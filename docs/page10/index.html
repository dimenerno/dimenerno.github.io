<!DOCTYPE html>
<html lang="en-us">
  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile" />
  <link href="https://fonts.googleapis.com/css2?family=Libre+Baskerville&display=swap" rel="stylesheet">
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />

  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=1"
  />

  <title>
     디멘의 블로그 &middot; 이데아를 여행하는 히치하이커
    
  </title>

  <style>
    .answer {
      display: none;
      margin-top: 10px;
      color: #333;
    }
  </style>

<style>
  .lang-toggle-wrapper {
    display: flex;
    align-items: center;
    gap: 0.4em;
    margin-right: 0.5em;
  }

  .lang-label {
    font-size: 0.9em;
    line-height: 1;
  }

  .switch {
    position: relative;
    display: inline-block;
    width: 44px;
    height: 24px;
  }

  .switch input {
    opacity: 0;
    width: 0;
    height: 0;
  }

  .slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #e7e8eb;
    transition: 0.4s;
    border-radius: 24px;
  }

  .slider::before {
    position: absolute;
    content: "";
    height: 18px;
    width: 18px;
    left: 3px;
    bottom: 3px;
    background-color: white;
    transition: 0.4s;
    border-radius: 50%;
  }

  .switch input:checked + .slider {
    background-color: #2e2e2e;
  }

  .switch input:checked + .slider::before {
    transform: translateX(20px);
  }

  .lang-ko, .lang-en {
  transition: opacity 0.3s ease;
}
</style>

  <script>
    function toggleAnswer(id) {
      const answer = document.getElementById("answer" + id);
      if (answer.style.display === "none" || answer.style.display === "") {
        answer.style.display = "block";
      } else {
        answer.style.display = "none";
      }
    }
  </script>

  <script>
    MathJax = {
      tex: {
        inlineMath: [
          ["$", "$"],
          ["\\(", "\\)"],
        ],
      },
      svg: {
        fontCache: "global",
      },
    };
  </script>
  <script
    type="text/javascript"
    id="MathJax-script"
    async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
  ></script>

  
  <link rel="canonical" href="/page10/" />
  

  <link rel="stylesheet" href="/public/css/poole.css" />
  <link rel="stylesheet" href="/public/css/syntax.css" />
  <link rel="stylesheet" href="/public/css/lanyon.css" />
  <link
    rel="stylesheet"
    href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400"
  />


  <link
    rel="apple-touch-icon-precomposed"
    sizes="144x144"
    href="/public/apple-touch-icon.png"
  />
  <link rel="shortcut icon" href="/public/favicon.ico" />
  <link
    rel="alternate"
    type="application/rss+xml"
    title="RSS"
    href=""
  />

  <script
    async
    src="https://www.googletagmanager.com/gtag/js?id=G-PVGYLWF7GR"
  ></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
      dataLayer.push(arguments);
    }
    gtag("js", new Date());

    gtag("config", "G-PVGYLWF7GR");
  </script>
</head>


  <style>
    /* 검색 입력창 */
    #search-input {
      padding: 6px 12px;
      font-size: 15px;
      border: 1px solid #eee;
      border-radius: 20px;
      outline: none;
      transition: all 0.2s ease-in-out;
      width: 90%;
      max-width: 240px;
      background-color: #fefefe;
    }

    #search-input::placeholder {
      color: var(--slate);
    }

    /* 입력창 포커스 시 */
    #search-input:focus {
      border-color: #9ea0a3;
      background-color: white;
    }

    @media (max-width: 600px) {
      .lang-label {
        display: none;
      }
    }
  </style>

  <body>
    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox" />

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p class="lang-ko">이데아를 여행하는 히치하이커</p>
    <p class="lang-en" style="display: none;">Alice in Logicland</p>
  </div>

  <nav class="sidebar-nav">
    <a
    class="sidebar-nav-item lang-ko"
    href="/"
    >메인</a>
    <a
    class="sidebar-nav-item lang-en"
    href="/"
    >Main</a
  >
                                                                                                                                                                                                     
    <a
      class="sidebar-nav-item lang-ko"
      href="/about/"
      >저에 대하여</a
    >
    <a
    class="sidebar-nav-item lang-en"
    href="/about/"
    >About Me</a
  >
        
    <a
      class="sidebar-nav-item lang-ko"
      href="/archive-date/"
      >날짜별로 보기</a
    >
    <a
    class="sidebar-nav-item lang-en"
    href="/archive-date/"
    >List by dates</a
  >
        
    <a
      class="sidebar-nav-item lang-ko"
      href="/archive-tag/"
      >주제별로 보기</a
    >
    <a
    class="sidebar-nav-item lang-en"
    href="/archive-tag/"
    >List by topics</a
  >
        
    <a
      class="sidebar-nav-item lang-ko"
      href="/random/"
      >랜덤 포스트</a
    >
    <a
    class="sidebar-nav-item lang-en"
    href="/random/"
    >Go to a random post</a
  >
        
    <a
      class="sidebar-nav-item lang-ko"
      href="/book/"
      >새벽의 자연학 수업</a
    >
    <a
    class="sidebar-nav-item lang-en"
    href="/book/"
    >Twilight Wonders (Korean)</a
  >
        
    <a
      class="sidebar-nav-item lang-ko"
      href="/notes/"
      >복습노트 아카이브</a
    >
    <a
    class="sidebar-nav-item lang-en"
    href="/notes/"
    >Maths Review Notes (Korean)</a
  >
        
    <a
      class="sidebar-nav-item lang-ko"
      href="/guestbook/"
      >방명록</a
    >
    <a
    class="sidebar-nav-item lang-en"
    href="/guestbook/"
    >Guestbook</a
  >
                      
  </nav>

  <div class="sidebar-item">
    <p>&copy; 2025. All rights reserved.</p>
    <p style="color: #202020">
      &copy; 2025. 디멘 reserved by 곰댕.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead" style="width: 100%">
        <div
          class="container"
          style="
            display: flex;
            justify-content: space-evenly;
            align-items: center;
            padding: 0px;
            margin-left: 4em;
            margin-right: 0;
            max-width: none;
            overflow-y: hidden;
          "
        >
          <h3
            class="masthead-title"
            style="
              display: flex;
              flex-direction: row;
              gap: 0.3em;
              align-items: end;
              line-height: 1;
            "
          >
            <a
              href="/"
              style="white-space: nowrap"
              class="lang-ko"
              title="Home"
              >디멘의 블로그</a>
            <a
              href="/"
              style="white-space: nowrap"
              class="lang-en"
              title="Home"
            >Dimen's Blog</a>
            <small><div class="lang-ko">이데아를 여행하는 히치하이커</div>
              <div class="lang-en">Alice in Logicland</div></small>

          </h3>
          <form
            id="search-form"
            action="/search.html"
            method="get"
            style="display: flex; justify-content: end; padding-right: 1em"
          >
            <input
              type="text"
              name="q"
              id="search-input"
              placeholder="검색"
            />
          </form>

          <div class="lang-toggle-wrapper">
            <span class="lang-label">한</span>
            <label class="switch">
              <input type="checkbox" id="lang-toggle" />
              <span class="slider round"></span>
            </label>
            <span class="lang-label">EN</span>
          </div>
        </div>
      </div>

      <div class="container content"><head>
  <style>
    .fade-rise-1 {
      opacity: 0;
      transform: translateY(20px);
      /* animation: fadeRise 0.8s ease-out forwards;
      animation-delay: 0.2s; */
    }

    .fade-rise-2 {
      opacity: 0;
      transform: translateY(20px);
      /* animation: fadeRise 0.8s ease-out forwards;
      animation-delay: 0.4s; */
    }

    .fade-rise-3 {
      opacity: 0;
      transform: translateY(20px);
      /* animation: fadeRise 0.8s ease-out forwards;
      animation-delay: 0.6s; */
    }

    /* 이미지가 로드된 후 추가될 클래스에 animation 속성 추가 */
    .fade-rise-1.is-loaded {
      animation: fadeRise 0.8s ease-out forwards 0.2s;
    }
    .fade-rise-2.is-loaded {
      animation: fadeRise 0.8s ease-out forwards 0.4s;
    }
    .fade-rise-3.is-loaded {
      animation: fadeRise 0.8s ease-out forwards 0.6s;
    }

    @keyframes fadeRise {
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .fade-in-section {
      opacity: 0;
      transform: translateY(10px);
      transition: opacity 0.5s ease-out, transform 0.5s ease-out;
    }

    .fade-in-section.is-visible {
      opacity: 1;
      transform: none;
    }

    .spacer {
      height: 100vh;
    }
  </style>
</head>



<div class="posts">
  
    <div class="post fade-in-section" data-lang="ko" style="display: none">
      <h1 class="post-title">
        <a href="/2024/12/16/adjoints"> 어드조인트에 대한 직관적 이해 </a>
      </h1>
    <span class="post-date">16 Dec 2024</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/수학/'">
        수학
      </div>
      
      <div class="tag" onclick="location.href='/tags/범주론/'">
        범주론
      </div>
      
    </div>
     <p>카테고리 이론의 핵심 개념 중 하나는 어드조인트(adjoint)이다.</p>

<blockquote>
  <p><strong>정의.</strong> $\mathcal{A}, \mathcal{B}$가 카테고리이고, $F: \mathcal{A} \to \mathcal{B}, G: \mathcal{B} \to \mathcal{A}$가 함자(functor)라고 하자. $F$가 $G$의 <strong>좌 어드조인트(left adjoint)</strong>라는 것은 임의의 $A \in \mathcal{A}, B \in \mathcal{B}$에 대해 $\mathcal{B}(F(A), B)$와 $\mathcal{A}(A, G(B))$가 자연스럽게 일대일 대응될 수 있다는 것이다. 즉,</p>

\[\begin{gather}
(F(A) \xrightarrow{g} B) \quad \mapsto \quad (A \xrightarrow{\bar{g}} G(B))\\
(A \xrightarrow{f} G(B)) \quad \mapsto \quad (F(A) \xrightarrow{\bar{f}} B)
\end{gather}\]

  <p>또한 $G$를 $F$의 <strong>우 어드조인트(right adjoint)</strong>라고 한다. 기호로 $F \dashv G$로 표기한다.</p>
</blockquote>

<p>필자는 이 정의를 형식적인 수준에서만 이해하고 있었는데, 최근 어드조인트를 직관적으로 이해하는 몇 가지 방식을 발견했다.</p>

<h3 id="1-형-변환으로서의-어드조인트">1. 형 변환으로서의 어드조인트</h3>

<p>좌 어드조인트는 프로그래밍에서 다운캐스팅 형 변환에, 우 어드조인트는 업캐스팅 형 변환에 비견할 수 있다.</p>

<p>예를 들어 $\mathbf{Z}$가 정수를 원소로 가지고, $x \leq y$일 때 그리고 오직 그 경우에만 $x \to y$ 사상이 유일하게 존재하는 카테고리라고 하자. 또한 $\mathbf{Z}^2$가 정수쌍을 원소로 가지고, $\mathbf{x} \preceq \mathbf{y}$일 때 그리고 오직 그 경우에만 $\mathbf{x} \to \mathbf{y}$ 사상이 유일하게 존재하는 카테고리라고 하자(여기서 $\preceq$는 사전식 순서이다).</p>

<p>$F: \mathbf{Z} \to \mathbf{Z}^2, G: \mathbf{Z}^2 \to \mathbf{Z}$가 각각 $F(x) = (x, 0), G(x, y) = x$라면 자연스러운 방식으로 함자가 된다. 또한 $F \dashv G$이다. $x \in \mathbf{Z}, y \in \mathbf{Z}^2$에 대해 $F(x) \leq y$라면 $x \leq G(y)$이고, 그 역도 성립하기 때문이다.</p>

<p><img src="https://velog.velcdn.com/images/dimenerno/post/8040c20d-c1bc-4d92-bd45-256f48b79d75/image.png" alt="" /></p>

<p>위의 논의를 코드로 표현하면 다음과 같다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Z</span> <span class="o">{</span>
	<span class="kt">int</span> <span class="n">x</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Z2</span> <span class="kd">extends</span> <span class="no">Z</span> <span class="o">{</span>
	<span class="c1">// int x;</span>
	<span class="kt">int</span> <span class="n">y</span><span class="o">;</span>
<span class="o">}</span>

<span class="no">Z2</span> <span class="nf">F</span><span class="o">(</span><span class="no">Z</span> <span class="n">z</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">return</span> <span class="k">new</span> <span class="nf">Z2</span><span class="o">(</span><span class="n">z</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
<span class="o">}</span>

<span class="no">Z</span> <span class="nf">G</span><span class="o">(</span><span class="no">Z2</span> <span class="n">z2</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">return</span> <span class="k">new</span> <span class="nf">Z</span><span class="o">(</span><span class="n">z2</span><span class="o">.</span><span class="na">x</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이 코드에서 $F$는 실질적으로 다운캐스팅, $G$는 업캐스팅에 해당함에 주목하라.</p>

<h3 id="2-근사로서의-어드조인트">2. 근사로서의 어드조인트</h3>

<p>$F \dashv G$일 때 $F, G$는 $\mathcal{A}$과 $\mathcal{B}$의 원소들을 서로 근사하는 방법으로 생각할 수 있다. 특히 좌 어드조인트는 ‘좌측에서 우측으로‘의 근사이고, 우 어드조인트는 ‘우측에서 좌측으로’의 근사이다.</p>

<p>예를 들어 $\mathbf{Z}$가 정수를 원소로 가지고, $x \leq y$일 때 그리고 오직 그 경우에만 $x \to y$ 사상이 유일하게 존재하는 카테고리라고 하자. 또한 $\mathbf{R}$이 실수를 원소로 가지고, $x \leq y$일 때 그리고 오직 그 경우에만 $x \to y$ 사상이 유일하게 존재하는 카테고리라고 하자. 이때 $\lceil \cdot \rceil, \lfloor \cdot \rfloor$는 표준적인 방식으로 함자 $\mathbf{R} → \mathbf{Z}$가 되고, 포함 사상 $\iota$는 함자 $\mathbf{Z} → \mathbf{R}$이 된다. 또한 $\lceil \cdot \rceil \dashv \iota \dashv \lfloor \cdot \rfloor$임을 확인할 수 있다.</p>

<p><img src="https://velog.velcdn.com/images/dimenerno/post/e26ee728-09b0-4280-ac4c-511f89cef615/image.png" alt="" /></p>

<p>즉 $\lceil \cdot \rceil$는 $r$을 $r \leq \lceil r \rceil$로 ‘좌측에서 우측으로 끌어올리는’ 변환이고, $\lfloor \cdot \rfloor$은 $r$을 $\lfloor r \rfloor \leq r$로 ‘우측에서 좌측으로 잡아당기는’ 변환이다.</p>

<p>또한 $I, T$가 각각 $\mathcal{A}$의 초기 대상(initial object) 및 종단 대상(terminal object)라고 하자. 즉, 임의의 $A \in \mathcal{A}$에 대해</p>

<ul>
  <li>사상 $I \to A$가 유일하게 존재한다.</li>
  <li>사상 $A \to T$가 유일하게 존재한다.</li>
</ul>

<p>일례로 $\mathbf{Set}$에서 공집합은 초기 대상이고 홑원소 집합은 종단 대상이다.</p>

<p>홑원소 카테고리 $\mathcal{U}$에 대해 함자 $F: \mathcal{A} \to \mathcal{U}$가 유일하게 존재한다. $G_I, G_T: \mathcal{U} \to \mathcal{A}$가 각각 상이 $I, T$인 함자라고 하자. 이때 앞선 경우와 비슷한 원리로 $G_T \dashv F \dashv G_I$가 됨을 확인하라. (종단 대상은 가장 “오른쪽”에 있는 대상이므로 $G_T$는 “왼쪽에서 오른쪽으로”의 근사이며, 초기 대상은 가장 “왼쪽”에 있는 대상이므로 $G_I$는 “오른쪽에서 왼쪽으로”의 근사이다.)</p>

<h3 id="3-구축과-파괴로서의-어드조인트">3. 구축과 파괴로서의 어드조인트</h3>

<p>좌 어드조인트는 구축을, 우 어드조인트는 파괴를 의미한다. 따라서 일반적으로 자유함자(free functor)는 좌 어드조인트, 망각함자(forgetful functor)는 우 어드조인트이다.</p>

<p>일례로 군의 카테고리를 $\mathbf{Grp}$, 모노이드의 카테고리를 $\mathbf{Mon}$이라 하자. $F$를 자유함자, $U$를 망각함자라고 하자. 그리고 $R: \mathbf{Mon} → \mathbf{Grp}$를 다음과 같이 정의한다.</p>

<ul>
  <li>$R(M) = \lbrace  m \in M : \exists m^{-1} \in M \rbrace$</li>
  <li>$R(f): m \mapsto f(m)$</li>
</ul>

<p>이 때, 다음 다이어그램이 성립하여 $F \dashv U \dashv R$이다.</p>

<p><img src="https://velog.velcdn.com/images/dimenerno/post/1640d6b4-bd6a-4098-9fe8-e9a7ab164041/image.png" alt="" /></p>

<p>$R$이 $U$보다 더 파괴적이기 때문에 $U \dashv R$인 것으로 이해할 수 있다.</p>


  </div>
  <div style="margin-bottom: 6em"></div>
  
    <div class="post fade-in-section" data-lang="en" style="display: none">
      <h1 class="post-title">
        <a href="/2024/12/16/adjoints/en"> An Intuitive Understanding of Adjoints </a>
      </h1>
    <span class="post-date">16 Dec 2024</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/mathematics/'">
        Mathematics
      </div>
      
      <div class="tag" onclick="location.href='/tags/category-theory/'">
        Category Theory
      </div>
      
    </div>
     <blockquote>
  <p>This post was machine translated and has not yet been proofread. It may contain minor errors or unnatural expressions. Proofreading will be done in the near future.</p>
</blockquote>

<p>One of the central concepts in category theory is that of an adjoint.</p>

<blockquote>
  <p><strong>Definition.</strong> Let $\mathcal{A}, \mathcal{B}$ be categories, and let $F: \mathcal{A} \to \mathcal{B}, G: \mathcal{B} \to \mathcal{A}$ be functors. We say that $F$ is a <strong>left adjoint</strong> to $G$ if for any $A \in \mathcal{A}, B \in \mathcal{B}$, there exists a natural bijection between $\mathcal{B}(F(A), B)$ and $\mathcal{A}(A, G(B))$. That is,</p>

\[\begin{gather}
(F(A) \xrightarrow{g} B) \quad \mapsto \quad (A \xrightarrow{\bar{g}} G(B))\\
(A \xrightarrow{f} G(B)) \quad \mapsto \quad (F(A) \xrightarrow{\bar{f}} B)
\end{gather}\]

  <p>We also call $G$ the <strong>right adjoint</strong> to $F$. This is denoted symbolically as $F \dashv G$.</p>
</blockquote>

<p>The author previously understood this definition only at a formal level, but has recently discovered several ways to understand adjoints intuitively.</p>

<h3 id="1-adjoints-as-type-conversions">1. Adjoints as Type Conversions</h3>

<p>Left adjoints can be likened to downcasting type conversions in programming, whilst right adjoints correspond to upcasting type conversions.</p>

<p>For instance, let $\mathbf{Z}$ be a category whose objects are integers, with a unique morphism $x \to y$ existing if and only if $x \leq y$. Similarly, let $\mathbf{Z}^2$ be a category whose objects are pairs of integers, with a unique morphism $\mathbf{x} \to \mathbf{y}$ existing if and only if $\mathbf{x} \preceq \mathbf{y}$ (where $\preceq$ denotes the lexicographic order).</p>

<p>If $F: \mathbf{Z} \to \mathbf{Z}^2, G: \mathbf{Z}^2 \to \mathbf{Z}$ are defined by $F(x) = (x, 0)$ and $G(x, y) = x$ respectively, then they naturally become functors. Moreover, $F \dashv G$. This is because for $x \in \mathbf{Z}, y \in \mathbf{Z}^2$, we have $F(x) \leq y$ if and only if $x \leq G(y)$.</p>

<p><img src="https://velog.velcdn.com/images/dimenerno/post/8040c20d-c1bc-4d92-bd45-256f48b79d75/image.png" alt="" /></p>

<p>The above discussion can be expressed in code as follows:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Z</span> <span class="o">{</span>
	<span class="kt">int</span> <span class="n">x</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Z2</span> <span class="kd">extends</span> <span class="no">Z</span> <span class="o">{</span>
	<span class="c1">// int x;</span>
	<span class="kt">int</span> <span class="n">y</span><span class="o">;</span>
<span class="o">}</span>

<span class="no">Z2</span> <span class="nf">F</span><span class="o">(</span><span class="no">Z</span> <span class="n">z</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">return</span> <span class="k">new</span> <span class="nf">Z2</span><span class="o">(</span><span class="n">z</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
<span class="o">}</span>

<span class="no">Z</span> <span class="nf">G</span><span class="o">(</span><span class="no">Z2</span> <span class="n">z2</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">return</span> <span class="k">new</span> <span class="nf">Z</span><span class="o">(</span><span class="n">z2</span><span class="o">.</span><span class="na">x</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Note that in this code, $F$ essentially corresponds to downcasting, whilst $G$ corresponds to upcasting.</p>

<h3 id="2-adjoints-as-approximations">2. Adjoints as Approximations</h3>

<p>When $F \dashv G$, the functors $F$ and $G$ can be thought of as methods for approximating objects in $\mathcal{A}$ and $\mathcal{B}$ with respect to each other. In particular, the left adjoint represents approximation ‘from left to right’, whilst the right adjoint represents approximation ‘from right to left’.</p>

<p>For example, let $\mathbf{Z}$ be a category whose objects are integers, with a unique morphism $x \to y$ existing if and only if $x \leq y$. Similarly, let $\mathbf{R}$ be a category whose objects are real numbers, with a unique morphism $x \to y$ existing if and only if $x \leq y$. Then $\lceil \cdot \rceil, \lfloor \cdot \rfloor$ become functors $\mathbf{R} → \mathbf{Z}$ in the standard manner, and the inclusion map $\iota$ becomes a functor $\mathbf{Z} → \mathbf{R}$. Moreover, one can verify that $\lceil \cdot \rceil \dashv \iota \dashv \lfloor \cdot \rfloor$.</p>

<p><img src="https://velog.velcdn.com/images/dimenerno/post/e26ee728-09b0-4280-ac4c-511f89cef615/image.png" alt="" /></p>

<p>That is, $\lceil \cdot \rceil$ is a transformation that ‘lifts from left to right’ by mapping $r$ to $\lceil r \rceil$ with $r \leq \lceil r \rceil$, whilst $\lfloor \cdot \rfloor$ is a transformation that ‘pulls from right to left’ by mapping $r$ to $\lfloor r \rfloor$ with $\lfloor r \rfloor \leq r$.</p>

<p>Furthermore, let $I$ and $T$ be the initial object and terminal object of $\mathcal{A}$ respectively. That is, for any $A \in \mathcal{A}$:</p>

<ul>
  <li>There exists a unique morphism $I \to A$.</li>
  <li>There exists a unique morphism $A \to T$.</li>
</ul>

<p>For instance, in $\mathbf{Set}$, the empty set is the initial object and any singleton set is a terminal object.</p>

<p>For the singleton category $\mathcal{U}$, there exists a unique functor $F: \mathcal{A} \to \mathcal{U}$. Let $G_I, G_T: \mathcal{U} \to \mathcal{A}$ be functors with images $I$ and $T$ respectively. Then by a similar principle to the previous case, one can verify that $G_T \dashv F \dashv G_I$. (Since the terminal object is the ‘rightmost’ object, $G_T$ represents approximation ‘from left to right’, whilst since the initial object is the ‘leftmost’ object, $G_I$ represents approximation ‘from right to left’.)</p>

<h3 id="3-adjoints-as-construction-and-destruction">3. Adjoints as Construction and Destruction</h3>

<p>Left adjoints signify construction, whilst right adjoints signify destruction. Therefore, free functors are generally left adjoints, whilst forgetful functors are right adjoints.</p>

<p>For instance, let $\mathbf{Grp}$ be the category of groups and $\mathbf{Mon}$ be the category of monoids. Let $F$ be the free functor and $U$ be the forgetful functor. Define $R: \mathbf{Mon} → \mathbf{Grp}$ as follows:</p>

<ul>
  <li>$R(M) = \lbrace  m \in M : \exists m^{-1} \in M \rbrace$</li>
  <li>$R(f): m \mapsto f(m)$</li>
</ul>

<p>Then the following diagram holds, yielding $F \dashv U \dashv R$.</p>

<p><img src="https://velog.velcdn.com/images/dimenerno/post/1640d6b4-bd6a-4098-9fe8-e9a7ab164041/image.png" alt="" /></p>

<p>One can understand that $U \dashv R$ because $R$ is more destructive than $U$.</p>

  </div>
  <div style="margin-bottom: 6em"></div>
  
    <div class="post fade-in-section" data-lang="ko" style="display: none">
      <h1 class="post-title">
        <a href="/2024/12/11/rolling"> 굴림에 대한 두 가지 삽화 </a>
      </h1>
    <span class="post-date">11 Dec 2024</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/물리학/'">
        물리학
      </div>
      
      <div class="tag" onclick="location.href='/tags/역학/'">
        역학
      </div>
      
    </div>
     <p>학부 시절 고전역학 수강 때 개인 공부용으로 만든 삽화인데, 잘 정리한 듯하여 이곳에도 공유한다.</p>

<p><img src="/public/rot-kr.png" style="width: 100%; margin: 0 auto" /></p>

<p><img src="/public/rolling-on-ground.png" style="width: 100%; margin: 4em auto 0em auto" /></p>

<p>굴림을 바퀴의 CM 기준으로 분석할 때 <strong>땅 또한 움직인다는 사실</strong>에 유의하자.</p>

  </div>
  <div style="margin-bottom: 6em"></div>
  
    <div class="post fade-in-section" data-lang="en" style="display: none">
      <h1 class="post-title">
        <a href="/2024/12/11/rolling/en"> Two Illustrations on Rolling </a>
      </h1>
    <span class="post-date">11 Dec 2024</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/physics/'">
        Physics
      </div>
      
      <div class="tag" onclick="location.href='/tags/mechanics/'">
        Mechanics
      </div>
      
    </div>
     <p>These are illustrations I made when I studied classical mechanics in my BA. They seem to be well-made, so I decided to share them here, too.</p>

<p><img src="/public/rot-en.png" style="width: 100%; margin: 0 auto" /></p>

<p>Note that decomposing Revolution as the sum of Rotation about CM and Rotation about Axis is a specific case of the central axis theorem.</p>

<p><img src="/public/rolling-on-ground.png" style="width: 100%; margin: 4em auto 0em auto" /></p>

<p>Note that when analysing Rolling from CM’s frame, the ground also moves at $v = -r\omega$.</p>

  </div>
  <div style="margin-bottom: 6em"></div>
  
    <div class="post fade-in-section" data-lang="ko" style="display: none">
      <h1 class="post-title">
        <a href="/2024/12/11/VL-axiom"> V = L 공리의 무모순성 </a>
      </h1>
    <span class="post-date">11 Dec 2024</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/수학/'">
        수학
      </div>
      
      <div class="tag" onclick="location.href='/tags/집합론/'">
        집합론
      </div>
      
    </div>
     <h2 id="1-전체">1. 전체</h2>

<h3 id="11-폰-노이만-전체">1.1. 폰 노이만 전체</h3>

<p><a href="https://dimenerno.github.io/2024/12/05/transfinite-recursion/">초한귀납적으로</a> $\lbrace  V_\alpha \rbrace$를 정의하자.</p>

<ul>
  <li>$V_0 = \varnothing$</li>
  <li>$V_{\alpha + 1} = V_\alpha \cup \mathcal{P}(V_\alpha)$</li>
  <li>$\lambda$가 극한 서수일 때, $V_\lambda = \bigcup_{\alpha &lt; \lambda} V_\alpha$</li>
</ul>

<p>처음 몇 개의 $V_\alpha$는 다음과 같다.</p>

<ul>
  <li>$V_1 = \lbrace  \varnothing \rbrace$</li>
  <li>$V_2 = \lbrace  \varnothing, \lbrace  \varnothing \rbrace \rbrace$</li>
  <li>$V_3 = \lbrace  \varnothing, \lbrace  \varnothing \rbrace, \lbrace  \lbrace  \varnothing \rbrace \rbrace, \lbrace  \varnothing, \lbrace  \lbrace  \varnothing\rbrace \rbrace  \rbrace$</li>
  <li>$V_\omega = \mathsf{HF}$</li>
</ul>

<p>모든 서수 $\alpha$에 대해 $V_\alpha$를 모아둔 모임을 <strong>폰 노이만 전체</strong>라고 한다.</p>

\[V = \bigcup_{\alpha \in \mathrm{Ord}} V_\alpha\]

<p>$x \in y \in z$가 $x \in z$를 시사할 때 $z$를 <strong>추이적 집합(transitive set)</strong>이라고 한다. 이것은 $V$의 중요한 특징이다.</p>

<blockquote>
  <p><strong>정리.</strong></p>

  <ol>
    <li>$\alpha \in \mathrm{Ord}$에 대해 $V_\alpha$는 추이적이다.</li>
    <li>$V$는 추이적이다.</li>
  </ol>
</blockquote>

<p>증명은 초한귀납법을 이용한다. 이에 따라 $V$를 다음과 같이 정의해도 무방하다.</p>

<ul>
  <li>$V_0 = \varnothing$</li>
  <li>$V_{\alpha + 1} = \mathcal{P}(V_\alpha)$</li>
  <li>$\lambda$가 극한 서수일 때, $V_\lambda = \bigcup_{\alpha &lt; \lambda}V_\alpha$</li>
</ul>

<p>직관적으로 생각했을 때 $V$는 모든 집합을 포함하는 듯하다. 실제로 다음을 증명할 수 있다.</p>

<blockquote>
  <p><strong>정리.</strong> $x$가 집합이라면 $x \in V$이다.</p>
</blockquote>

<p><strong>증명.</strong> 집합 $x$에 대해 $x$의 <strong>추이적 폐포</strong> $\bar{x}$를, $x$를 원소로 가지는 가장 작은 추이적 집합으로 정의한다(추이적 집합들의 교집합은 추이적이기 때문에 이 정의는 정당하다).</p>

<p>$x \notin V$라고 가정하자. 분류 공리에 의해 $y = \lbrace  u \in \bar{x} : u \notin V \rbrace$가 집합이며, 정초 공리에 의해 $y$의 $\in$-극소 원소 $z$가 존재한다. 만약 $w \notin V$인 $w \in z$가 존재한다면,  추이성에 의해 $w \in y$가 되어 $z$의 $\in$-극소성과 모순된다. 따라서 $z$의 모든 원소는 $V$에 있으며, 치환 공리로부터 $\Omega = \lbrace  \alpha \in \mathrm{Ord} \mid \exists w \in z : w \in V_\alpha\rbrace$가 집합이다. 부랄리포르티 정리에 의해 $\beta = \bigcup_{\alpha \in \Omega}\alpha$가 서수이며, <strong>$z \in V_{\beta + 1}$이다.</strong> (이 부분에서 $V_{\beta + 1} = \mathcal{P}(V_\beta)$임이 필요하다) 따라서 모순이다. ■</p>

<p>이에 따라 $V$는 집합이 아니다. 따라서 $V$는 모든 집합을 포함한다는 점에서 ZFC의 모델이지만, <a href="https://math.stackexchange.com/questions/56726/how-can-there-be-genuine-models-of-set-theory">많은 수학자들은 모델이 집합일 것을 요구하기 때문에</a> 엄격한 의미에서의 모델은 아니다. 하지만 이 글에서는 편의를 위해 $V$를 집합론의 모델이라고 부르도록 한다. 또한 $x \in V$를 “$x$는 집합이다“의 형식적 표현으로 이해하도록 한다.</p>

<h3 id="12-괴델-구성-가능-전체">1.2. 괴델 구성 가능 전체</h3>

<p>먼저 다음과 같이 구성 가능성을 정의한다.</p>

<blockquote>
  <p><strong>정의.</strong> $u$가 집합 $S$로부터 <strong>구성 가능</strong>하다는 것은, 어떤 1차 논리 명제 $\phi(y, x_1, \dots, x_n)$와 $c_1, \dots, c_n \in S$가 존재하여 다음이 성립하는 것이다.</p>

\[y \in u \iff y \in S \land \phi(y, c_1, \dots, c_n)\]

  <p>단, $\phi$의 양화사의 정의역은 $S$이다.</p>
</blockquote>

<p>예를 들어 $S = \lbrace 0, 1, 2\rbrace$일 때 다음은 $u = \lbrace  1, 2 \rbrace$를 구성한다.</p>

<ul>
  <li>$\phi(y, x_1, x_2) := (y = x_1) \lor (y = x_2)$</li>
  <li>$c_1 = 1, c_2 = 2$</li>
</ul>

<p>또한 $S = \mathbb{N}$일 때 다음은 $u = \lbrace 0, 3, 6, 9, \dots \rbrace$를 구성한다.</p>

<ul>
  <li>$\phi(y, x_1) := x_1 \mid y$</li>
  <li>$c_1 = 3$</li>
</ul>

<p>괴델의 구성가능성은 일반적인 의미에서의 구성가능성, 즉 언어로서의 표현가능성과 다르다. 일례로 언어로 표현가능한 실수의 집합은 가산이므로, 어떤 실수는 언어로 표현이 불가능하다. 그러한 실수를 $r$이라고 하자. 이제 $S = \mathbb{R}$일 때, 다음은 $u = \lbrace  r \rbrace$을 구성한다.</p>

<ul>
  <li>$\phi(y, x_1) := x_1 = y$</li>
  <li>$c_1 = r$</li>
</ul>

<p>즉, 괴델의 구성가능성은 자유변수의 초기화를 임의의 원소에 대해 허용한다는 점에서 강력하다. 그러나 자유변수의 수가 유한하다는 점에서 한계를 가진다. 이제 초한귀납적으로 $\lbrace  L_\alpha \rbrace$를 정의하자.</p>

<ul>
  <li>$L_0 = \varnothing$</li>
  <li>$L_{\alpha + 1} = \lbrace  x : x \text{ is constructible from } L_\alpha  \rbrace$</li>
  <li>$\lambda$가 극한 서수일 때, $L_\lambda = \bigcup_{\alpha &lt; \lambda} L_\alpha$</li>
  <li>$L = \bigcup_{\alpha &lt; \lambda} L_\alpha$</li>
</ul>

<p>$\alpha &lt; \omega$일 때 $L_\alpha = V_\alpha$임을 쉽게 보일 수 있다. $\alpha = n$일 때, 최대 $n$개의 $\lor$ 연언으로 $x \in V_\alpha$를 구성할 수 있기 때문이다. 따라서,</p>

<ul>
  <li>$L_1 = \lbrace  \varnothing \rbrace$</li>
  <li>$L_2 = \lbrace  \varnothing, \lbrace  \varnothing \rbrace \rbrace$</li>
  <li>$L_3 = \lbrace  \varnothing, \lbrace  \varnothing \rbrace, \lbrace  \lbrace  \varnothing \rbrace \rbrace, \lbrace  \varnothing, \lbrace  \lbrace  \varnothing\rbrace \rbrace  \rbrace$</li>
  <li>$L_\omega = \mathsf{HF}$</li>
</ul>

<p>하지만 $L_{\omega + 1} \subsetneq V_{\omega + 1}$이다. $\mathcal{P}(\mathbb{N}) \subset V_{\omega + 1}$이므로 $V_{\omega + 1}$은 비가산인 반면, 1차 논리 문장들의 집합과  $L_\omega$는 모두 가산이므로 $L_{\omega + 1}$ 또한 가산이기 때문이다. 일반적으로 $\alpha$가 가산일 때 $L_\alpha$는 가산이다.</p>

<p>그럼에도 $L$은 $V$와 많은 특징을 공유한다. 일례로,</p>

<blockquote>
  <p><strong>정리.</strong> $\alpha \in \mathrm{Ord}$에 대해 다음이 성립한다.</p>

  <ol>
    <li>$L_\alpha$는 추이적이다. (따라서 $L$이 추이적이다)</li>
    <li>$\alpha \in L_{\alpha + 1} \setminus L_{\alpha}$</li>
  </ol>
</blockquote>

<p>증명은 초한귀납법을 사용한다.</p>

<p>$L$은 모든 서수를 포함하므로 부랄리포르티 정리에 의해 집합이 아님에 유의하라. 대신 $x \in L_\alpha$에 대응되는 1차 논리식 $\mathsf{IsInL}_\alpha(x)$가 존재한다. 증명은 조금 까다로운데, 괴델 수를 이용하여 명제를 산술화하면 된다. (<a href="https://math.stackexchange.com/questions/198437/a-formula-that-defines-constructible-universe">링크</a> 참조) 따라서 $x \in L$을 $\exists \alpha \in \mathrm{Ord} :\mathsf{IsInL}_\alpha(x)$를 대체하는 형식적 표현으로 이해하여 사용하도록 한다. (물론 $\alpha \in \mathrm{Ord}$ 또한 1차 논리식을 대체하는 형식적 표현으로 이해되어야 한다)</p>

<h2 id="2-상대화">2. 상대화</h2>

<h3 id="21-명제의-상대화">2.1. 명제의 상대화</h3>

<p>1차 논리 명제는 양화사를 포함할 수 있다. 때문에 양화사의 정의역을 어떻게 설정하느냐의 따라 명제의 의미가 달라진다.</p>

<p>명제 $\phi$와 집합 (또는 모임) $A$에 대해, $\phi$의 상대화 $\phi^A$를 $\phi$의 모든 양화사를 $A$로 제한한 명제로 정의한다. 약간의 서사적 표현을 곁들이자면, $\phi^A$는 $A$의 “내부”에서 이해한 $\phi$라고 할 수 있겠다. 예를 들어, $\phi : \forall x \; \exists y : y &lt; x$일 때</p>

<ul>
  <li>$\phi^\mathbb{N} : \forall x \in \mathbb{N} \; \exists y \in \mathbb{N} : y &lt; x$</li>
  <li>$\phi^\mathbb{Z} : \forall x \in \mathbb{Z} \; \exists y \in \mathbb{Z} : y &lt; x$</li>
</ul>

<p>$T_\mathbb{Q}$가 자연수 및 정수를 특정할 수 있는 정도의 표현력을 지니는 유리수 이론이라고 하면,</p>

<ul>
  <li>$T_\mathbb{Q} \vdash \phi$</li>
  <li>$T_\mathbb{Q} \not\vdash \phi^\mathbb{N}$</li>
  <li>$T_\mathbb{Q} \vdash \phi^{\mathbb{Z}}$</li>
</ul>

<p>이다. 따라서 $\phi$는 자연수와 유리수를 성공적으로 구분해 내지만, 정수와 유리수는 구분해 내지 못한다. 이 관찰을 일반화하면, 이론 $T$와 집합 $A$에 대해 $T \vdash \phi \leftrightarrow \phi^A$인 $\phi$가 많으면 많을수록 $A$는 $T$의 기술에 잘 “부합한다“고 말할 수 있다.</p>

<p>위 논의를 조금 일반화하여, 다음과 같이 정의한다.</p>

<blockquote>
  <p><strong>정의.</strong> 이론 $T$와 집합 $A$에 대해서</p>

\[T \vdash \forall x_1, \dots, x_n \in A (\phi(x_1, \dots, x_n) \leftrightarrow \phi^A(x_1, \dots, x_n))\]

  <p>일 때, $\phi$는 $A$에 대해 <strong>절대적(absolute)</strong>이라고 한다.</p>
</blockquote>

<p>일례로 $T_\mathbb{Q}$에 대해 $\phi(x) : \exists y (y &lt; x)$는 정수에 대해 절대적이지만 자연수에 대해 절대적이지는 않다.</p>

<h3 id="22-l-상대화">2.2. $L$-상대화</h3>

<p>이제 우리의 목표는 $L$이 $\mathsf{ZF}$와 극대적으로 부합함을 보이는 것이다. 즉,</p>

<blockquote>
  <p><strong>정리 1.</strong> $\phi$가 ZF의 공리라면 $\mathsf{ZF} \vdash \phi^L$이다.</p>
</blockquote>

<p>정리 1의 의미를 말로 풀어 보자면,</p>

<blockquote>
  <p>“$L$의 내부에서 보았을 때 $L$은 ZF의 모델이다”를 ZF로 증명할 수 있다.</p>
</blockquote>

<p>물론 우리는 $L \subset V$만 알고 $V = L$인지는 알지 못하기 때문에, 어떤 집합 $x$는 $L$에 속하지 않을 수도 있다. 그러나 설령 $x \in V \setminus L$인 집합 $x$가 있더라도, 그러한 $x$의 결여는 $L$의 <em>내적 정합성</em>을 깨뜨리지 않는다는 것이 정리 1의 내용이다.</p>

<p>예를 들어 어떤 집합 $y, z$에 대해 $x = \lbrace  y, z \rbrace$가 $L$에 결여되어 있다고 하자. 일면 $x$의 결여는 $L$이 짝 공리 $\mathsf{Pair}$을 만족하지 않음을 시사하는 듯하다.</p>

\[\mathsf{Pair} := \forall y, z \; \exists x \; \forall w: w \in x \leftrightarrow (w = y \lor w = z)\]

<p>하지만 $L$의 내부에서 본 짝 공리는 다음과 같다.</p>

\[\mathsf{Pair}^L := \forall y, z \in L \; \exists x \in L \; \forall w \in L: w \in x \leftrightarrow (w = y \lor w = z)\]

<p>$\forall y, z$의 양화 또한 $L$로 한정됨에 주목하라. 즉, $x = \lbrace  y, z \rbrace$의 결여가 $L$에게 문제를 일으키는 경우는 $y, z \in L$일 때이다. 거꾸로 말해, $x = \lbrace  y, z \rbrace \notin L$이 $y, z \notin L$을 시사한다면 $L$은 $\mathsf{Pair}^L$을 만족한다. 이것이 “$L$이 내적 정합성을 유지하는 방식으로 집합을 결여한다”의 의미이다.</p>

<p>정리 1이 성립하는 핵심 이유는 $L$과 $V$가 <strong>추이성이라는 성질을 공유</strong>하기 때문이다.</p>

<blockquote>
  <p><strong>보조정리.</strong> 다음 술어는 ZF에서 $L$에 대해 절대적이다.</p>

  <ol>
    <li>$x \in y$</li>
    <li>$x \subset y$</li>
    <li>$x = \bigcup y$</li>
    <li>$x = \lbrace  y, z \rbrace$</li>
    <li>$\alpha \in \mathrm{Ord}$</li>
    <li>$x$는 추이적이다.</li>
    <li><a href="https://math.stackexchange.com/questions/404699/delta-0-formulas">$\Delta_0$ 논리식</a></li>
  </ol>
</blockquote>

<p>또한 다음을 증명할 수 있다.</p>

<blockquote>
  <p><strong>정리 2.</strong> $\mathsf{ZF} \vdash (V = L)^L$</p>
</blockquote>

<p>여기서 $V = L$은, “모든 집합이 $L$에 속한다”를 의미한다. 따라서 일면 보기에 $(V = L)^L$은 “$L$에 속하는 모든 집합이 $L$에 속한다”라는 자명한 명제인 듯하다. 하지만 실제로 $V = L$을 논리식으로 적으면</p>

\[\forall x \; \exists \alpha  : \alpha \in \mathrm{Ord} \land x \in L_\alpha\]

<p>이므로 $(V = L)^L$은</p>

\[\forall x \in L \; \exists \alpha \in L : (\alpha \in \mathrm{Ord})^L \land (x \in L_\alpha)^L\]

<p>이다. 특히, $\alpha \in \mathrm{Ord}$와 $x \in L_\alpha$가 진정한 의미에서의 $\in$-술어가 아닌 1차 논리식의 형식적 표현이기 때문에 마찬가지로 $L$로 상대화해야 함에 유의하라. 이에 따라 $(V = L)^L$을 ZF에서 증명하기 위해서는 $\alpha \in \mathsf{Ord}$와 $x \in L_\alpha$가 절대적임을 증명해야 한다. 두 증명 모두 초한귀납법을 사용하면 가능하다.</p>

<p>정리 1과 정리 2로부터 다음을 증명할 수 있다.</p>

<blockquote>
  <p><strong>정리 3.</strong> $\mathsf{ZFL} \vdash \phi \implies \mathsf{ZF} \vdash \phi^L$</p>
</blockquote>

<p><strong>증명.</strong> $\mathsf{ZFL} \vdash \phi$의 증명 길이에 대한 귀납법으로 증명한다. 증명 길이가 0일 때 $\phi$는 ZFL의 공리이다. $\phi$가 ZF의 공리일 때 정리 1로부터 증명되고, $\phi$가 $V = L$일 때 정리 2로부터 증명된다.</p>

<p>이제 $\phi$가 $\lbrace  \psi_1, \dots, \psi_n \rbrace$에 추론 규칙을 적용하는 것으로 증명된다고 가정하자. $\psi_k$의 증명 길이는 $\phi$보다 작으므로 귀납 가정에 의해 $\mathsf{ZF} \vdash \psi_k^L$이며,  논리 공리와 추론 규칙은 $L$에 대해 절대적임을 쉽게 보일 수 있다. 따라서 $(\psi_1 \land \dots \land \psi_n) \rightarrow \phi$가 논리적 참이라면 $(\psi_1^L \land \dots \land \psi_n^L) → \phi^L$ 또한 논리적 참이며, 이에 따라 $\mathsf{ZF} \vdash \phi^L$이다. ■</p>

<p>정리 3의 따름정리로서 정리 4를 얻는다.</p>

<blockquote>
  <p><strong>정리 4.</strong> ZF가 무모순적이라면 ZFL 또한 무모순적이다.</p>
</blockquote>

<p><strong>증명.</strong> ZFL이 모순적이라면 $\mathsf{ZFL} \vdash \varnothing \neq \varnothing$이며, 정리 3에 의해 $\mathsf{ZF} \vdash (\varnothing \neq \varnothing)^L \iff \mathsf{ZF} \vdash \varnothing \neq \varnothing$이다.</p>

<p>따라서 <strong>V = L은 ZF와 일관적이다</strong>.</p>

  </div>
  <div style="margin-bottom: 6em"></div>
  
    <div class="post fade-in-section" data-lang="en" style="display: none">
      <h1 class="post-title">
        <a href="/2024/12/11/VL-axiom/en"> Consistency of the V = L Axiom </a>
      </h1>
    <span class="post-date">11 Dec 2024</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/mathematics/'">
        Mathematics
      </div>
      
      <div class="tag" onclick="location.href='/tags/set-theory/'">
        Set Theory
      </div>
      
    </div>
     <blockquote>
  <p>This post was machine translated and has not yet been proofread. It may contain minor errors or unnatural expressions. Proofreading will be done in the near future.</p>
</blockquote>

<h2 id="1-universe">1. Universe</h2>

<h3 id="11-von-neumann-universe">1.1. Von Neumann Universe</h3>

<p>We define $\lbrace  V_\alpha \rbrace$ <a href="https://dimenerno.github.io/2024/12/05/transfinite-recursion/">transfinitely recursively</a>.</p>

<ul>
  <li>$V_0 = \varnothing$</li>
  <li>$V_{\alpha + 1} = V_\alpha \cup \mathcal{P}(V_\alpha)$</li>
  <li>When $\lambda$ is a limit ordinal, $V_\lambda = \bigcup_{\alpha &lt; \lambda} V_\alpha$</li>
</ul>

<p>The first few $V_\alpha$ are as follows:</p>

<ul>
  <li>$V_1 = \lbrace  \varnothing \rbrace$</li>
  <li>$V_2 = \lbrace  \varnothing, \lbrace  \varnothing \rbrace \rbrace$</li>
  <li>$V_3 = \lbrace  \varnothing, \lbrace  \varnothing \rbrace, \lbrace  \lbrace  \varnothing \rbrace \rbrace, \lbrace  \varnothing, \lbrace  \lbrace  \varnothing\rbrace \rbrace  \rbrace$</li>
  <li>$V_\omega = \mathsf{HF}$</li>
</ul>

<p>The collection of all $V_\alpha$ for every ordinal $\alpha$ is called the <strong>Von Neumann universe</strong>.</p>

\[V = \bigcup_{\alpha \in \mathrm{Ord}} V_\alpha\]

<p>When $x \in y \in z$ implies $x \in z$, we call $z$ a <strong>transitive set</strong>. This is an important property of $V$.</p>

<blockquote>
  <p><strong>Theorem.</strong></p>

  <ol>
    <li>For $\alpha \in \mathrm{Ord}$, $V_\alpha$ is transitive.</li>
    <li>$V$ is transitive.</li>
  </ol>
</blockquote>

<p>The proof uses transfinite induction. Accordingly, we may define $V$ as follows without loss of generality:</p>

<ul>
  <li>$V_0 = \varnothing$</li>
  <li>$V_{\alpha + 1} = \mathcal{P}(V_\alpha)$</li>
  <li>When $\lambda$ is a limit ordinal, $V_\lambda = \bigcup_{\alpha &lt; \lambda}V_\alpha$</li>
</ul>

<p>Intuitively, $V$ appears to contain all sets. Indeed, we can prove the following:</p>

<blockquote>
  <p><strong>Theorem.</strong> If $x$ is a set, then $x \in V$.</p>
</blockquote>

<p><strong>Proof.</strong> For a set $x$, we define the <strong>transitive closure</strong> $\bar{x}$ of $x$ as the smallest transitive set containing $x$ as an element (this definition is justified because the intersection of transitive sets is transitive).</p>

<p>Assume $x \notin V$. By the axiom of separation, $y = \lbrace  u \in \bar{x} : u \notin V \rbrace$ is a set, and by the axiom of foundation, there exists an $\in$-minimal element $z$ of $y$. If there exists $w \in z$ such that $w \notin V$, then by transitivity $w \in y$, contradicting the $\in$-minimality of $z$. Therefore, all elements of $z$ are in $V$, and by the axiom of replacement, $\Omega = \lbrace  \alpha \in \mathrm{Ord} \mid \exists w \in z : w \in V_\alpha\rbrace$ is a set. By the Burali-Forti theorem, $\beta = \bigcup_{\alpha \in \Omega}\alpha$ is an ordinal, and <strong>$z \in V_{\beta + 1}$.</strong> (This part requires that $V_{\beta + 1} = \mathcal{P}(V_\beta)$) This yields a contradiction. ■</p>

<p>Consequently, $V$ is not a set. Therefore, whilst $V$ is a model of ZFC in the sense that it contains all sets, <a href="https://math.stackexchange.com/questions/56726/how-can-there-be-genuine-models-of-set-theory">many mathematicians require models to be sets</a>, so it is not a model in the strict sense. However, for convenience in this article, we shall refer to $V$ as a model of set theory. Moreover, we shall understand $x \in V$ as a formal expression for “$x$ is a set”.</p>

<h3 id="12-gödel-constructible-universe">1.2. Gödel Constructible Universe</h3>

<p>First, we define constructibility as follows:</p>

<blockquote>
  <p><strong>Definition.</strong> $u$ is <strong>constructible</strong> from a set $S$ if there exist some first-order logical formula $\phi(y, x_1, \dots, x_n)$ and $c_1, \dots, c_n \in S$ such that the following holds:</p>

\[y \in u \iff y \in S \land \phi(y, c_1, \dots, c_n)\]

  <p>where the domain of quantifiers in $\phi$ is $S$.</p>
</blockquote>

<p>For example, when $S = \lbrace 0, 1, 2\rbrace$, the following constructs $u = \lbrace  1, 2 \rbrace$:</p>

<ul>
  <li>$\phi(y, x_1, x_2) := (y = x_1) \lor (y = x_2)$</li>
  <li>$c_1 = 1, c_2 = 2$</li>
</ul>

<p>Also, when $S = \mathbb{N}$, the following constructs $u = \lbrace 0, 3, 6, 9, \dots \rbrace$:</p>

<ul>
  <li>$\phi(y, x_1) := x_1 \mid y$</li>
  <li>$c_1 = 3$</li>
</ul>

<p>Gödel’s constructibility differs from constructibility in the general sense, namely expressibility in language. For instance, since the set of real numbers expressible in language is countable, some real numbers cannot be expressed in language. Let such a real number be $r$. Now when $S = \mathbb{R}$, the following constructs $u = \lbrace  r \rbrace$:</p>

<ul>
  <li>$\phi(y, x_1) := x_1 = y$</li>
  <li>$c_1 = r$</li>
</ul>

<p>That is, Gödel’s constructibility is powerful in that it allows initialisation of free variables to arbitrary elements. However, it has limitations in that the number of free variables is finite. We now define $\lbrace  L_\alpha \rbrace$ transfinitely recursively:</p>

<ul>
  <li>$L_0 = \varnothing$</li>
  <li>$L_{\alpha + 1} = \lbrace  x : x \text{ is constructible from } L_\alpha  \rbrace$</li>
  <li>When $\lambda$ is a limit ordinal, $L_\lambda = \bigcup_{\alpha &lt; \lambda} L_\alpha$</li>
  <li>$L = \bigcup_{\alpha &lt; \lambda} L_\alpha$</li>
</ul>

<p>We can easily show that $L_\alpha = V_\alpha$ when $\alpha &lt; \omega$. When $\alpha = n$, we can construct $x \in V_\alpha$ with at most $n$ disjunctions $\lor$. Therefore:</p>

<ul>
  <li>$L_1 = \lbrace  \varnothing \rbrace$</li>
  <li>$L_2 = \lbrace  \varnothing, \lbrace  \varnothing \rbrace \rbrace$</li>
  <li>$L_3 = \lbrace  \varnothing, \lbrace  \varnothing \rbrace, \lbrace  \lbrace  \varnothing \rbrace \rbrace, \lbrace  \varnothing, \lbrace  \lbrace  \varnothing\rbrace \rbrace  \rbrace$</li>
  <li>$L_\omega = \mathsf{HF}$</li>
</ul>

<p>However, $L_{\omega + 1} \subsetneq V_{\omega + 1}$. Since $\mathcal{P}(\mathbb{N}) \subset V_{\omega + 1}$, $V_{\omega + 1}$ is uncountable, whereas since the set of first-order logical sentences and $L_\omega$ are both countable, $L_{\omega + 1}$ is also countable. In general, when $\alpha$ is countable, $L_\alpha$ is countable.</p>

<p>Nevertheless, $L$ shares many properties with $V$. For instance:</p>

<blockquote>
  <p><strong>Theorem.</strong> For $\alpha \in \mathrm{Ord}$, the following hold:</p>

  <ol>
    <li>$L_\alpha$ is transitive. (Therefore $L$ is transitive)</li>
    <li>$\alpha \in L_{\alpha + 1} \setminus L_{\alpha}$</li>
  </ol>
</blockquote>

<p>The proof uses transfinite induction.</p>

<p>Note that $L$ is not a set by the Burali-Forti theorem since it contains all ordinals. Instead, there exists a first-order logical formula $\mathsf{IsInL}_\alpha(x)$ corresponding to $x \in L_\alpha$. The proof is somewhat intricate and involves arithmetising propositions using Gödel numbers. (<a href="https://math.stackexchange.com/questions/198437/a-formula-that-defines-constructible-universe">See link</a>) Therefore, we shall understand $x \in L$ as a formal expression replacing $\exists \alpha \in \mathrm{Ord} :\mathsf{IsInL}_\alpha(x)$. (Of course, $\alpha \in \mathrm{Ord}$ should also be understood as a formal expression replacing a first-order logical formula)</p>

<h2 id="2-relativisation">2. Relativisation</h2>

<h3 id="21-relativisation-of-propositions">2.1. Relativisation of Propositions</h3>

<p>First-order logical propositions may contain quantifiers. Hence, the meaning of a proposition changes depending on how the domain of quantifiers is set.</p>

<p>For a proposition $\phi$ and a set (or class) $A$, we define the relativisation $\phi^A$ of $\phi$ as the proposition where all quantifiers in $\phi$ are restricted to $A$. To add a bit of narrative expression, $\phi^A$ can be said to be $\phi$ understood from “inside” $A$. For example, when $\phi : \forall x \; \exists y : y &lt; x$:</p>

<ul>
  <li>$\phi^\mathbb{N} : \forall x \in \mathbb{N} \; \exists y \in \mathbb{N} : y &lt; x$</li>
  <li>$\phi^\mathbb{Z} : \forall x \in \mathbb{Z} \; \exists y \in \mathbb{Z} : y &lt; x$</li>
</ul>

<p>If $T_\mathbb{Q}$ is a theory of rational numbers with sufficient expressive power to characterise natural numbers and integers, then:</p>

<ul>
  <li>$T_\mathbb{Q} \vdash \phi$</li>
  <li>$T_\mathbb{Q} \not\vdash \phi^\mathbb{N}$</li>
  <li>$T_\mathbb{Q} \vdash \phi^{\mathbb{Z}}$</li>
</ul>

<p>Therefore, $\phi$ successfully distinguishes between natural numbers and rational numbers, but fails to distinguish between integers and rational numbers. Generalising this observation, for a theory $T$ and a set $A$, the more formulas $\phi$ such that $T \vdash \phi \leftrightarrow \phi^A$, the better $A$ “conforms” to the description of $T$.</p>

<p>Generalising the above discussion slightly, we define:</p>

<blockquote>
  <p><strong>Definition.</strong> For a theory $T$ and a set $A$,</p>

\[T \vdash \forall x_1, \dots, x_n \in A (\phi(x_1, \dots, x_n) \leftrightarrow \phi^A(x_1, \dots, x_n))\]

  <p>when this holds, $\phi$ is said to be <strong>absolute</strong> with respect to $A$.</p>
</blockquote>

<p>For instance, with respect to $T_\mathbb{Q}$, $\phi(x) : \exists y (y &lt; x)$ is absolute with respect to integers but not absolute with respect to natural numbers.</p>

<h3 id="22-l-relativisation">2.2. $L$-Relativisation</h3>

<p>Our goal now is to show that $L$ conforms maximally with $\mathsf{ZF}$. That is:</p>

<blockquote>
  <p><strong>Theorem 1.</strong> If $\phi$ is an axiom of ZF, then $\mathsf{ZF} \vdash \phi^L$.</p>
</blockquote>

<p>Let us express the meaning of Theorem 1 in words:</p>

<blockquote>
  <p>“When viewed from inside $L$, $L$ is a model of ZF” can be proved in ZF.</p>
</blockquote>

<p>Of course, we only know $L \subset V$ and do not know whether $V = L$, so some set $x$ may not belong to $L$. However, even if there exists a set $x$ such that $x \in V \setminus L$, the absence of such $x$ does not break the <em>internal consistency</em> of $L$—this is the content of Theorem 1.</p>

<p>For example, suppose some set $x = \lbrace  y, z \rbrace$ is absent from $L$ for some sets $y, z$. At first glance, the absence of $x$ seems to suggest that $L$ does not satisfy the pairing axiom $\mathsf{Pair}$:</p>

\[\mathsf{Pair} := \forall y, z \; \exists x \; \forall w: w \in x \leftrightarrow (w = y \lor w = z)\]

<p>However, the pairing axiom as viewed from inside $L$ is:</p>

\[\mathsf{Pair}^L := \forall y, z \in L \; \exists x \in L \; \forall w \in L: w \in x \leftrightarrow (w = y \lor w = z)\]

<p>Note that the quantification $\forall y, z$ is also restricted to $L$. That is, the absence of $x = \lbrace  y, z \rbrace$ causes problems for $L$ only when $y, z \in L$. Conversely, if $x = \lbrace  y, z \rbrace \notin L$ implies $y, z \notin L$, then $L$ satisfies $\mathsf{Pair}^L$. This is the meaning of “$L$ lacks sets in a way that maintains internal consistency”.</p>

<p>The key reason Theorem 1 holds is that $L$ and $V$ <strong>share the property of transitivity</strong>.</p>

<blockquote>
  <p><strong>Lemma.</strong> The following predicates are absolute with respect to $L$ in ZF:</p>

  <ol>
    <li>$x \in y$</li>
    <li>$x \subset y$</li>
    <li>$x = \bigcup y$</li>
    <li>$x = \lbrace  y, z \rbrace$</li>
    <li>$\alpha \in \mathrm{Ord}$</li>
    <li>$x$ is transitive</li>
    <li><a href="https://math.stackexchange.com/questions/404699/delta-0-formulas">$\Delta_0$ formulas</a></li>
  </ol>
</blockquote>

<p>Moreover, we can prove:</p>

<blockquote>
  <p><strong>Theorem 2.</strong> $\mathsf{ZF} \vdash (V = L)^L$</p>
</blockquote>

<p>Here, $V = L$ means “every set belongs to $L$”. Therefore, at first glance, $(V = L)^L$ appears to be the trivial proposition “every set belonging to $L$ belongs to $L$”. However, when we actually write $V = L$ as a logical formula:</p>

\[\forall x \; \exists \alpha  : \alpha \in \mathrm{Ord} \land x \in L_\alpha\]

<p>so $(V = L)^L$ becomes:</p>

\[\forall x \in L \; \exists \alpha \in L : (\alpha \in \mathrm{Ord})^L \land (x \in L_\alpha)^L\]

<p>Note particularly that since $\alpha \in \mathrm{Ord}$ and $x \in L_\alpha$ are formal expressions of first-order logical formulas rather than the genuine $\in$-predicate, they must likewise be relativised to $L$. Accordingly, to prove $(V = L)^L$ in ZF, we must prove that $\alpha \in \mathsf{Ord}$ and $x \in L_\alpha$ are absolute. Both proofs are possible using transfinite induction.</p>

<p>From Theorems 1 and 2, we can prove:</p>

<blockquote>
  <p><strong>Theorem 3.</strong> $\mathsf{ZFL} \vdash \phi \implies \mathsf{ZF} \vdash \phi^L$</p>
</blockquote>

<p><strong>Proof.</strong> We prove by induction on the proof length of $\mathsf{ZFL} \vdash \phi$. When the proof length is 0, $\phi$ is an axiom of ZFL. When $\phi$ is an axiom of ZF, it follows from Theorem 1, and when $\phi$ is $V = L$, it follows from Theorem 2.</p>

<p>Now assume $\phi$ is proved by applying an inference rule to $\lbrace  \psi_1, \dots, \psi_n \rbrace$. The proof length of $\psi_k$ is smaller than that of $\phi$, so by the induction hypothesis $\mathsf{ZF} \vdash \psi_k^L$. We can easily show that logical axioms and inference rules are absolute with respect to $L$. Therefore, if $(\psi_1 \land \dots \land \psi_n) \rightarrow \phi$ is logically valid, then $(\psi_1^L \land \dots \land \psi_n^L) → \phi^L$ is also logically valid, and consequently $\mathsf{ZF} \vdash \phi^L$. ■</p>

<p>As a corollary of Theorem 3, we obtain Theorem 4:</p>

<blockquote>
  <p><strong>Theorem 4.</strong> If ZF is consistent, then ZFL is also consistent.</p>
</blockquote>

<p><strong>Proof.</strong> If ZFL is inconsistent, then $\mathsf{ZFL} \vdash \varnothing \neq \varnothing$, and by Theorem 3, $\mathsf{ZF} \vdash (\varnothing \neq \varnothing)^L \iff \mathsf{ZF} \vdash \varnothing \neq \varnothing$.</p>

<p>Therefore, <strong>V = L is consistent with ZF</strong>.</p>

  </div>
  <div style="margin-bottom: 6em"></div>
  
    <div class="post fade-in-section" data-lang="ko" style="display: none">
      <h1 class="post-title">
        <a href="/2024/12/05/transfinite-recursion"> 초한귀납과 초한재귀 </a>
      </h1>
    <span class="post-date">05 Dec 2024</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/수학/'">
        수학
      </div>
      
      <div class="tag" onclick="location.href='/tags/집합론/'">
        집합론
      </div>
      
    </div>
     <h3 id="1-초한귀납법">1. 초한귀납법</h3>

<blockquote>
  <p><strong>정리.</strong> $P$가 서수 위에서 정의된 속성이고 임의의 $\alpha \in \mathrm{Ord}$에 대해</p>

\[[ \forall \beta &lt; \alpha : P(\beta)] → P(\alpha)\]

  <p>가 성립할 때, $P$는 모든 서수에 대해 참이다.</p>
</blockquote>

<p><em>Remark.</em> $P$의 정의역인 $\mathrm{Ord}$는 집합이 아닌 진모임(proper class)이므로 “술어” 대신 “속성”이란 표현을 사용한다.</p>

<p><strong>증명.</strong> 서수가 정렬 순서라는 사실과 귀류법을 사용한다.</p>

<p>$\lnot P(\lambda)$인 $\lambda$가 존재한다고 하자. $\Omega = \lbrace  \alpha \in \lambda : \lnot P(\alpha) \rbrace$는 공집합이 아닌 정렬 집합이므로 최소 원소 $\alpha_0$가 존재한다. 이때 $\forall \beta &lt; \alpha_0 : P(\beta)$이므로 가정에 의해 $P(\alpha_0)$가 되어 모순이다. ■</p>

<p><strong>응용.</strong> 폰 노인만 계층에서 $V_\alpha$는 추이적이다. 따라서 $V_{\alpha + 1} = V_\alpha \cup \mathcal{P}(V_\alpha)$ 대신 $V_{\alpha + 1} = \mathcal{P}(V_\alpha)$로 정의할 수 있다.</p>

<h3 id="2-초한재귀적-정의">2. 초한재귀적 정의</h3>

<p><em>Motivation.</em> 자연수의 재귀적 정의를 생각해 보자. $n$개의 집합 $x_1, \dots , x_n$이 주어졌을 때 집합을 출력하는 함수 $g$가 존재한다면 다음과 같이 $f: \mathbb{N} → V$을 정의할 수 있을 것이다.</p>

\[f(n) = g(f(0), \dots, f(n - 1))\]

<p>문제는 $g$가 고정된 수의 매개변수만을 가질 수 있다는 것이다. 따라서 다음과 같이 $g$의 매개변수를 순서쌍으로 묶는다.</p>

\[f(n) = g(\langle f(0), \dots, f(n - 1) \rangle)\]

<p>이 순서쌍은 $\lbrace  (0, f(0)), \dots, (n - 1, f(n - 1)) \rbrace = f \upharpoonright n$과 같이 표현할 수 있다. 즉,</p>

\[f(n) = g(f \upharpoonright n).\]

<p>이를 서수에 대해서 일반화하면 다음과 같다.</p>

<blockquote>
  <p><strong>정리.</strong> $G: V → V$가 모임함수(class function)이라고 하자. 다음을 만족하는 모임함수 $F: \mathrm{Ord} → V$가 존재한다.</p>

\[F(\alpha) = G(F \upharpoonright \alpha)\]
</blockquote>

<p><strong>증명.</strong> 초한귀납법을 겁나게 쓰면 된다. (불친절해서 ㅈㅅ)</p>

  </div>
  <div style="margin-bottom: 6em"></div>
  
    <div class="post fade-in-section" data-lang="en" style="display: none">
      <h1 class="post-title">
        <a href="/2024/12/05/transfinite-recursion/en"> Transfinite Induction and Transfinite Recursion </a>
      </h1>
    <span class="post-date">05 Dec 2024</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/mathematics/'">
        Mathematics
      </div>
      
      <div class="tag" onclick="location.href='/tags/set-theory/'">
        Set Theory
      </div>
      
    </div>
     <blockquote>
  <p>This post was machine translated and has not yet been proofread. It may contain minor errors or unnatural expressions. Proofreading will be done in the near future.</p>
</blockquote>

<h3 id="1-transfinite-induction">1. Transfinite Induction</h3>

<blockquote>
  <p><strong>Theorem.</strong> Let $P$ be a property defined on ordinals, and suppose that for any $\alpha \in \mathrm{Ord}$,</p>

\[[ \forall \beta &lt; \alpha : P(\beta)] → P(\alpha)\]

  <p>holds. Then $P$ is true for all ordinals.</p>
</blockquote>

<p><em>Remark.</em> Since $\mathrm{Ord}$, the domain of $P$, is a proper class rather than a set, we use the term “property” instead of “predicate”.</p>

<p><strong>Proof.</strong> We employ the fact that ordinals form a well-ordering and proceed by contradiction.</p>

<p>Suppose there exists $\lambda$ such that $\lnot P(\lambda)$. Then $\Omega = \lbrace  \alpha \in \lambda : \lnot P(\alpha) \rbrace$ is a non-empty well-ordered set, so it has a minimal element $\alpha_0$. Since $\forall \beta &lt; \alpha_0 : P(\beta)$, by hypothesis we have $P(\alpha_0)$, which is a contradiction. ■</p>

<p><strong>Application.</strong> In the von Neumann hierarchy, $V_\alpha$ is transitive. Therefore, instead of $V_{\alpha + 1} = V_\alpha \cup \mathcal{P}(V_\alpha)$, we may define $V_{\alpha + 1} = \mathcal{P}(V_\alpha)$.</p>

<h3 id="2-transfinite-recursive-definition">2. Transfinite Recursive Definition</h3>

<p><em>Motivation.</em> Consider recursive definitions on natural numbers. Given $n$ sets $x_1, \dots , x_n$ and a function $g$ that outputs a set, we would like to define $f: \mathbb{N} → V$ as follows:</p>

\[f(n) = g(f(0), \dots, f(n - 1))\]

<p>The problem is that $g$ can only take a fixed number of parameters. Therefore, we group the parameters of $g$ into an ordered pair:</p>

\[f(n) = g(\langle f(0), \dots, f(n - 1) \rangle)\]

<p>This ordered pair can be represented as $\lbrace  (0, f(0)), \dots, (n - 1, f(n - 1)) \rbrace = f \upharpoonright n$. That is,</p>

\[f(n) = g(f \upharpoonright n).\]

<p>Generalising this to ordinals, we obtain the following:</p>

<blockquote>
  <p><strong>Theorem.</strong> Let $G: V → V$ be a class function. There exists a class function $F: \mathrm{Ord} → V$ satisfying</p>

\[F(\alpha) = G(F \upharpoonright \alpha)\]
</blockquote>

<p><strong>Proof.</strong> One applies transfinite induction extensively. (My apologies for the brevity.)</p>

  </div>
  <div style="margin-bottom: 6em"></div>
  
    <div class="post fade-in-section" data-lang="ko" style="display: none">
      <h1 class="post-title">
        <a href="/2024/12/01/net"> 콤팩트성과 그물 </a>
      </h1>
    <span class="post-date">01 Dec 2024</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/수학/'">
        수학
      </div>
      
      <div class="tag" onclick="location.href='/tags/위상수학/'">
        위상수학
      </div>
      
    </div>
     <h3 id="콤팩트성">콤팩트성</h3>
<blockquote>
  <p><strong>정의.</strong> $X$가 위상공간이라고 하자.</p>

  <ol>
    <li>임의의 열린 덮개가 유한한 부분덮개를 가질 때 $X$를 <strong>콤팩트</strong>하다고 한다.</li>
    <li>임의의 점렬 $\lbrace x_n \in X \rbrace$가 수렴하는 부분점렬을 가질 때 $X$를 <strong>점렬 콤팩트</strong>하다고 한다.</li>
    <li>임의의 무한집합 $S \subset X$가 극점을 가질 때 $X$를 <strong>극점 콤팩트</strong>하다고 한다.</li>
  </ol>
</blockquote>

<blockquote>
  <p><strong>정리.</strong></p>

  <ol>
    <li>콤팩트 $\rightarrow$ 극점 콤팩트</li>
    <li>점렬 콤팩트 $\rightarrow$ 극점 콤팩트</li>
    <li>극점 콤팩트 $\not\rightarrow$ 콤팩트</li>
    <li>극점 콤팩트 $\not\rightarrow$ 점렬 콤팩트</li>
  </ol>
</blockquote>

<p><strong>증명.</strong></p>

<ol>
  <li>$S \subset X$가 극점이 없는 무한집합이라고 하자. $\overline{S} = S \cup S’ = S$이므로 $S$는 닫힌 집합이며, $X \setminus S$는 열린 집합이다. 임의의 $s \in S$에 대해, $s$가 극점이 아니므로 $U_s \cap S = \lbrace  s \rbrace$인 $s$의 근방 $U_s$가 존재한다. 따라서 다음 $X$의 열린 덮개는 유한한 부분덮개를 가지지 않는다.</li>
</ol>

\[\mathcal{C} = \lbrace  X \setminus S \rbrace \cup \bigcup_{s \in S} \lbrace  U_s \rbrace\]

<ol>
  <li>$S \subset X$가 무한집합이라고 하자. $S$의 원소들을 임의로 추출하여 점렬 $\lbrace  s_n \rbrace \;(n \neq m \implies s_n \neq s_m)$을 만든다. $X$가 점렬 콤팩트하므로 $\lbrace  s_n \rbrace → s$이며, $s$는 $S$의 극점이다.</li>
  <li>순서 토폴로지가 주어진 $\omega_1$은 극점 콤팩트하지만 콤팩트하지 않다.</li>
  <li>$X = \mathbb{N} \times \lbrace  0, 1 \rbrace$, $\mathbb{N}$에는 이산 토폴로지가 주어지고 $\lbrace  0, 1\rbrace$에는 자명한 토폴로지가 주어짐.</li>
</ol>

<p><strong>Remark.</strong> 4의 올바르지 못한 “증명”</p>

<blockquote>
  <p>$X$가 극점 콤팩트하다고 하자. 점렬 $(x_n)$이 주어졌을 때, $S = \lbrace  x_n : n \in \mathbb{N}\rbrace$이 유한집합이라면 $(x_n)$은 수렴하는 부분점렬을 자명하게 가진다. $S$가 무한집합이라면 $X$의 극점 콤팩트성에 의해 $x \in S’$가 존재한다. <strong>이제 다음 조건을 만족하는 $x$의 근방들의 가산 모임 $\mathcal{U} = \lbrace  U_n \rbrace$을 정의한다.</strong></p>

  <ol>
    <li>$n &lt; m \implies U_n \supset U_m$</li>
    <li>$V$가 $x$의 근방일 때, $\exists U \in \mathcal{U} : U \subset V$</li>
  </ol>

  <p>이로부터 다음 두 조건을 만족하는 함수 $k: \mathbb{N} → \mathbb{N}$을 정의할 수 있다.</p>

  <ol>
    <li>$x_{k(n)} \in U_n$</li>
    <li>$n &lt; m \implies k(n) &lt; k(m)$</li>
  </ol>

  <p>2가 가능한 이유는 $k(i)$가 $i \leq n$까지 정의되었을 때 $T = S \setminus \lbrace  x_i : i \leq k(n) \rbrace$가 여전히 $x$를 극점으로 가지기 때문이다. 즉, $(x_n)$은 수렴하는 부분점렬 $(x_{k(n)})$을 가진다.</p>
</blockquote>

<p>위 증명이 올바르지 않은 이유는 볼드체 부분이 일반적으로 가능하지 않기 때문이다. 대신 다음이 성립한다.</p>

<blockquote>
  <p><strong>정리.</strong> 1차 가산 T₁ 공간에서 극점 콤팩트성과 점렬 콤팩트성은 동치이다.</p>
</blockquote>

<h3 id="그물과-점렬">그물과 점렬</h3>

<blockquote>
  <p><strong>정의.</strong> $(J, \leq)$가 전순서라고 하자. 임의의 $x, y \in J$에 대해 $x, y \leq z$인 $z \in J$가 존재한다면 $(J, \leq)$를 <strong>방향 집합(directed set)</strong>이라고 한다.</p>
</blockquote>

<blockquote>
  <p><strong>정의.</strong> $K$가 $(J, \leq)$의 부분집합이라고 하자. 임의의 $x \in J$에 대해 $x \leq y$인 $y \in K$가 존재한다면 $K$를 <strong>공종(cofinal)</strong>이라고 한다.</p>
</blockquote>

<p><strong>Remark.</strong> $(J, \leq)$가 방향 집합이고 $K \subset J$가 공종이라면 $(K, \leq)$ 또한 방향 집합이다.</p>

<blockquote>
  <p><strong>정의.</strong> $(J, \leq)$가 방향 집합이라고 하자. 위상공간 $X$에 대해 $J$에서 $X$로 가는 함수 $f: J → X$를 <strong>그물(net)</strong>이라고 한다. 특히, $\alpha \in J$에 대해 $f(\alpha)$를 $x_\alpha$와 같이 표기한다.</p>
</blockquote>

<p><img src="https://velog.velcdn.com/images/dimenerno/post/9012f74b-245b-413c-8df4-f6ae30ebf7b3/image.png" alt="" /></p>

<blockquote>
  <p><strong>정의.</strong> 그물 $(x_\alpha)$가 $x$로 수렴한다는 것은, 임의의 $x$의 근방 $U$에 대해 어떤 $\alpha \in J$가 존재하여</p>

  <p>\(\alpha \leq \beta \implies x_\beta \in U\)
인 것이다.</p>
</blockquote>

<p>일반 위상 공간에서의 그물의 수렴은 1차 가산 공간에서 점렬의 수렴과 대응된다. 즉,</p>

<blockquote>
  <p><strong>정리.</strong> $X$가 1차 가산 공간이라고 하자.</p>

  <ol>
    <li>$A \subset X$에 대해, $x \in \bar{A}$일 필요충분조건은 $x$로 수렴하는 점렬 $(x_n)$이 존재하는 것이다.</li>
    <li>$f: X → Y$에 대해, $f$가 연속일 필요충분조건은 임의의 점렬 $(x_n)$에 대해 $x_n → x$라면  $f(x_n) → f(x)$인 것이다.</li>
  </ol>
</blockquote>

<blockquote>
  <p><strong>정리.</strong> $X$가 위상 공간이라고 하자.</p>

  <ol>
    <li>$A \subset X$에 대해, $x \in \bar{A}$일 필요충분조건은 $x$로 수렴하는 그물 $(x_\alpha)$가 존재하는 것이다.</li>
    <li>$f: X → Y$에 대해, $f$가 연속일 필요충분조건은 임의의 그물 $(x_\alpha)$에 대해 $x_\alpha → x$라면  $f(x_\alpha) → f(x)$인 것이다.</li>
  </ol>
</blockquote>

<p><strong>증명.</strong></p>

<ol>
  <li>$\mathcal{U}_x$를 $x$의 근방들의 집합이라고 하자. 역포함관계로 $\mathcal{U}_x$에 순서 $\leq$를 준다. $x \in \bar{A}$라면 임의의 $U_\alpha \in \mathcal{U}_x$에 대해 $x_\alpha \in U_\alpha \cap A, x_\alpha \neq x$인 $x_\alpha$가 존재한다. $x_\alpha → x$임을 확인하라.</li>
</ol>

<blockquote>
  <p><strong>정의.</strong> $(x_\alpha)_{\alpha \in J}$가 그물이라고 하자. $(I, \preceq)$가 방향 집합이고, $g: (I, \preceq) → (J, \leq)$가 순서 보존이며, $\operatorname{im}g$가 공종일 때, $(x_{g(\beta)})_{\beta \in I}$를 $(x_\alpha)$의 부분그물이라고 한다.</p>
</blockquote>

<blockquote>
  <p><strong>정리.</strong> $X$가 콤팩트할 필요충분조건은 임의의 그물이 수렴하는 부분그물을 가지는 것이다.</p>
</blockquote>

<p><strong>Remark.</strong> ”수렴하는 점렬이 존재한다“는 ”수렴하는 그물이 존재한다“보다 강한 조건이지만, ”임의의 점렬이 수렴하는 부분점렬을 가진다”는 “임의의 그물이 수렴하는 부분그물을 가진다”보다 강하지도, 약하지도 않은 조건임에 유의하라. 주어는 후자가 더 강하고, 술어는 전자가 더 강하다. 따라서 <strong>콤팩트성과 점렬 콤팩트성은 일반적으로 시사 관계가 없다.</strong> 구체적으로,</p>

<blockquote>
  <p><strong>정리.</strong></p>

  <ol>
    <li>콤팩트 $\not\rightarrow$ 점렬 콤팩트</li>
    <li>점렬 콤팩트 $\not\rightarrow$ 콤팩트</li>
  </ol>
</blockquote>

<p><strong>증명.</strong></p>

<ol>
  <li>$[0, 1]^{[0, 1]}$은 티호노프 정리에 의해 콤팩트하지만 점렬 콤팩트하지 않다.</li>
  <li>Long line과 $\omega_1$은 점렬 콤팩트하지만 콤팩트하지 않다.</li>
</ol>

  </div>
  <div style="margin-bottom: 6em"></div>
  
    <div class="post fade-in-section" data-lang="en" style="display: none">
      <h1 class="post-title">
        <a href="/2024/12/01/net/en"> Compactness and Nets </a>
      </h1>
    <span class="post-date">01 Dec 2024</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/mathematics/'">
        Mathematics
      </div>
      
      <div class="tag" onclick="location.href='/tags/topology/'">
        Topology
      </div>
      
    </div>
     <blockquote>
  <p>This post was machine translated and has not yet been proofread. It may contain minor errors or unnatural expressions. Proofreading will be done in the near future.</p>
</blockquote>

<h3 id="compactness">Compactness</h3>
<blockquote>
  <p><strong>Definition.</strong> Let $X$ be a topological space.</p>

  <ol>
    <li>$X$ is said to be <strong>compact</strong> if every open cover has a finite subcover.</li>
    <li>$X$ is said to be <strong>sequentially compact</strong> if every sequence $\lbrace x_n \in X \rbrace$ has a convergent subsequence.</li>
    <li>$X$ is said to be <strong>limit point compact</strong> if every infinite set $S \subset X$ has a limit point.</li>
  </ol>
</blockquote>

<blockquote>
  <p><strong>Theorem.</strong></p>

  <ol>
    <li>Compact $\rightarrow$ Limit point compact</li>
    <li>Sequentially compact $\rightarrow$ Limit point compact</li>
    <li>Limit point compact $\not\rightarrow$ Compact</li>
    <li>Limit point compact $\not\rightarrow$ Sequentially compact</li>
  </ol>
</blockquote>

<p><strong>Proof.</strong></p>

<ol>
  <li>Let $S \subset X$ be an infinite set with no limit points. Since $\overline{S} = S \cup S’ = S$, $S$ is a closed set and $X \setminus S$ is an open set. For any $s \in S$, since $s$ is not a limit point, there exists a neighbourhood $U_s$ of $s$ such that $U_s \cap S = \lbrace  s \rbrace$. Therefore, the following open cover of $X$ has no finite subcover:</li>
</ol>

\[\mathcal{C} = \lbrace  X \setminus S \rbrace \cup \bigcup_{s \in S} \lbrace  U_s \rbrace\]

<ol>
  <li>Let $S \subset X$ be an infinite set. Arbitrarily extract elements of $S$ to form a sequence $\lbrace  s_n \rbrace \;(n \neq m \implies s_n \neq s_m)$. Since $X$ is sequentially compact, $\lbrace  s_n \rbrace → s$, and $s$ is a limit point of $S$.</li>
  <li>$\omega_1$ with the order topology is limit point compact but not compact.</li>
  <li>$X = \mathbb{N} \times \lbrace  0, 1 \rbrace$, where $\mathbb{N}$ is given the discrete topology and $\lbrace  0, 1\rbrace$ is given the trivial topology.</li>
</ol>

<p><strong>Remark.</strong> An incorrect “proof” of 4</p>

<blockquote>
  <p>Suppose $X$ is limit point compact. Given a sequence $(x_n)$, if $S = \lbrace  x_n : n \in \mathbb{N}\rbrace$ is a finite set, then $(x_n)$ trivially has a convergent subsequence. If $S$ is an infinite set, then by the limit point compactness of $X$, there exists $x \in S’$. <strong>Now we define a countable collection of neighbourhoods of $x$, $\mathcal{U} = \lbrace  U_n \rbrace$, satisfying the following conditions:</strong></p>

  <ol>
    <li>$n &lt; m \implies U_n \supset U_m$</li>
    <li>For any neighbourhood $V$ of $x$, $\exists U \in \mathcal{U} : U \subset V$</li>
  </ol>

  <p>From this, we can define a function $k: \mathbb{N} → \mathbb{N}$ satisfying the following two conditions:</p>

  <ol>
    <li>$x_{k(n)} \in U_n$</li>
    <li>$n &lt; m \implies k(n) &lt; k(m)$</li>
  </ol>

  <p>Condition 2 is possible because when $k(i)$ is defined for $i \leq n$, $T = S \setminus \lbrace  x_i : i \leq k(n) \rbrace$ still has $x$ as a limit point. Thus, $(x_n)$ has a convergent subsequence $(x_{k(n)})$.</p>
</blockquote>

<p>The above proof is incorrect because the bold portion is not generally possible. Instead, the following holds:</p>

<blockquote>
  <p><strong>Theorem.</strong> In first countable T₁ spaces, limit point compactness and sequential compactness are equivalent.</p>
</blockquote>

<h3 id="nets-and-sequences">Nets and Sequences</h3>

<blockquote>
  <p><strong>Definition.</strong> Let $(J, \leq)$ be a preorder. If for any $x, y \in J$, there exists $z \in J$ such that $x, y \leq z$, then $(J, \leq)$ is called a <strong>directed set</strong>.</p>
</blockquote>

<blockquote>
  <p><strong>Definition.</strong> Let $K$ be a subset of $(J, \leq)$. If for any $x \in J$, there exists $y \in K$ such that $x \leq y$, then $K$ is said to be <strong>cofinal</strong>.</p>
</blockquote>

<p><strong>Remark.</strong> If $(J, \leq)$ is a directed set and $K \subset J$ is cofinal, then $(K, \leq)$ is also a directed set.</p>

<blockquote>
  <p><strong>Definition.</strong> Let $(J, \leq)$ be a directed set. For a topological space $X$, a function $f: J → X$ is called a <strong>net</strong>. In particular, for $\alpha \in J$, we denote $f(\alpha)$ as $x_\alpha$.</p>
</blockquote>

<p><img src="https://velog.velcdn.com/images/dimenerno/post/9012f74b-245b-413c-8df4-f6ae30ebf7b3/image.png" alt="" /></p>

<blockquote>
  <p><strong>Definition.</strong> A net $(x_\alpha)$ converges to $x$ if, for any neighbourhood $U$ of $x$, there exists some $\alpha \in J$ such that</p>

\[\alpha \leq \beta \implies x_\beta \in U\]
</blockquote>

<p>The convergence of nets in general topological spaces corresponds to the convergence of sequences in first countable spaces. That is,</p>

<blockquote>
  <p><strong>Theorem.</strong> Let $X$ be a first countable space.</p>

  <ol>
    <li>For $A \subset X$, $x \in \bar{A}$ if and only if there exists a sequence $(x_n)$ converging to $x$.</li>
    <li>For $f: X → Y$, $f$ is continuous if and only if for any sequence $(x_n)$, if $x_n → x$ then $f(x_n) → f(x)$.</li>
  </ol>
</blockquote>

<blockquote>
  <p><strong>Theorem.</strong> Let $X$ be a topological space.</p>

  <ol>
    <li>For $A \subset X$, $x \in \bar{A}$ if and only if there exists a net $(x_\alpha)$ converging to $x$.</li>
    <li>For $f: X → Y$, $f$ is continuous if and only if for any net $(x_\alpha)$, if $x_\alpha → x$ then $f(x_\alpha) → f(x)$.</li>
  </ol>
</blockquote>

<p><strong>Proof.</strong></p>

<ol>
  <li>Let $\mathcal{U}_x$ be the set of neighbourhoods of $x$. Give $\mathcal{U}_x$ the order $\leq$ by reverse inclusion. If $x \in \bar{A}$, then for any $U_\alpha \in \mathcal{U}_x$, there exists $x_\alpha \in U_\alpha \cap A, x_\alpha \neq x$. Verify that $x_\alpha → x$.</li>
</ol>

<blockquote>
  <p><strong>Definition.</strong> Let $(x_\alpha)_{\alpha \in J}$ be a net. If $(I, \preceq)$ is a directed set, $g: (I, \preceq) → (J, \leq)$ is order-preserving, and $\operatorname{im}g$ is cofinal, then $(x_{g(\beta)})_{\beta \in I}$ is called a subnet of $(x_\alpha)$.</p>
</blockquote>

<blockquote>
  <p><strong>Theorem.</strong> $X$ is compact if and only if every net has a convergent subnet.</p>
</blockquote>

<p><strong>Remark.</strong> Note that “there exists a convergent sequence” is a stronger condition than “there exists a convergent net”, but “every sequence has a convergent subsequence” is neither stronger nor weaker than “every net has a convergent subnet”. The subject is stronger in the latter case, whilst the predicate is stronger in the former case. Therefore, <strong>compactness and sequential compactness have no implication relation in general.</strong> Specifically,</p>

<blockquote>
  <p><strong>Theorem.</strong></p>

  <ol>
    <li>Compact $\not\rightarrow$ Sequentially compact</li>
    <li>Sequentially compact $\not\rightarrow$ Compact</li>
  </ol>
</blockquote>

<p><strong>Proof.</strong></p>

<ol>
  <li>$[0, 1]^{[0, 1]}$ is compact by Tychonoff’s theorem but not sequentially compact.</li>
  <li>The long line and $\omega_1$ are sequentially compact but not compact.</li>
</ol>

  </div>
  <div style="margin-bottom: 6em"></div>
  
</div>

<div class="pagination">
  
  <a
    class="pagination-item older lang-ko"
    href="/page11"
    >이전 글</a
  >
  <a
  class="pagination-item older lang-en"
  href="/page11"
  >Previous</a
>
    
  <a
    class="pagination-item newer lang-ko"
    href="/page9"
    >다음 글</a
  >
  <a
  class="pagination-item newer lang-en"
  href="/page9"
  >Next</a
>
   
</div>

<script>
  const faders = document.querySelectorAll(".fade-in-section");

  const appearOptions = {
    // threshold: 0.05,
    // rootMargin: "0px 0px 50px 0px",
  };

  const appearOnScroll = new IntersectionObserver((entries, observer) => {
    entries.forEach((entry) => {
      if (entry.isIntersecting) {
        entry.target.classList.add("is-visible");
        observer.unobserve(entry.target);
      }
    });
  }, appearOptions);

  faders.forEach((fader) => {
    appearOnScroll.observe(fader);
  });

  // 배너 이미지 로드 후 애니메이션 트리거 스크립트
  document.addEventListener("DOMContentLoaded", () => {

    const lang = localStorage.getItem("lang") || "ko";
  document.querySelectorAll('.post[data-lang]').forEach(post => {
    if (post.dataset.lang === lang) {
      post.style.display = '';
    }
  });

    const bannerImages = document.querySelectorAll(
      '.fade-rise-1[src="/public/banner.png"], .fade-rise-2[src="/public/banner-2.png"]'
    ); // 애니메이션 시작을 기다릴 이미지들
    const elementsToAnimate = document.querySelectorAll(
      ".fade-rise-1, .fade-rise-2, .fade-rise-3"
    ); // 애니메이션 될 요소들
    let loadedImagesCount = 0;
    const totalImagesToWait = bannerImages.length;

    // 기다릴 이미지가 없으면 즉시 애니메이션 시작
    if (totalImagesToWait === 0) {
      elementsToAnimate.forEach((el) => el.classList.add("is-loaded"));
      return;
    }

    const checkAllImagesLoaded = () => {
      if (loadedImagesCount === totalImagesToWait) {
        // 모든 이미지가 로드되면 애니메이션 클래스 추가
        elementsToAnimate.forEach((el) => el.classList.add("is-loaded"));
      }
    };

    bannerImages.forEach((img) => {
      // 이미지가 캐시되어 이미 로드 완료된 경우
      if (img.complete) {
        loadedImagesCount++;
      } else {
        // 이미지 로드 완료 이벤트 리스너 추가
        img.addEventListener("load", () => {
          loadedImagesCount++;
          checkAllImagesLoaded(); // 이미지 로드될 때마다 체크
        });
        // 에러 발생 시 처리 (선택 사항)
        img.addEventListener("error", () => {
          console.error("Failed to load image:", img.src);
          // 에러 발생 시에도 애니메이션을 시작하려면 여기서 loadedImagesCount를 증가시키거나 다른 로직 추가
          // 현재 로직에서는 에러 시 카운트가 증가하지 않아 모든 이미지 로드되지 않으면 애니메이션 안 시작
          loadedImagesCount++; // 에러 발생 시에도 카운트 증가 (모든 이미지를 처리했음을 알림)
          checkAllImagesLoaded();
        });
      }
    });

    // 모든 이미지에 대해 complete 상태를 확인하거나 리스너를 설정한 후,
    // 이미 모든 이미지가 로드 완료 상태였을 경우를 대비해 마지막으로 체크
    checkAllImagesLoaded();


    // Listen for language toggle changes and update post visibility dynamically
    const langToggle = document.getElementById("lang-toggle");
    if (langToggle) {
      langToggle.addEventListener("change", () => {
        const newLang = langToggle.checked ? "en" : "ko";
        localStorage.setItem("lang", newLang);
        document.querySelectorAll('.post[data-lang]').forEach(post => {
          post.style.display = post.dataset.lang === newLang ? '' : 'none';
        });
      });
    }
  });
</script>
</div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script src="/public/js/script.js"></script>
    <script src="/public/js/lang.js"></script>
  </body>
</html>
