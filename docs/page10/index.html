<!DOCTYPE html>
<html lang="en-us">
  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile" />
  <link href="https://fonts.googleapis.com/css2?family=Libre+Baskerville&display=swap" rel="stylesheet">
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />

  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=1"
  />

  <title>
     디멘의 블로그 &middot; 이데아를 여행하는 히치하이커
    
  </title>

  <style>
    .answer {
      display: none;
      margin-top: 10px;
      color: #333;
    }
  </style>

<style>
  .lang-toggle-wrapper {
    display: flex;
    align-items: center;
    gap: 0.4em;
    margin-right: 0.5em;
  }

  .lang-label {
    font-size: 0.9em;
    line-height: 1;
  }

  .switch {
    position: relative;
    display: inline-block;
    width: 44px;
    height: 24px;
  }

  .switch input {
    opacity: 0;
    width: 0;
    height: 0;
  }

  .slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #e7e8eb;
    transition: 0.4s;
    border-radius: 24px;
  }

  .slider::before {
    position: absolute;
    content: "";
    height: 18px;
    width: 18px;
    left: 3px;
    bottom: 3px;
    background-color: white;
    transition: 0.4s;
    border-radius: 50%;
  }

  .switch input:checked + .slider {
    background-color: #2e2e2e;
  }

  .switch input:checked + .slider::before {
    transform: translateX(20px);
  }

  .lang-ko, .lang-en {
  transition: opacity 0.3s ease;
}
</style>

  <script>
    function toggleAnswer(id) {
      const answer = document.getElementById("answer" + id);
      if (answer.style.display === "none" || answer.style.display === "") {
        answer.style.display = "block";
      } else {
        answer.style.display = "none";
      }
    }
  </script>

  <script>
    MathJax = {
      tex: {
        inlineMath: [
          ["$", "$"],
          ["\\(", "\\)"],
        ],
      },
      svg: {
        fontCache: "global",
      },
    };
  </script>
  <script
    type="text/javascript"
    id="MathJax-script"
    async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
  ></script>

  
  <link rel="canonical" href="/page10/" />
  

  <link rel="stylesheet" href="/public/css/poole.css" />
  <link rel="stylesheet" href="/public/css/syntax.css" />
  <link rel="stylesheet" href="/public/css/lanyon.css" />
  <link
    rel="stylesheet"
    href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400"
  />


  <link
    rel="apple-touch-icon-precomposed"
    sizes="144x144"
    href="/public/apple-touch-icon.png"
  />
  <link rel="shortcut icon" href="/public/favicon.ico" />
  <link
    rel="alternate"
    type="application/rss+xml"
    title="RSS"
    href=""
  />

  <script
    async
    src="https://www.googletagmanager.com/gtag/js?id=G-PVGYLWF7GR"
  ></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
      dataLayer.push(arguments);
    }
    gtag("js", new Date());

    gtag("config", "G-PVGYLWF7GR");
  </script>
</head>


  <style>
    /* 검색 입력창 */
    #search-input {
      padding: 6px 12px;
      font-size: 15px;
      border: 1px solid #eee;
      border-radius: 20px;
      outline: none;
      transition: all 0.2s ease-in-out;
      width: 90%;
      max-width: 240px;
      background-color: #fefefe;
    }

    #search-input::placeholder {
      color: var(--slate);
    }

    /* 입력창 포커스 시 */
    #search-input:focus {
      border-color: #9ea0a3;
      background-color: white;
    }

    @media (max-width: 600px) {
      .lang-label {
        display: none;
      }
    }
  </style>

  <body>
    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox" />

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p class="lang-ko">이데아를 여행하는 히치하이커</p>
    <p class="lang-en" style="display: none;">Alice in Logicland</p>
  </div>

  <nav class="sidebar-nav">
    <a
    class="sidebar-nav-item lang-ko"
    href="/"
    >메인</a>
    <a
    class="sidebar-nav-item lang-en"
    href="/"
    >Main</a
  >
                                                                                                                                                                                                         
    <a
      class="sidebar-nav-item lang-ko"
      href="/about/"
      >저에 대하여</a
    >
    <a
    class="sidebar-nav-item lang-en"
    href="/about/"
    >About Me</a
  >
        
    <a
      class="sidebar-nav-item lang-ko"
      href="/archive-date/"
      >날짜별로 보기</a
    >
    <a
    class="sidebar-nav-item lang-en"
    href="/archive-date/"
    >List by dates</a
  >
        
    <a
      class="sidebar-nav-item lang-ko"
      href="/archive-tag/"
      >주제별로 보기</a
    >
    <a
    class="sidebar-nav-item lang-en"
    href="/archive-tag/"
    >List by topics</a
  >
        
    <a
      class="sidebar-nav-item lang-ko"
      href="/random/"
      >랜덤 포스트</a
    >
    <a
    class="sidebar-nav-item lang-en"
    href="/random/"
    >Go to a random post</a
  >
        
    <a
      class="sidebar-nav-item lang-ko"
      href="/book/"
      >새벽의 자연학 수업</a
    >
    <a
    class="sidebar-nav-item lang-en"
    href="/book/"
    >Twilight Wonders (Korean)</a
  >
        
    <a
      class="sidebar-nav-item lang-ko"
      href="/notes/"
      >복습노트 아카이브</a
    >
    <a
    class="sidebar-nav-item lang-en"
    href="/notes/"
    >Maths Review Notes (Korean)</a
  >
        
    <a
      class="sidebar-nav-item lang-ko"
      href="/guestbook/"
      >방명록</a
    >
    <a
    class="sidebar-nav-item lang-en"
    href="/guestbook/"
    >Guestbook</a
  >
                      
  </nav>

  <div class="sidebar-item">
    <p>&copy; 2025. All rights reserved.</p>
    <p style="color: #202020">
      &copy; 2025. 디멘 reserved by 곰댕.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead" style="width: 100%">
        <div
          class="container"
          style="
            display: flex;
            justify-content: space-evenly;
            align-items: center;
            padding: 0px;
            margin-left: 4em;
            margin-right: 0;
            max-width: none;
            overflow-y: hidden;
          "
        >
          <h3
            class="masthead-title"
            style="
              display: flex;
              flex-direction: row;
              gap: 0.3em;
              align-items: end;
              line-height: 1;
            "
          >
            <a
              href="/"
              style="white-space: nowrap"
              class="lang-ko"
              title="Home"
              >디멘의 블로그</a>
            <a
              href="/"
              style="white-space: nowrap"
              class="lang-en"
              title="Home"
            >Dimen's Blog</a>
            <small><div class="lang-ko">이데아를 여행하는 히치하이커</div>
              <div class="lang-en">Alice in Logicland</div></small>

          </h3>
          <form
            id="search-form"
            action="/search.html"
            method="get"
            style="display: flex; justify-content: end; padding-right: 1em"
          >
            <input
              type="text"
              name="q"
              id="search-input"
              placeholder="검색"
            />
          </form>

          <div class="lang-toggle-wrapper">
            <span class="lang-label">한</span>
            <label class="switch">
              <input type="checkbox" id="lang-toggle" />
              <span class="slider round"></span>
            </label>
            <span class="lang-label">EN</span>
          </div>
        </div>
      </div>

      <div class="container content"><head>
  <style>
    .fade-rise-1 {
      opacity: 0;
      transform: translateY(20px);
      /* animation: fadeRise 0.8s ease-out forwards;
      animation-delay: 0.2s; */
    }

    .fade-rise-2 {
      opacity: 0;
      transform: translateY(20px);
      /* animation: fadeRise 0.8s ease-out forwards;
      animation-delay: 0.4s; */
    }

    .fade-rise-3 {
      opacity: 0;
      transform: translateY(20px);
      /* animation: fadeRise 0.8s ease-out forwards;
      animation-delay: 0.6s; */
    }

    /* 이미지가 로드된 후 추가될 클래스에 animation 속성 추가 */
    .fade-rise-1.is-loaded {
      animation: fadeRise 0.8s ease-out forwards 0.2s;
    }
    .fade-rise-2.is-loaded {
      animation: fadeRise 0.8s ease-out forwards 0.4s;
    }
    .fade-rise-3.is-loaded {
      animation: fadeRise 0.8s ease-out forwards 0.6s;
    }

    @keyframes fadeRise {
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .fade-in-section {
      opacity: 0;
      transform: translateY(10px);
      transition: opacity 0.5s ease-out, transform 0.5s ease-out;
    }

    .fade-in-section.is-visible {
      opacity: 1;
      transform: none;
    }

    .spacer {
      height: 100vh;
    }
  </style>
</head>



<div class="posts">
  
    <div class="post fade-in-section" data-lang="en" style="display: none">
      <h1 class="post-title">
        <a href="/2024/12/26/uncountability-of-reals/en"> Proving the Uncountability of Real Numbers Without the Diagonal Argument </a>
      </h1>
    <span class="post-date">26 Dec 2024</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/mathematics/'">
        Mathematics
      </div>
      
      <div class="tag" onclick="location.href='/tags/topology/'">
        Topology
      </div>
      
    </div>
     <blockquote>
  <p><strong>Theorem.</strong> $\mathbb{R}$ is uncountable. That is, there exists no surjective function from $\mathbb{N}$ to $\mathbb{R}$.</p>
</blockquote>

<p>This is a theorem that any sophomore student would have encountered at least once. The most widely known proof is Cantor’s diagonal argument. However, there are methods to prove this theorem without the diagonal argument. These utilise the order-theoretic and topological properties of $\mathbb{R}$, respectively.</p>

<h3 id="1-proof-using-the-isomorphism-theorem">1. Proof Using the Isomorphism Theorem</h3>

<p><a href="https://dimenerno.github.io/2024/11/20/Rational-Real/">Cantor’s isomorphism theorem</a> states that all totally ordered sets $(S, \leq)$ satisfying the following conditions are order isomorphic:</p>

<ol>
  <li>$S$ is countable.</li>
  <li>$S$ is dense. That is, for $x, y \in S$ with $x &lt; y$, there exists $z \in S$ such that $x &lt; z &lt; y$.</li>
  <li>$S$ has neither an upper bound nor a lower bound.</li>
</ol>

<p>$(\mathbb{Q}, \leq)$ satisfies all three conditions above, whilst $(\mathbb{R}, \leq)$ satisfies conditions 2 and 3. Therefore, if $\mathbb{R}$ were countable, then $(\mathbb{R}, \leq)$ would be order isomorphic to $(\mathbb{Q}, \leq)$. However, the former is complete while the latter is not, so $\mathbb{R}$ is uncountable. ■</p>

<h3 id="2-proof-using-compactness">2. Proof Using Compactness</h3>

<p><img src="/public/uncountability-wo-diagnal.png" style="width: 100%; max-width: 600px; margin: 2em auto;" /></p>

<p>Let $X$ be a compact Hausdorff space with no isolated points. Also assume that $X \neq \varnothing$.</p>

<p><em>Claim 1.</em> Let $U \neq \varnothing$ be an open subset of $X$. For $x \in X$, there exists an open set $V$ such that $x \notin \bar{V}$ and $V \subset U$.</p>

<p><em>Proof of Claim 1.</em> There exists $y \in U$ where $x \neq y$. This is because if $x \in U$, then since $X$ has no isolated points such a $y$ must exist, and if $x \notin U$, then such a $y$ exists because $U$ is non-empty. Since $X$ is Hausdorff, we can separate $x$ and $y$ by neighbourhoods $V_x$ and $V_y$. Then $V = V_y \cap U$ is the desired set (the dark shaded region in Fig 1). □</p>

<p><em>Claim 2.</em> $X$ is uncountable.</p>

<p><em>Proof of Claim 2.</em> Suppose $X$ is countable. Enumerate the elements of $X$ as ${x_n}<em>{n \in \mathbb{Z}^+}$. Let $V_0 = X$. By Claim 1, for each $n$ there exists an open set $V_n$ such that $x_n \notin \bar{V_n}$ and $V_n \subset V</em>{n-1}$ (Fig 2). Since $X$ is compact, by the finite intersection property we have</p>

\[K = \bigcap_{n \in \mathbb{Z}^+} \bar{V}_n \neq \varnothing.\]

<p>However, if $x_n \in K$, then $x_n \in \bar{V}_n$, which is a contradiction. Therefore, $X$ is uncountable. □</p>

<p><em>Claim 3.</em> $\mathbb{R}$ is uncountable.</p>

<p><em>Proof of Claim 3.</em> $[0, 1]$ is a compact Hausdorff space with no isolated points. Therefore, it is uncountable. Consequently, $\mathbb{R}$ is uncountable. ■</p>

  </div>
  <div style="margin-bottom: 6em"></div>
  
    <div class="post fade-in-section" data-lang="ko" style="display: none">
      <h1 class="post-title">
        <a href="/2024/12/25/Cantor-Bendixson"> 칸토어-벤딕슨 정리와 폴란드 공간 </a>
      </h1>
    <span class="post-date">25 Dec 2024</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/수학/'">
        수학
      </div>
      
      <div class="tag" onclick="location.href='/tags/위상수학/'">
        위상수학
      </div>
      
    </div>
     <blockquote>
  <p><strong>정의.</strong> 위상공간 $X$의 집합 $P$에 대해 $P’ = P$일 때 $P$를 <strong>완벽한 집합<sub>perfect set</sub></strong>이라고 한다. ($P’$은 $P$의 집적점들의 집합)</p>
</blockquote>

<p><em>Remark.</em> 모든 완벽한 집합은 닫힌 집합이지만, 역은 성립하지 않는다. 일반적으로 $S \not\subset S’$ ($S$가 고립점을 가짐), $S’ \not\subset S$ ($S$가 닫힌 집합이 아님) 임에 유의하라. 뒤집어 말해, 완벽한 집합은 고립점이 없는 닫힌 집합이다.</p>

<blockquote>
  <p><strong>정의.</strong> $X$의 임의의 부분공간이 린델뢰프일 때 $X$를 <strong>세습적 린델뢰프<sub>hereditarily Lindelöf</sub></strong>라고 한다.</p>
</blockquote>

<blockquote>
  <p><strong>약한 칸토어-벤딕슨 정리.</strong> $X$가 세습적 린델뢰프 공간이라고 하자. $F \subset X$가 닫힌 집합일 때 어떤 완벽한 집합 $P$와 가산집합 $C$가 존재하여 $F = P \sqcup C$이다.</p>
</blockquote>

<p><img src="/public/cantor-bendixson.png" style="width: 100%; max-width: 600px; margin: 2em auto;" /></p>

<p>완벽한 집합은 고립점이 없는 닫힌 집합이므로, 위 정리는 “닫힌 집합은 최대 가산 개의 고립점을 가진다”로 재진술할 수 있다.</p>

<p><strong>증명.</strong> 다음과 같이 $P, C$를 정의한다.</p>

\[P = \lbrace  x \in F : \text{For all nbd $U$ of $x$, $U \cap F$ is uncountable} \rbrace\]

\[C = \lbrace  x \in F : \text{There exists a nbd $U$ of $x$ s.t. $U \cap F$ is countable} \rbrace\]

<p>$F = P \sqcup C$임에 주목하라.</p>

<p><em>Claim 1.</em> $C$는 $F$에서 열린 집합이다.</p>

<p><em>Proof of Claim.</em> $x \in C$일 때 어떤 $x$의 근방 $U$가 존재하여 $U \cap F$가 가산이다. 즉, 임의의 $y \in U \cap F$에 대해 $U$는 $y$의 근방이고 $U \cap F$가 가산이므로 $y \in C$이다. 따라서 $U \cap F \subset C$이다. □</p>

<p><em>Claim 2.</em> $C$는 가산이다.</p>

<p><em>Proof of Claim.</em> $F$의 부분공간 토폴로지를 생각하자. 가정에 의해 이 토폴로지는 린델뢰프이다. 임의의 $x \in C$에 대해 $U_x \cap F$가 가산인 $x$의 근방 $U_x$를 찾을 수 있다. 그러면 $\lbrace  U_x \rbrace_{x \in C}$는 $C$의 $F$-열린 덮개이며, 린델뢰프 가정에 의해 $C = \bigcup_{\alpha \in J} U_\alpha$ ($J$는 가산)이다. $U_\alpha$가 가산이므로 $C$는 가산이다. □</p>

<p><em>Claim 3.</em> $P$는 완벽하다.</p>

<p><em>Proof of Claim.</em> Claim 1에 의해 $P$는 $F$에서 닫힌 집합이며, $F$가 닫힌 집합이므로 $P$는 $X$에서 닫힌 집합이다. 따라서 $P’ \subset P$이다. 역을 보이기 위해 $x \in P$라고 하자. 임의의 $x$의 근방 $U$에 대해 $U \cap F = (U \cap C) \sqcup (U \cap P)$가 비가산이다. $C$가 가산이므로, $U \cap P$가 비가산이어야 한다. 따라서 $U$는 $P$와 $\lbrace x \rbrace$보다 큰 교집합을 가지며, $x \in P’$이다. ■</p>

<blockquote>
  <p><strong>정의.</strong> 분리 가능한<sub>separable</sub> 완비 거리화 가능 공간을 <strong>폴란드 공간<sub>Polish space</sub></strong>이라고 한다.</p>
</blockquote>

<p>거리화 가능 공간에서 분리 가능성, 2차 가산, 그리고 린델뢰프는 동치이므로 해당 세 가지 조건 중 하나로 정의를 대체할 수 있다. ‘폴란드 공간’이라는 이름은 해당 공간을 처음으로 연구한 학자들인 시에르핀스키, 쿠라토프스키, 타르스키 등이 폴란드인들인 데에서 유래했다.</p>

<p>$X$가 폴란드 공간이라는 더 강한 조건이 주어지면 칸토어-벤딕슨 분해가 유일함을 증명할 수 있다.</p>

<blockquote>
  <p><strong>강한 칸토어-벤딕슨 정리.</strong> $X$가 폴란드 공간이라고 하자. $F \subset X$가 닫힌 집합일 때 어떤 완벽한 집합 $P$와 가산집합 $C$가 존재하여 $F = P \sqcup C$이다. 또한, 해당 분해는 유일하다.</p>
</blockquote>

<p>또한 다음이 성립한다.</p>

<blockquote>
  <p><strong>정리.</strong> 폴란드 공간의 완벽한 집합은 $2^{\aleph_0}$의 크기를 가진다.</p>
</blockquote>

<p><strong>증명.</strong> 추후 기술적 집합론에 대한 글에서 따로 다룰 예정.</p>

<p>이로부터 다음의 결론이 따라 나온다.</p>

<blockquote>
  <p><strong>따름정리: 실수의 닫힌집합에서의 연속체 가설.</strong> 실수의 닫힌집합은 가산이거나 $2^{\aleph_0}$의 크기를 가진다.</p>
</blockquote>

<p><strong>증명.</strong> 실수는 폴란드 공간이므로 칸토어-벤딕슨 정리에 의해 모든 닫힌집합이 가산집합과 완벽한 집합의 서로소 합으로 분해된다. 후자가 공집합일 경우 해당 닫힌집합은 가산이며, 그렇지 않을 경우 $2^{\aleph_0}$이다. ■</p>

<p>칸토어는 위 정리의 증명으로부터 일반적인 연속체 가설을 증명할 수 있으리라는 희망을 품었지만 잘 알려져 있다시피 그 희망은 실현되지 못했다.</p>

  </div>
  <div style="margin-bottom: 6em"></div>
  
    <div class="post fade-in-section" data-lang="en" style="display: none">
      <h1 class="post-title">
        <a href="/2024/12/25/Cantor-Bendixson/en"> The Cantor-Bendixson Theorem and Polish Space </a>
      </h1>
    <span class="post-date">25 Dec 2024</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/mathematics/'">
        Mathematics
      </div>
      
      <div class="tag" onclick="location.href='/tags/topology/'">
        Topology
      </div>
      
    </div>
     <blockquote>
  <p>This post was machine translated and has not yet been proofread. It may contain minor errors or unnatural expressions. Proofreading will be done in the near future.</p>
</blockquote>

<blockquote>
  <p><strong>Definition.</strong> A set $P$ in a topological space $X$ is <strong>perfect</strong> when $P’ = P$. Here, $P’$ denotes the set of limit points of $P$.</p>
</blockquote>

<p><em>Remark.</em> Every perfect set is a closed set, but the converse does not hold. Recall that in general $S \not\subset S’$ (when $S$ has isolated points) and $S’ \not\subset S$ (when $S$ is not a closed set). It follows that <em>a perfect set is a closed set with no isolated points.</em></p>

<blockquote>
  <p><strong>Definition.</strong> A topological space $X$ is <strong>hereditarily Lindelöf</strong> when every subspace of $X$ is Lindelöf.</p>
</blockquote>

<blockquote>
  <p><strong>Weak Cantor-Bendixson Theorem.</strong> Let $X$ be a hereditarily Lindelöf space. For any closed set $F \subset X$, there exist a perfect set $P$ and a countable set $C$ such that $F = P \sqcup C$.</p>
</blockquote>

<p><img src="/public/cantor-bendixson.png" style="width: 100%; max-width: 600px; margin: 2em auto;" /></p>

<p>Since a perfect space is a closed space with no isolated points, the above theorem can be restated as: A closed subspace of a hereditarily Lindelöf space has at most countable isolated points.</p>

<p><strong>Proof.</strong> We define $P$ and $C$ as follows:</p>

\[P = \lbrace  x \in F : \text{For all nbd $U$ of $x$, $U \cap F$ is uncountable} \rbrace\]

\[C = \lbrace  x \in F : \text{There exists a nbd $U$ of $x$ s.t. $U \cap F$ is countable} \rbrace\]

<p>Note that $F = P \sqcup C$.</p>

<p><em>Claim 1.</em> $C$ is open in $F$.</p>

<p><em>Proof of Claim.</em> When $x \in C$, there exists a neighbourhood $U$ of $x$ such that $U \cap F$ is countable. That is, for any $y \in U \cap F$, $U$ is a neighbourhood of $y$ and $U \cap F$ is countable, so $y \in C$. Therefore $U \cap F \subset C$. □</p>

<p><em>Claim 2.</em> $C$ is countable.</p>

<p><em>Proof of Claim.</em> Consider the subspace topology on $F$. By hypothesis, this topology is Lindelöf. For any $x \in C$, we can find a neighbourhood $U_x$ of $x$ such that $U_x \cap F$ is countable. Then $\lbrace  U_x \rbrace_{x \in C}$ is an $F$-open cover of $C$, and by the Lindelöf hypothesis, $C = \bigcup_{\alpha \in J} U_\alpha$ where $J$ is countable. Since each $U_\alpha$ is countable, $C$ is countable. □</p>

<p><em>Claim 3.</em> $P$ is perfect.</p>

<p><em>Proof of Claim.</em> By Claim 1, $P$ is a closed set in $F$, and since $F$ is a closed set, $P$ is a closed set in $X$. Therefore $P’ \subset P$. To show the reverse inclusion, let $x \in P$. For any neighbourhood $U$ of $x$, we have that $U \cap F = (U \cap C) \sqcup (U \cap P)$ is uncountable. Since $C$ is countable, $U \cap P$ must be uncountable. Therefore $U$ has intersection with $P$ larger than $\lbrace x \rbrace$, and hence $x \in P’$. ■</p>

<blockquote>
  <p><strong>Definition.</strong> A separable complete metrisable space is called a <strong>Polish space</strong>.</p>
</blockquote>

<p>In metrisable spaces, separability, second countability, and the Lindelöf property are equivalent, so the definition can be replaced with any of these three conditions. The name ‘Polish space’ derives from the fact that the mathematicians who first studied these spaces — Sierpiński, Kuratowski, Tarski — were Polish.</p>

<p>When the stronger condition that $X$ is a Polish space is given, one can prove that the Cantor-Bendixson decomposition is unique.</p>

<blockquote>
  <p><strong>Strong Cantor-Bendixson Theorem.</strong> Let $X$ be a Polish space. For any closed set $F \subset X$, there exist a perfect set $P$ and a countable set $C$ such that $F = P \sqcup C$. Moreover, this decomposition is unique.</p>
</blockquote>

<p>The following also holds:</p>

<blockquote>
  <p><strong>Theorem.</strong> A perfect set in a Polish space has cardinality $2^{\aleph_0}$.</p>
</blockquote>

<p><strong>Proof.</strong> This will be treated separately in a future article on descriptive set theory.</p>

<p>From this, the following conclusion follows:</p>

<blockquote>
  <p><strong>Corollary: The Continuum Hypothesis for Closed Sets of Real Numbers.</strong> A closed set of real numbers is either countable or has cardinality $2^{\aleph_0}$.</p>
</blockquote>

<p><strong>Proof.</strong> Since the real numbers form a Polish space, by the Cantor-Bendixson theorem every closed set decomposes as a disjoint union of a countable set and a perfect set. If the latter is empty, then the closed set is countable; otherwise it has cardinality $2^{\aleph_0}$. ■</p>

<p>Cantor had hoped that from the proof of the above theorem he might be able to prove the general continuum hypothesis, but as is well known, this hope was not realised.</p>

  </div>
  <div style="margin-bottom: 6em"></div>
  
    <div class="post fade-in-section" data-lang="ko" style="display: none">
      <h1 class="post-title">
        <a href="/2024/12/16/adjoints"> 어드조인트에 대한 직관적 이해 </a>
      </h1>
    <span class="post-date">16 Dec 2024</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/수학/'">
        수학
      </div>
      
      <div class="tag" onclick="location.href='/tags/범주론/'">
        범주론
      </div>
      
    </div>
     <p>카테고리 이론의 핵심 개념 중 하나는 어드조인트<sub>adjoint</sub>이다.</p>

<blockquote>
  <p><strong>정의.</strong> $\mathcal{A}, \mathcal{B}$가 카테고리이고, $F: \mathcal{A} \to \mathcal{B}, G: \mathcal{B} \to \mathcal{A}$가 함자<sub>functor</sub>라고 하자. $F$가 $G$의 <strong>좌 어드조인트<sub>left adjoint</sub></strong>라는 것은 임의의 $A \in \mathcal{A}, B \in \mathcal{B}$에 대해 $\mathcal{B}(F(A), B)$와 $\mathcal{A}(A, G(B))$가 자연스럽게 일대일 대응될 수 있다는 것이다. 즉,</p>

\[\begin{gather}
(F(A) \xrightarrow{g} B) \quad \mapsto \quad (A \xrightarrow{\bar{g}} G(B))\\
(A \xrightarrow{f} G(B)) \quad \mapsto \quad (F(A) \xrightarrow{\bar{f}} B)
\end{gather}\]

  <p>또한 $G$를 $F$의 <strong>우 어드조인트<sub>right adjoint</sub></strong>라고 한다. 기호로 $F \dashv G$로 표기한다.</p>
</blockquote>

<p>이 정의는 다소 추상적으로 느껴질 수 있지만, 이해를 돕는 몇 가지 직관이 있다.</p>

<h3 id="1-근사로서의-어드조인트">1. 근사로서의 어드조인트</h3>

<p>$F \dashv G$일 때 $F, G$는 $\mathcal{A}$과 $\mathcal{B}$의 원소들을 서로 근사하는 방법으로 생각할 수 있다. 특히 좌 어드조인트는 ‘좌측에서 우측으로‘의 근사이고, 우 어드조인트는 ‘우측에서 좌측으로’의 근사이다.</p>

<p>예를 들어 $\mathbf{Z}$가 정수를 원소로 가지고, $x \leq y$일 때 그리고 오직 그 경우에만 $x \to y$ 사상이 유일하게 존재하는 카테고리라고 하자. 또한 $\mathbf{R}$이 실수를 원소로 가지고, $x \leq y$일 때 그리고 오직 그 경우에만 $x \to y$ 사상이 유일하게 존재하는 카테고리라고 하자. 이때 $\lceil \cdot \rceil, \lfloor \cdot \rfloor$는 표준적인 방식으로 함자 $\mathbf{R} → \mathbf{Z}$가 되고, 포함 사상 $\iota$는 함자 $\mathbf{Z} → \mathbf{R}$이 된다. 또한 $\lceil \cdot \rceil \dashv \iota \dashv \lfloor \cdot \rfloor$임을 확인할 수 있다.</p>

<p><img src="/public/adjoint-int-2.png" style="width: 100%; max-width: 180px; margin: 0 auto;" /></p>

<p>즉 $\lceil \cdot \rceil$는 $r$을 $r \leq \lceil r \rceil$로 ‘좌측에서 우측으로 끌어올리는’ 변환이고, $\lfloor \cdot \rfloor$은 $r$을 $\lfloor r \rfloor \leq r$로 ‘우측에서 좌측으로 잡아당기는’ 변환이다.</p>

<p>또한 $I, T$가 각각 $\mathcal{A}$의 초기 대상<sub>initial object</sub> 및 종단 대상<sub>terminal object</sub>라고 하자. 즉, 임의의 $A \in \mathcal{A}$에 대해</p>

<ul>
  <li>사상 $I \to A$가 유일하게 존재한다.</li>
  <li>사상 $A \to T$가 유일하게 존재한다.</li>
</ul>

<p>일례로 $\mathbf{Set}$에서 공집합은 초기 대상이고 홑원소 집합은 종단 대상이다.</p>

<p>홑원소 카테고리 $\mathcal{U}$에 대해 함자 $F: \mathcal{A} \to \mathcal{U}$가 유일하게 존재한다. $G_I, G_T: \mathcal{U} \to \mathcal{A}$가 각각 상이 $I, T$인 함자라고 하자. 이때 앞선 경우와 비슷한 원리로 $G_T \dashv F \dashv G_I$가 됨을 확인하라. (종단 대상은 가장 “오른쪽”에 있는 대상이므로 $G_T$는 “왼쪽에서 오른쪽으로”의 근사이며, 초기 대상은 가장 “왼쪽”에 있는 대상이므로 $G_I$는 “오른쪽에서 왼쪽으로”의 근사이다.)</p>

<h3 id="2-구축과-파괴로서의-어드조인트">2. 구축과 파괴로서의 어드조인트</h3>

<p>좌 어드조인트는 구축을, 우 어드조인트는 파괴를 의미한다. 따라서 일반적으로 자유함자<sub>free functor</sub>는 좌 어드조인트, 망각함자<sub>forgetful functor</sub>는 우 어드조인트이다.</p>

<p>일례로 군의 카테고리를 $\mathbf{Grp}$, 모노이드의 카테고리를 $\mathbf{Mon}$이라 하자. $F$를 자유함자, $U$를 망각함자라고 하자. 그리고 $R: \mathbf{Mon} → \mathbf{Grp}$를 다음과 같이 정의한다.</p>

<ul>
  <li>$R(M) = \lbrace  m \in M : \exists m^{-1} \in M \rbrace$</li>
  <li>$R(f): m \mapsto f(m)$</li>
</ul>

<p>이때, 다음 다이어그램이 성립하여 $F \dashv U \dashv R$이다.</p>

<p><img src="/public/adjoint-int-3.png" style="width: 100%; max-width: 170px; margin: 0 auto;" /></p>

<p>$R$이 $U$보다 더 파괴적이기 때문에 $U \dashv R$인 것으로 이해할 수 있다.</p>

  </div>
  <div style="margin-bottom: 6em"></div>
  
    <div class="post fade-in-section" data-lang="en" style="display: none">
      <h1 class="post-title">
        <a href="/2024/12/16/adjoints/en"> An Intuitive Understanding of Adjoints </a>
      </h1>
    <span class="post-date">16 Dec 2024</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/mathematics/'">
        Mathematics
      </div>
      
      <div class="tag" onclick="location.href='/tags/category-theory/'">
        Category Theory
      </div>
      
    </div>
     <p>One of the central concepts in category theory is that of an adjoint.</p>

<blockquote>
  <p><strong>Definition.</strong> Let $\mathcal{A}, \mathcal{B}$ be categories, and let $F: \mathcal{A} \to \mathcal{B}, G: \mathcal{B} \to \mathcal{A}$ be functors. We say that $F$ is a <strong>left adjoint</strong> to $G$, written as $F \dashv G$, if for any $A \in \mathcal{A}, B \in \mathcal{B}$, there exists a natural correspondence between $\hom_\mathcal{B}(F(A), B)$ and $\hom_\mathcal{A}(A, G(B))$. That is,</p>

\[\begin{gather}
(F(A) \xrightarrow{g} B) \quad \mapsto \quad (A \xrightarrow{\bar{g}} G(B))\\
(A \xrightarrow{f} G(B)) \quad \mapsto \quad (F(A) \xrightarrow{\bar{f}} B)
\end{gather}\]

  <p>We also call $G$ the <strong>right adjoint</strong> to $F$.</p>
</blockquote>

<p>This may feel very abstract, but there is a couple of examples that could be of assist in grasping the definition.</p>

<h3 id="1-adjoints-as-approximations">1. Adjoints as Approximations</h3>

<p>When $F \dashv G$, the functors $F$ and $G$ can be thought of as approximating objects in $\mathcal{A}$ and $\mathcal{B}$ with respect to each other. In particular, the left adjoint represents approximation ‘from left to right’, whilst the right adjoint represents approximation ‘from right to left’.</p>

<p>For example, let $\mathbf{Z}$ be a category whose objects are integers, with a unique morphism $x \to y$ existing if and only if $x \leq y$. Similarly, let $\mathbf{R}$ be a category whose objects are real numbers, with a unique morphism $x \to y$ existing if and only if $x \leq y$. We may think of $\lceil \cdot \rceil, \lfloor \cdot \rfloor$ as functors $\mathbf{R} → \mathbf{Z}$, and the inclusion map $\iota$ as a functor $\mathbf{Z} → \mathbf{R}$. It then follows that $\lceil \cdot \rceil \dashv \iota \dashv \lfloor \cdot \rfloor$.</p>

<p><img src="/public/adjoint-int-2.png" style="width: 100%; max-width: 180px; margin: 0 auto;" /></p>

<p>That is, $\lceil \cdot \rceil$ is a transformation that ‘lifts [a number] from left to right’ by mapping $r$ to $\lceil r \rceil$ with $r \leq \lceil r \rceil$, whilst $\lfloor \cdot \rfloor$ is a transformation that ‘pulls [a number] from right to left’ by mapping $r$ to $\lfloor r \rfloor$ with $\lfloor r \rfloor \leq r$.</p>

<p>Furthermore, let $I$ and $T$ be the initial object and terminal object of $\mathcal{A}$ respectively. That is, for any $A \in \mathcal{A}$:</p>

<ul>
  <li>There exists a unique morphism $I \to A$.</li>
  <li>There exists a unique morphism $A \to T$.</li>
</ul>

<p>For instance, in $\mathbf{Set}$, the empty set is the initial object and any singleton set is a terminal object.</p>

<p>For the singleton category $\mathcal{S}$, there exists a unique functor $F: \mathcal{A} \to \mathcal{S}$ that maps every object of $\mathcal{A}$ to the single object of $\mathcal{S}$. Let $G_I, G_T: \mathcal{S} \to \mathcal{A}$ be functors that maps the single object of $\mathcal{S}$ to $I$ and $T$, respectively. It then follows that $G_T \dashv F \dashv G_I$. (Since the terminal object is the ‘rightmost’ object, $G_T$ represents approximation ‘from left to right’, whilst since the initial object is the ‘leftmost’ object, $G_I$ represents approximation ‘from right to left’.)</p>

<h3 id="2-adjoints-as-construction-and-destruction">2. Adjoints as Construction and Destruction</h3>

<p>Left adjoints are associated with construction, whilst right adjoints are associated with destruction. Therefore, free functors are generally left adjoints, whilst forgetful functors are right adjoints.</p>

<p>For instance, let $\mathbf{Grp}$ be the category of groups and $\mathbf{Mon}$ be the category of monoids. Let $F$ be the free functor and $U$ be the forgetful functor. Define $R: \mathbf{Mon} → \mathbf{Grp}$ as follows:</p>

<ul>
  <li>$R(M) = \lbrace  m \in M : \exists m^{-1} \in M \rbrace$</li>
  <li>$R(f): m \mapsto f(m)$</li>
</ul>

<p>Then the following diagram holds, yielding $F \dashv U \dashv R$.</p>

<p><img src="/public/adjoint-int-3.png" style="width: 100%; max-width: 170px; margin: 0 auto;" /></p>

<p>One can understand $U \dashv R$ as expressing that $R$ is more destructive than $U$.</p>

  </div>
  <div style="margin-bottom: 6em"></div>
  
    <div class="post fade-in-section" data-lang="ko" style="display: none">
      <h1 class="post-title">
        <a href="/2024/12/11/rolling"> 굴림에 대한 두 가지 삽화 </a>
      </h1>
    <span class="post-date">11 Dec 2024</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/물리학/'">
        물리학
      </div>
      
      <div class="tag" onclick="location.href='/tags/역학/'">
        역학
      </div>
      
    </div>
     <p>학부 시절 고전역학 수강 때 개인 공부용으로 만든 삽화인데, 잘 정리한 듯하여 이곳에도 공유한다.</p>

<p><img src="/public/rot-kr.png" style="width: 100%; margin: 0 auto" /></p>

<p><img src="/public/rolling-on-ground.png" style="width: 100%; margin: 4em auto 0em auto" /></p>

<p>굴림을 바퀴의 CM 기준으로 분석할 때 <strong>땅 또한 움직인다는 사실</strong>에 유의하자.</p>

  </div>
  <div style="margin-bottom: 6em"></div>
  
    <div class="post fade-in-section" data-lang="en" style="display: none">
      <h1 class="post-title">
        <a href="/2024/12/11/rolling/en"> Two Illustrations on Rolling </a>
      </h1>
    <span class="post-date">11 Dec 2024</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/physics/'">
        Physics
      </div>
      
      <div class="tag" onclick="location.href='/tags/mechanics/'">
        Mechanics
      </div>
      
    </div>
     <p>These are illustrations I made when I studied classical mechanics in my BA. They seem to be well-made, so I decided to share them here, too.</p>

<p><img src="/public/rot-en.png" style="width: 100%; margin: 0 auto" /></p>

<p>Note that decomposing Revolution as the sum of Rotation about CM and Rotation about Axis is a specific case of the central axis theorem.</p>

<p><img src="/public/rolling-on-ground.png" style="width: 100%; margin: 4em auto 0em auto" /></p>

<p>Note that when analysing Rolling from CM’s frame, the ground also moves at $v = -r\omega$.</p>

  </div>
  <div style="margin-bottom: 6em"></div>
  
    <div class="post fade-in-section" data-lang="ko" style="display: none">
      <h1 class="post-title">
        <a href="/2024/12/11/VL-axiom"> V = L 공리의 무모순성 </a>
      </h1>
    <span class="post-date">11 Dec 2024</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/수학/'">
        수학
      </div>
      
      <div class="tag" onclick="location.href='/tags/집합론/'">
        집합론
      </div>
      
    </div>
     <blockquote>
  <p>영문 버전의 글이 더 정확하고 설명이 풍부하니 참고하시길 바랍니다.</p>
</blockquote>

<h2 id="1-전체">1. 전체</h2>

<h3 id="11-폰-노이만-전체">1.1. 폰 노이만 전체</h3>

<p><a href="https://dimenerno.github.io/2024/12/05/transfinite-recursion/">초한귀납적으로</a> $\lbrace  V_\alpha \rbrace$를 정의하자.</p>

<ul>
  <li>$V_0 = \varnothing$</li>
  <li>$V_{\alpha + 1} = V_\alpha \cup \mathcal{P}(V_\alpha)$</li>
  <li>$\lambda$가 극한 서수일 때, $V_\lambda = \bigcup_{\alpha &lt; \lambda} V_\alpha$</li>
</ul>

<p>처음 몇 개의 $V_\alpha$는 다음과 같다.</p>

<ul>
  <li>$V_1 = \lbrace  \varnothing \rbrace$</li>
  <li>$V_2 = \lbrace  \varnothing, \lbrace  \varnothing \rbrace \rbrace$</li>
  <li>$V_3 = \lbrace  \varnothing, \lbrace  \varnothing \rbrace, \lbrace  \lbrace  \varnothing \rbrace \rbrace, \lbrace  \varnothing, \lbrace  \lbrace  \varnothing\rbrace \rbrace  \rbrace$</li>
  <li>$V_\omega = \mathsf{HF}$</li>
</ul>

<p>모든 서수 $\alpha$에 대해 $V_\alpha$를 모아둔 모임을 <strong>폰 노이만 전체</strong>라고 한다.</p>

\[V = \bigcup_{\alpha \in \mathrm{Ord}} V_\alpha\]

<p>$x \in y \in z$가 $x \in z$를 시사할 때 $z$를 <strong>추이적 집합<sub>transitive set</sub></strong>이라고 한다. 이것은 $V$의 중요한 특징이다.</p>

<blockquote>
  <p><strong>정리.</strong></p>

  <ol>
    <li>$\alpha \in \mathrm{Ord}$에 대해 $V_\alpha$는 추이적이다.</li>
    <li>$V$는 추이적이다.</li>
  </ol>
</blockquote>

<p>증명은 초한귀납법을 이용한다. 이에 따라 $V$를 다음과 같이 정의해도 무방하다.</p>

<ul>
  <li>$V_0 = \varnothing$</li>
  <li>$V_{\alpha + 1} = \mathcal{P}(V_\alpha)$</li>
  <li>$\lambda$가 극한 서수일 때, $V_\lambda = \bigcup_{\alpha &lt; \lambda}V_\alpha$</li>
</ul>

<p>직관적으로 생각했을 때 $V$는 모든 집합을 포함하는 듯하다. 실제로 다음을 증명할 수 있다.</p>

<blockquote>
  <p><strong>정리.</strong> $x$가 집합이라면 $x \in V$이다.</p>
</blockquote>

<p><strong>증명.</strong> 집합 $x$에 대해 $x$의 <strong>추이적 폐포</strong> $\bar{x}$를, $x$를 원소로 가지는 가장 작은 추이적 집합으로 정의한다(추이적 집합들의 교집합은 추이적이기 때문에 이 정의는 정당하다).</p>

<p>$x \notin V$라고 가정하자. 분류 공리에 의해 $y = \lbrace  u \in \bar{x} : u \notin V \rbrace$가 집합이며, 정초 공리에 의해 $y$의 $\in$-극소 원소 $z$가 존재한다. 만약 $w \notin V$인 $w \in z$가 존재한다면, 추이성에 의해 $w \in y$가 되어 $z$의 $\in$-극소성과 모순된다. 따라서 $z$의 모든 원소는 $V$에 있으며, 치환 공리로부터 $\Omega = \lbrace  \alpha \in \mathrm{Ord} \mid \exists w \in z : w \in V_\alpha\rbrace$가 집합이다. $\beta = \bigcup_{\alpha \in \Omega}\alpha$라고 하자. $\beta$는 서수이며, $z \in V_{\beta + 1}$이다. (이 부분에서 $V_{\beta + 1} = \mathcal{P}(V_\beta)$임이 필요하다) 따라서 모순이다. ■</p>

<p>이에 따라 $V$는 집합이 아니다. 따라서 $V$는 모든 집합을 포함한다는 점에서 ZFC의 모델이지만, <a href="https://math.stackexchange.com/questions/56726/how-can-there-be-genuine-models-of-set-theory">많은 수학자들은 모델이 집합일 것을 요구하기 때문에</a> 엄격한 의미에서의 모델은 아니다. 하지만 이 글에서는 편의를 위해 $V$를 집합론의 모델이라고 부르도록 한다. 또한 $x \in V$를 “$x$는 집합이다“의 형식적 표현으로 이해하도록 한다.</p>

<h3 id="12-괴델-구성-가능-전체">1.2. 괴델 구성 가능 전체</h3>

<p>먼저 다음과 같이 구성 가능성을 정의한다.</p>

<blockquote>
  <p><strong>정의.</strong> $u$가 집합 $S$로부터 <strong>구성 가능</strong>하다는 것은, 어떤 1차 논리 명제 $\phi(y, x_1, \dots, x_n)$와 $c_1, \dots, c_n \in S$가 존재하여 다음이 성립하는 것이다.</p>

\[y \in u \iff y \in S \land \phi(y, c_1, \dots, c_n)\]

  <p>단, $\phi$의 양화사의 정의역은 $S$이다.</p>
</blockquote>

<p>예를 들어 $S = \lbrace 0, 1, 2\rbrace$일 때 다음은 $u = \lbrace  1, 2 \rbrace$를 구성한다.</p>

<ul>
  <li>$\phi(y, x_1, x_2) := (y = x_1) \lor (y = x_2)$</li>
  <li>$c_1 = 1, c_2 = 2$</li>
</ul>

<p>또한 $S = \mathbb{N}$일 때 다음은 $u = \lbrace 0, 3, 6, 9, \dots \rbrace$를 구성한다.</p>

<ul>
  <li>$\phi(y, x_1) := x_1 \mid y$</li>
  <li>$c_1 = 3$</li>
</ul>

<p>괴델의 구성가능성은 일반적인 의미에서의 구성가능성, 즉 언어로서의 표현가능성과 다르다. 일례로 언어로 표현가능한 실수의 집합은 가산이므로, 어떤 실수는 언어로 표현이 불가능하다. 그러한 실수를 $r$이라고 하자. 이제 $S = \mathbb{R}$일 때, 다음은 $u = \lbrace  r \rbrace$을 구성한다.</p>

<ul>
  <li>$\phi(y, x_1) := x_1 = y$</li>
  <li>$c_1 = r$</li>
</ul>

<p>즉, 괴델의 구성가능성은 자유변수의 초기화를 임의의 원소에 대해 허용한다는 점에서 강력하다. 그러나 자유변수의 수가 유한하다는 점에서 한계를 가진다. 이제 초한귀납적으로 $\lbrace  L_\alpha \rbrace$를 정의하자.</p>

<ul>
  <li>$L_0 = \varnothing$</li>
  <li>$L_{\alpha + 1} = \lbrace  x : x \text{ is constructible from } L_\alpha  \rbrace$</li>
  <li>$\lambda$가 극한 서수일 때, $L_\lambda = \bigcup_{\alpha &lt; \lambda} L_\alpha$</li>
  <li>$L = \bigcup_{\alpha &lt; \lambda} L_\alpha$</li>
</ul>

<p>$\alpha &lt; \omega$일 때 $L_\alpha = V_\alpha$임을 쉽게 보일 수 있다. $\alpha = n$일 때, 최대 $n$개의 $\lor$ 연언으로 $x \in V_\alpha$를 구성할 수 있기 때문이다. 따라서,</p>

<ul>
  <li>$L_1 = \lbrace  \varnothing \rbrace$</li>
  <li>$L_2 = \lbrace  \varnothing, \lbrace  \varnothing \rbrace \rbrace$</li>
  <li>$L_3 = \lbrace  \varnothing, \lbrace  \varnothing \rbrace, \lbrace  \lbrace  \varnothing \rbrace \rbrace, \lbrace  \varnothing, \lbrace  \lbrace  \varnothing\rbrace \rbrace  \rbrace$</li>
  <li>$L_\omega = \mathsf{HF}$</li>
</ul>

<p>하지만 $L_{\omega + 1} \subsetneq V_{\omega + 1}$이다. $\mathcal{P}(\mathbb{N}) \subset V_{\omega + 1}$이므로 $V_{\omega + 1}$은 비가산인 반면, 1차 논리 문장들의 집합과 $L_\omega$는 모두 가산이므로 $L_{\omega + 1}$ 또한 가산이기 때문이다. 일반적으로 $\alpha$가 가산일 때 $L_\alpha$는 가산이다.</p>

<p>그럼에도 $L$은 $V$와 많은 특징을 공유한다. 일례로,</p>

<blockquote>
  <p><strong>정리.</strong> $\alpha \in \mathrm{Ord}$에 대해 다음이 성립한다.</p>

  <ol>
    <li>$L_\alpha$는 추이적이다. (따라서 $L$이 추이적이다)</li>
    <li>$\alpha \in L_{\alpha + 1} \setminus L_{\alpha}$</li>
  </ol>
</blockquote>

<p>증명은 초한귀납법을 사용한다.</p>

<p>$L$은 모든 서수를 포함하므로 부랄리포르티 정리에 의해 집합이 아님에 유의하라. 대신 $x \in L_\alpha$에 대응되는 1차 논리식 $\mathsf{IsInL}_\alpha(x)$가 존재한다. 증명은 조금 까다로운데, 괴델 수를 이용하여 명제를 산술화하면 된다. (<a href="https://math.stackexchange.com/questions/198437/a-formula-that-defines-constructible-universe">링크</a> 참조) 따라서 $x \in L$을 $\exists \alpha \in \mathrm{Ord} :\mathsf{IsInL}_\alpha(x)$를 대체하는 형식적 표현으로 이해하여 사용하도록 한다. (물론 $\alpha \in \mathrm{Ord}$ 또한 1차 논리식을 대체하는 형식적 표현으로 이해되어야 한다)</p>

<h2 id="2-상대화">2. 상대화</h2>

<h3 id="21-명제의-상대화">2.1. 명제의 상대화</h3>

<p>1차 논리 명제는 양화사를 포함할 수 있다. 때문에 양화사의 정의역을 어떻게 설정하느냐의 따라 명제의 의미가 달라진다.</p>

<p>명제 $\phi$와 집합 (또는 모임) $A$에 대해, $\phi$의 상대화 $\phi^A$를 $\phi$의 모든 양화사를 $A$로 제한한 명제로 정의한다. 약간의 서사적 표현을 곁들이자면, $\phi^A$는 $A$의 “내부”에서 이해한 $\phi$라고 할 수 있겠다. 예를 들어, $\phi : \forall x \; \exists y : y &lt; x$일 때</p>

<ul>
  <li>$\phi^\mathbb{N} : \forall x \in \mathbb{N} \; \exists y \in \mathbb{N} : y &lt; x$</li>
  <li>$\phi^\mathbb{Z} : \forall x \in \mathbb{Z} \; \exists y \in \mathbb{Z} : y &lt; x$</li>
</ul>

<p>$T_\mathbb{Q}$가 자연수 및 정수를 특정할 수 있는 정도의 표현력을 지니는 유리수 이론이라고 하면,</p>

<ul>
  <li>$T_\mathbb{Q} \vdash \phi$</li>
  <li>$T_\mathbb{Q} \not\vdash \phi^\mathbb{N}$</li>
  <li>$T_\mathbb{Q} \vdash \phi^{\mathbb{Z}}$</li>
</ul>

<p>이다. 따라서 $\phi$는 자연수와 유리수를 성공적으로 구분해 내지만, 정수와 유리수는 구분해 내지 못한다. 이 관찰을 일반화하면, 이론 $T$와 집합 $A$에 대해 $T \vdash \phi \leftrightarrow \phi^A$인 $\phi$가 많으면 많을수록 $A$는 $T$의 기술에 잘 “부합한다“고 말할 수 있다.</p>

<p>위 논의를 조금 일반화하여, 다음과 같이 정의한다.</p>

<blockquote>
  <p><strong>정의.</strong> 이론 $T$와 집합 $A$에 대해서</p>

\[T \vdash \forall x_1, \dots, x_n \in A (\phi(x_1, \dots, x_n) \leftrightarrow \phi^A(x_1, \dots, x_n))\]

  <p>일 때, $\phi$는 $A$에 대해 <strong>절대적<sub>absolute</sub></strong>이라고 한다.</p>
</blockquote>

<p>일례로 $T_\mathbb{Q}$에 대해 $\phi(x) : \exists y (y &lt; x)$는 정수에 대해 절대적이지만 자연수에 대해 절대적이지는 않다.</p>

<h3 id="22-l-상대화">2.2. $L$-상대화</h3>

<p>이제 우리의 목표는 $L$이 $\mathsf{ZF}$와 극대적으로 부합함을 보이는 것이다. 즉,</p>

<blockquote>
  <p><strong>정리 1.</strong> $\phi$가 ZF의 공리라면 $\mathsf{ZF} \vdash \phi^L$이다.</p>
</blockquote>

<p>정리 1의 의미를 말로 풀어 보자면,</p>

<blockquote>
  <p>“$L$의 내부에서 보았을 때 $L$은 ZF의 모델이다”를 ZF로 증명할 수 있다.</p>
</blockquote>

<p>물론 우리는 $L \subset V$만 알고 $V = L$인지는 알지 못하기 때문에, 어떤 집합 $x$는 $L$에 속하지 않을 수도 있다. 그러나 설령 $x \in V \setminus L$인 집합 $x$가 있더라도, 그러한 $x$의 결여는 $L$의 <em>내적 정합성</em>을 깨뜨리지 않는다는 것이 정리 1의 내용이다.</p>

<p>예를 들어 어떤 집합 $y, z$에 대해 $x = \lbrace  y, z \rbrace$가 $L$에 결여되어 있다고 하자. 일면 $x$의 결여는 $L$이 짝 공리 $\mathsf{Pair}$을 만족하지 않음을 시사하는 듯하다.</p>

\[\mathsf{Pair} := \forall y, z \; \exists x \; \forall w: w \in x \leftrightarrow (w = y \lor w = z)\]

<p>하지만 $L$의 내부에서 본 짝 공리는 다음과 같다.</p>

\[\mathsf{Pair}^L := \forall y, z \in L \; \exists x \in L \; \forall w \in L: w \in x \leftrightarrow (w = y \lor w = z)\]

<p>$\forall y, z$의 양화 또한 $L$로 한정됨에 주목하라. 즉, $x = \lbrace  y, z \rbrace$의 결여가 $L$에게 문제를 일으키는 경우는 $y, z \in L$일 때이다. 거꾸로 말해, $x = \lbrace  y, z \rbrace \notin L$이 $y, z \notin L$을 시사한다면 $L$은 $\mathsf{Pair}^L$을 만족한다. 이것이 “$L$이 내적 정합성을 유지하는 방식으로 집합을 결여한다”의 의미이다.</p>

<p>정리 1이 성립하는 핵심 이유는 $L$과 $V$가 <strong>추이성이라는 성질을 공유</strong>하기 때문이다.</p>

<blockquote>
  <p><strong>보조정리.</strong> 다음 술어는 ZF에서 $L$에 대해 절대적이다.</p>

  <ol>
    <li>$x \in y$</li>
    <li>$x \subset y$</li>
    <li>$x = \bigcup y$</li>
    <li>$x = \lbrace  y, z \rbrace$</li>
    <li>$\alpha \in \mathrm{Ord}$</li>
    <li>$x$는 추이적이다.</li>
    <li><a href="https://math.stackexchange.com/questions/404699/delta-0-formulas">$\Delta_0$ 논리식</a></li>
  </ol>
</blockquote>

<p>또한 다음을 증명할 수 있다.</p>

<blockquote>
  <p><strong>정리 2.</strong> $\mathsf{ZF} \vdash (V = L)^L$</p>
</blockquote>

<p>여기서 $V = L$은, “모든 집합이 $L$에 속한다”를 의미한다. 따라서 일면 보기에 $(V = L)^L$은 “$L$에 속하는 모든 집합이 $L$에 속한다”라는 자명한 명제인 듯하다. 하지만 실제로 $V = L$을 논리식으로 적으면</p>

\[\forall x \; \exists \alpha  : \alpha \in \mathrm{Ord} \land x \in L_\alpha\]

<p>이므로 $(V = L)^L$은</p>

\[\forall x \in L \; \exists \alpha \in L : (\alpha \in \mathrm{Ord})^L \land (x \in L_\alpha)^L\]

<p>이다. 특히, $\alpha \in \mathrm{Ord}$와 $x \in L_\alpha$가 진정한 의미에서의 $\in$-술어가 아닌 1차 논리식의 형식적 표현이기 때문에 마찬가지로 $L$로 상대화해야 함에 유의하라. 이에 따라 $(V = L)^L$을 ZF에서 증명하기 위해서는 $\alpha \in \mathsf{Ord}$와 $x \in L_\alpha$가 절대적임을 증명해야 한다. 두 증명 모두 초한귀납법을 사용하면 가능하다.</p>

<p>정리 1과 정리 2로부터 다음을 증명할 수 있다.</p>

<blockquote>
  <p><strong>정리 3.</strong> $\mathsf{ZFL} \vdash \phi \implies \mathsf{ZF} \vdash \phi^L$</p>
</blockquote>

<p><strong>증명.</strong> $\mathsf{ZFL} \vdash \phi$의 증명 길이에 대한 귀납법으로 증명한다. 증명 길이가 0일 때 $\phi$는 ZFL의 공리이다. $\phi$가 ZF의 공리일 때 정리 1로부터 증명되고, $\phi$가 $V = L$일 때 정리 2로부터 증명된다.</p>

<p>이제 $\phi$가 $\lbrace  \psi_1, \dots, \psi_n \rbrace$에 추론 규칙을 적용하는 것으로 증명된다고 가정하자. $\psi_k$의 증명 길이는 $\phi$보다 작으므로 귀납 가정에 의해 $\mathsf{ZF} \vdash \psi_k^L$이며, 논리 공리와 추론 규칙은 $L$에 대해 절대적임을 쉽게 보일 수 있다. 따라서 $(\psi_1 \land \dots \land \psi_n) \rightarrow \phi$가 논리적 참이라면 $(\psi_1^L \land \dots \land \psi_n^L) → \phi^L$ 또한 논리적 참이며, 이에 따라 $\mathsf{ZF} \vdash \phi^L$이다. ■</p>

<p>정리 3의 따름정리로서 정리 4를 얻는다.</p>

<blockquote>
  <p><strong>정리 4.</strong> ZF가 무모순적이라면 ZFL 또한 무모순적이다.</p>
</blockquote>

<p><strong>증명.</strong> ZFL이 모순적이라면 $\mathsf{ZFL} \vdash \varnothing \neq \varnothing$이며, 정리 3에 의해 $\mathsf{ZF} \vdash (\varnothing \neq \varnothing)^L \iff \mathsf{ZF} \vdash \varnothing \neq \varnothing$이다.</p>

<p>따라서 <strong>V = L은 ZF와 일관적이다</strong>.</p>

  </div>
  <div style="margin-bottom: 6em"></div>
  
    <div class="post fade-in-section" data-lang="en" style="display: none">
      <h1 class="post-title">
        <a href="/2024/12/11/VL-axiom/en"> Consistency of the V = L Axiom </a>
      </h1>
    <span class="post-date">11 Dec 2024</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/mathematics/'">
        Mathematics
      </div>
      
      <div class="tag" onclick="location.href='/tags/set-theory/'">
        Set Theory
      </div>
      
    </div>
     <h2 id="1-universe">1. Universe</h2>

<h3 id="11-von-neumann-universe">1.1. Von Neumann Universe</h3>

<p>We define $\lbrace  V_\alpha \rbrace$ using <a href="https://dimenerno.github.io/2024/12/05/transfinite-recursion/">transfinite recursion</a>.</p>

<ul>
  <li>$V_0 = \varnothing$</li>
  <li>$V_{\alpha + 1} = V_\alpha \cup \mathcal{P}(V_\alpha)$</li>
  <li>When $\lambda$ is a limit ordinal, $V_\lambda = \bigcup_{\alpha &lt; \lambda} V_\alpha$</li>
</ul>

<p>The first few $V_\alpha$ are as follows:</p>

<ul>
  <li>$V_1 = \lbrace  \varnothing \rbrace$</li>
  <li>$V_2 = \lbrace  \varnothing, \lbrace  \varnothing \rbrace \rbrace$</li>
  <li>$V_3 = \lbrace  \varnothing, \lbrace  \varnothing \rbrace, \lbrace  \lbrace  \varnothing \rbrace \rbrace, \lbrace  \varnothing, \lbrace  \lbrace  \varnothing\rbrace \rbrace  \rbrace$</li>
  <li>$V_\omega = \mathsf{HF}$</li>
</ul>

<p>The collection of all $V_\alpha$ for every ordinal $\alpha$ is called the <strong>Von Neumann universe</strong>.</p>

\[V = \bigcup_{\alpha \in \mathrm{Ord}} V_\alpha\]

<p>When $x \in y \in z$ implies $x \in z$, we call $z$ a <strong>transitive set</strong>. This is an important property of $V$.</p>

<blockquote>
  <p><strong>Theorem.</strong></p>

  <ol>
    <li>For $\alpha \in \mathrm{Ord}$, $V_\alpha$ is transitive.</li>
    <li>$V$ is transitive.</li>
  </ol>
</blockquote>

<p><strong>Proof.</strong> By transfinite induction.</p>

<p>Accordingly, we can also define $V$ as follows:</p>

<ul>
  <li>$V_0 = \varnothing$</li>
  <li>$V_{\alpha + 1} = \mathcal{P}(V_\alpha)$</li>
  <li>When $\lambda$ is a limit ordinal, $V_\lambda = \bigcup_{\alpha &lt; \lambda}V_\alpha$</li>
</ul>

<p>Intuitively, $V$ appears to contain all sets. Indeed, we can prove the following:</p>

<blockquote>
  <p><strong>Theorem.</strong> If $x$ is a set, then $x \in V$.</p>
</blockquote>

<p><strong>Proof.</strong> For a set $x$, we define the <strong>transitive closure</strong> $\bar{x}$ of $x$ as the smallest transitive set containing $x$ as an element. Note that this is well-defined as the intersection of transitive sets is transitive.</p>

<p>Assume $x \notin V$. By the axiom of separation, $y = \lbrace  u \in \bar{x} : u \notin V \rbrace$ is a set, and by the axiom of foundation, there exists an $\in$-minimal element $z$ of $y$. If there exists $w \in z$ such that $w \notin V$, then by transitivity $w \in y$, contradicting the $\in$-minimality of $z$. Therefore, all elements of $z$ are in $V$, and by the axiom of replacement, $\Omega = \lbrace  \alpha \in \mathrm{Ord} \mid \exists w \in z : w \in V_\alpha\rbrace$ is a set. Let $\beta = \bigcup_{\alpha \in \Omega}\alpha$. Then $\beta$ is an ordinal, and $z \in V_{\beta + 1}$. (This is where the definition of von Neumann universe $V_{\beta + 1} = \mathcal{P}(V_\beta)$ is invoked.) This yields a contradiction. ■</p>

<p>Consequently, $V$ is not a set. Therefore, whilst $V$ is a model of ZFC in the sense that it contains all sets, <a href="https://math.stackexchange.com/questions/56726/how-can-there-be-genuine-models-of-set-theory">many mathematicians require models to be sets</a>, so it is not a model in the strict sense. (This explains why our proof that $V$ is a ‘model’ of ZFC does not contradict Gödel’s incompleteness theorems; within ZFC, $V$ is not recognised as a valid set-theoretic object.) However, for convenience, in this article, we shall refer to $V$ as a model of set theory. Moreover, we shall understand $x \in V$ as a formal expression for “$x$ is a set”.</p>

<h3 id="12-gödel-constructible-universe">1.2. Gödel Constructible Universe</h3>

<p>First, we define <a href="https://dimenerno.github.io/2025/05/13/saturation">constructibility</a> as follows:</p>

<blockquote>
  <p><strong>Definition.</strong> Let $\mathfrak{A}$ be an $\mathcal{L}$-structure and let $A$ be the underlying domain of $\mathfrak{A}$. $u$ is <strong>constructible</strong> from $\mathfrak{A}$ if there exist some $\mathcal{L}$-formula $\phi(y, x_1, \dots, x_n)$ and $a_1, \dots, a_n \in A$ such that the following holds:</p>

\[y \in u \iff y \in A \land \mathfrak{A} \vDash \phi(y, a_1, \dots, a_n)\]
</blockquote>

<p>Sometimes we abuse the notation and say that $u$ is constructible from $A$.</p>

<p>For example, with respect to the standard model of arithmetics, the following constructs $u = \lbrace  1, 2 \rbrace$:</p>

<ul>
  <li>$\phi(y, x_1, x_2) : (y = x_1) \lor (y = x_2)$</li>
  <li>$a_1 = 1, a_2 = 2$</li>
</ul>

<p>The following constructs $u = \lbrace 2, 5, 10, 17, \dots \rbrace$:</p>

<ul>
  <li>$\phi(y, x_1) : \exists z (z \cdot z + x_1 = y)$</li>
  <li>$a_1 = 1$</li>
</ul>

<p>Gödel’s constructibility differs from constructibility in the general sense, namely expressibility in language. For instance, since the set of real numbers expressible in language is countable, some real numbers cannot be expressed in language. Let such a real number be $r$. With respect to the standard model of real numbers, the following “constructs” $u = \lbrace  r \rbrace$:</p>

<ul>
  <li>$\phi(y, x_1) : x_1 = y$</li>
  <li>$a_1 = r$</li>
</ul>

<p>That is, Gödel’s constructibility is more versatile than linguistic constructibility in that it allows initialisation of free variables to arbitrary elements. Nonetheless, it is constrained to have only finite number of free variables.</p>

<p>We now define $\lbrace  L_\alpha \rbrace$ using transfinite recursion:</p>

<ul>
  <li>$L_0 = \varnothing$</li>
  <li>$L_{\alpha + 1} = \lbrace  x : x \text{ is constructible from } L_\alpha  \rbrace$</li>
  <li>When $\lambda$ is a limit ordinal, $L_\lambda = \bigcup_{\alpha &lt; \lambda} L_\alpha$</li>
  <li>$L = \bigcup_{\alpha &lt; \lambda} L_\alpha$</li>
</ul>

<p>We can easily show that $L_\alpha = V_\alpha$ when $\alpha &lt; \omega$. Specifically, when $\alpha = n$, we can construct $x \in V_\alpha$ with at most $n$ disjunctions. Therefore:</p>

<ul>
  <li>$L_1 = \lbrace  \varnothing \rbrace$</li>
  <li>$L_2 = \lbrace  \varnothing, \lbrace  \varnothing \rbrace \rbrace$</li>
  <li>$L_3 = \lbrace  \varnothing, \lbrace  \varnothing \rbrace, \lbrace  \lbrace  \varnothing \rbrace \rbrace, \lbrace  \varnothing, \lbrace  \lbrace  \varnothing\rbrace \rbrace  \rbrace$</li>
  <li>$L_\omega = \mathsf{HF}$</li>
</ul>

<p>However, $L_{\omega + 1} \subsetneq V_{\omega + 1}$. This is because although $\mathcal{P}(\mathbb{N}) \subset V_{\omega + 1}$ is uncountable, since the set of first-order logical sentences and $L_\omega$ are both countable, $L_{\omega + 1}$ is countable. In general, when $\alpha$ is countable, $L_\alpha$ is countable.</p>

<p>Nevertheless, $L$ shares many properties with $V$. For instance:</p>

<blockquote>
  <p><strong>Theorem.</strong> For $\alpha \in \mathrm{Ord}$, the following hold:</p>

  <ol>
    <li>$L_\alpha$ is transitive. (Therefore $L$ is transitive)</li>
    <li>$\alpha \in L_{\alpha + 1} \setminus L_{\alpha}$</li>
  </ol>
</blockquote>

<p><strong>Proof.</strong> By transfinite induction.</p>

<p>Note that $L$ is not a set since it contains all ordinals. However, there exists a first-order formula $\mathsf{IsInL}_\alpha(x)$ that expresses $x \in L_\alpha$. The proof is intricate and involves arithmetising propositions using Gödel numbers. (<a href="https://math.stackexchange.com/questions/198437/a-formula-that-defines-constructible-universe">See link</a>) At any rate, this means that we may understand $x \in L$ as a formal expression expressing $\exists \alpha \in \mathrm{Ord} :\mathsf{IsInL}_\alpha(x)$. The two will be co-extensional for models of ZF.</p>

<h2 id="2-relativisation">2. Relativisation</h2>

<h3 id="21-relativisation-of-formulas">2.1. Relativisation of Formulas</h3>

<blockquote>
  <p><strong>Definition.</strong> Let $T$ be an $\mathcal{L}$-theory and $\psi$ an $\mathcal{L}$-formula. We define the <strong>relativisation</strong> $\phi^\psi$, read as the relativisaion of $\phi$ respect to $\psi$, as the formula where all quantifiers in $\phi$ are restricted to satisfy $\psi$.</p>
</blockquote>

<p>Using $\mathsf{PA}$ as an example, if $\psi(x) : \exists z(z + z = x)$ and $\phi(x) : \exists z(z \cdot z = x)$, then:</p>

\[\phi^\psi(x) : \exists z (\psi(z) \land z \cdot z = x)\]

<p>Semantically, $\phi(x)$ expresses “$x$ is a perfect square” while $\phi^\psi(x)$ expresses “$x$ is a square of an even number”.</p>

<p>When it is clear that what $\psi(x)$ is supposed to express is $x \in S$, then we abuse the notation and write $\phi^S$ instead of $\phi^\psi$. Hence in the case of the previous example, we may write $\phi^E$ instead, where $E$ is the set of even numbers. That is,</p>

\[\phi^E(x) : \exists z \in E (z \cdot z = x)\]

<p>To use a bit of metaphoric expression, $\phi^S$ is how $\phi$ is “seen from” $S$.</p>

<p>For example, let $o(x)$ be the first-order formula expressing “$x$ is an ordinal”. Specifically, it is defined as:</p>

\[o(x) : \mathrm{tr}(x) \land \forall y \in x \; \mathrm{tr}(y)\]

<p>where $\mathrm{tr}(x) : \forall y \in x \; \forall z \in y (z \in x)$ expresses “$x$ is transitive”. By the abuse of notation, we may write $\phi^{\mathrm{Ord}}$ instead of $\phi^o$. $\phi^{\mathrm{Ord}}$ is how $\phi$ is “seen from” the class of all ordinals. Define:</p>

<ul>
  <li>$\phi_1 : \forall x \exists y \forall z (z \subset x \rightarrow z \in y)$</li>
  <li>$\phi_2 : \forall x \forall y \exists z (z = x \cup y)$</li>
</ul>

<p>That is, $\phi_1$ expresses closure under power set operation and $\phi_2$ expresses closure under set union. We have:</p>

<ul>
  <li>$\mathsf{ZFC} \not\vdash \phi_1^\mathrm{Ord}$</li>
  <li>$\mathsf{ZFC} \vdash \phi_2^\mathrm{Ord}$,</li>
</ul>

<p>since the set of ordinals is closed under union but not under power set. Put in another way, $\phi_1$ successfully distinguishes the class of all sets — what ZFC tries to describe — and the class of ordinals, while $\phi_2$ cannot. Generalising this observation, for a theory $T$ and a set $A$, the more formulas $\phi$ such that $T \vdash \phi \leftrightarrow \phi^A$, the better $A$ “conforms” to the description of $T$.</p>

<p>This leads us to the following definition.</p>

<blockquote>
  <p><strong>Definition.</strong> For an $\mathcal{L}$-theory $T$ and a set $A$, $\phi$ is said to be <strong>absolute</strong> with respect to $A$ if for every $\mathcal{L}$-formula $\phi$,</p>

\[T \vdash \forall x_1, \dots, x_n \in A (\phi(x_1, \dots, x_n) \leftrightarrow \phi^A(x_1, \dots, x_n))\]
</blockquote>

<p>Note that the definition simply becomes $T \vdash \phi^A$ when $\phi$ has no free variables, and it is given that $T \vdash \phi$.</p>

<h3 id="22-l-relativisation">2.2. $L$-Relativisation</h3>

<p>Our goal now is to show that the axioms of ZF are absoulte with respect to $L$. That is:</p>

<blockquote>
  <p><strong>Theorem 1.</strong> If $\phi$ is an axiom of ZF, then $\mathsf{ZF} \vdash \phi^L$.</p>
</blockquote>

<p>That is to say,</p>

<blockquote>
  <p>“When <em>seen from</em> $L$, $L$ is a model of ZF” can be proved in ZF.</p>
</blockquote>

<p>Of course, we only know that $L \subset V$ and do not know whether $V = L$, which leaves open the possibility of some set $x$ not belonging to $L$. Yet according to Theorem 1 states is that, even if there exists such a set $x$, its abscence does not break the <em>internal consistency</em> of $L$.</p>

<p>For example, suppose some set $x = \lbrace  y, z \rbrace$ is absent from $L$. At first glance, the absence of $x$ seems to suggest that $L$ does not satisfy the pairing axiom $\mathsf{Pair}$:</p>

\[\mathsf{Pair} := \forall y, z \; \exists x \; \forall w: w \in x \leftrightarrow (w = y \lor w = z)\]

<p>However, the pairing axiom as viewed from inside $L$ is:</p>

\[\mathsf{Pair}^L := \forall y, z \in L \; \exists x \in L \; \forall w \in L: w \in x \leftrightarrow (w = y \lor w = z)\]

<p>Note that the quantification $\forall y, z$ is also restricted to $L$. That is, the absence of $x = \lbrace  y, z \rbrace$ causes problems in $L$ <em>only when</em> $y, z \in L$. Conversely, if $x = \lbrace  y, z \rbrace \notin L$ implies $y, z \notin L$, then $L$ satisfies $\mathsf{Pair}^L$. This is, $L$ lacks sets only in a way that maintains internal consistency.</p>

<p>Although we do not give the full proof, we highlight that the key reason Theorem 1 holds is that $L$, like $V$, is a transitivie class of sets, which leads to the following lemma.</p>

<blockquote>
  <p><strong>Lemma.</strong> The following predicates are absolute with respect to $L$ in ZF:</p>

  <ol>
    <li>$x \in y$</li>
    <li>$x \subset y$</li>
    <li>$x = \bigcup y$</li>
    <li>$x = \lbrace  y, z \rbrace$</li>
    <li>$\alpha \in \mathrm{Ord}$</li>
    <li>$x$ is transitive</li>
    <li><a href="https://math.stackexchange.com/questions/404699/delta-0-formulas">$\Delta_0$ formulas</a></li>
  </ol>
</blockquote>

<p>From this lemma, it is not too difficult to prove Theorem 1. Moreover, we can prove:</p>

<blockquote>
  <p><strong>Theorem 2.</strong> $\mathsf{ZF} \vdash (V = L)^L$</p>
</blockquote>

<p>Here, $V = L$ is a formal expression standing for $\forall x (x \in L)$. At first glance it may seem that $(V = L)^L$ is thus the trivial proposition $\forall x \in L (x \in L)$. However, when we actually expand $V = L$ as a first-order formula, we have:</p>

\[\forall x \; \exists \alpha  \; (\alpha \in \mathrm{Ord} \land x \in L_\alpha)\]

<p>so $(V = L)^L$ becomes:</p>

\[\forall x \in L \; \exists \alpha \in L \; (\alpha \in \mathrm{Ord})^L \land (x \in L_\alpha)^L\]

<p>Note particularly that since $\alpha \in \mathrm{Ord}$ and $x \in L_\alpha$ are formal expressions of first-order formulas rather than a genuine $\in$-relation, they must likewise be relativised to $L$. Thus, to prove $(V = L)^L$ in ZF, <em>we must prove that $\alpha \in \mathrm{Ord}$ and $x \in L_\alpha$ are also absolute</em>. The former follows from the previous lemma, and the latter also “almost” follows from the lemma, except that $x \in L_\alpha$ is a $\Sigma_1$-sentence, so slightly more argument is required to secure its absoluteness.</p>

<p>From Theorems 1 and 2, we can prove:</p>

<blockquote>
  <p><strong>Theorem 3.</strong> $\mathsf{ZFL} \vdash \phi \implies \mathsf{ZF} \vdash \phi^L$</p>
</blockquote>

<p><strong>Proof.</strong> We prove by induction on the proof length of $\mathsf{ZFL} \vdash \phi$. When the proof length is 0, $\phi$ is an axiom of ZFL. When $\phi$ is an axiom of ZF, it follows from Theorem 1, and when $\phi$ is $V = L$, it follows from Theorem 2.</p>

<p>Now assume $\phi$ is proved by applying an inference rule to $\lbrace  \psi_1, \dots, \psi_n \rbrace$. The proof length of $\psi_k$ is smaller than that of $\phi$, so by the induction hypothesis $\mathsf{ZF} \vdash \psi_k^L$. We can easily show that logical axioms and inference rules are absolute with respect to $L$. Using modus ponens as an example, this means that:</p>

\[\mathsf{ZF} \vdash ((\phi \land \phi \rightarrow \psi) \rightarrow \psi)^L\]

<p>Therefore, if $(\psi_1 \land \dots \land \psi_n) \rightarrow \phi$ is logically valid, then $(\psi_1^L \land \dots \land \psi_n^L) → \phi^L$ is also logically valid, and consequently $\mathsf{ZF} \vdash \phi^L$. ■</p>

<p>As a corollary of Theorem 3, we obtain Theorem 4:</p>

<blockquote>
  <p><strong>Theorem 4.</strong> If ZF is consistent, then ZFL is also consistent.</p>
</blockquote>

<p><strong>Proof.</strong> If ZFL is inconsistent, then $\mathsf{ZFL} \vdash \varnothing \neq \varnothing$, and by Theorem 3, $\mathsf{ZF} \vdash (\varnothing \neq \varnothing)^L \iff \mathsf{ZF} \vdash \varnothing \neq \varnothing$, which contradicts the consistency of ZF. ■</p>

<p>Therefore, <strong>V = L is consistent with ZF</strong>.</p>

  </div>
  <div style="margin-bottom: 6em"></div>
  
    <div class="post fade-in-section" data-lang="ko" style="display: none">
      <h1 class="post-title">
        <a href="/2024/12/05/transfinite-recursion"> 초한귀납과 초한재귀 </a>
      </h1>
    <span class="post-date">05 Dec 2024</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/수학/'">
        수학
      </div>
      
      <div class="tag" onclick="location.href='/tags/집합론/'">
        집합론
      </div>
      
    </div>
     <h3 id="1-초한귀납법">1. 초한귀납법</h3>

<blockquote>
  <p><strong>정리.</strong> $P$가 서수 위에서 정의된 속성이고 임의의 $\alpha \in \mathrm{Ord}$에 대해</p>

\[[ \forall \beta &lt; \alpha : P(\beta)] → P(\alpha)\]

  <p>가 성립할 때, $P$는 모든 서수에 대해 참이다.</p>
</blockquote>

<p><em>Remark.</em> $P$의 정의역인 $\mathrm{Ord}$는 집합이 아닌 진모임<sub>proper class</sub>이므로 “술어” 대신 “속성”이란 표현을 사용한다.</p>

<p><strong>증명.</strong> 서수가 정렬 순서라는 사실과 귀류법을 사용한다.</p>

<p>$\lnot P(\lambda)$인 $\lambda$가 존재한다고 하자. $\Omega = \lbrace  \alpha \in \lambda : \lnot P(\alpha) \rbrace$는 공집합이 아닌 정렬 집합이므로 최소 원소 $\alpha_0$가 존재한다. 이때 $\forall \beta &lt; \alpha_0 : P(\beta)$이므로 가정에 의해 $P(\alpha_0)$가 되어 모순이다. ■</p>

<p><strong>응용.</strong> 폰 노인만 계층에서 $V_\alpha$는 추이적이다. 따라서 $V_{\alpha + 1} = V_\alpha \cup \mathcal{P}(V_\alpha)$ 대신 $V_{\alpha + 1} = \mathcal{P}(V_\alpha)$로 정의할 수 있다.</p>

<h3 id="2-초한재귀적-정의">2. 초한재귀적 정의</h3>

<p><em>Motivation.</em> 자연수의 재귀적 정의를 생각해 보자. $n$개의 집합 $x_1, \dots , x_n$이 주어졌을 때 집합을 출력하는 함수 $g$가 존재한다면 다음과 같이 $f: \mathbb{N} → V$을 정의할 수 있을 것이다.</p>

\[f(n) = g(f(0), \dots, f(n - 1))\]

<p>문제는 $g$가 고정된 수의 매개변수만을 가질 수 있다는 것이다. 따라서 다음과 같이 $g$의 매개변수를 순서쌍으로 묶는다.</p>

\[f(n) = g(\langle f(0), \dots, f(n - 1) \rangle)\]

<p>이 순서쌍은 $\lbrace  (0, f(0)), \dots, (n - 1, f(n - 1)) \rbrace = f \upharpoonright n$과 같이 표현할 수 있다. 즉,</p>

\[f(n) = g(f \upharpoonright n).\]

<p>이를 서수에 대해서 일반화하면 다음과 같다.</p>

<blockquote>
  <p><strong>정리.</strong> $G: V → V$가 모임함수(class function)이라고 하자. 다음을 만족하는 모임함수 $F: \mathrm{Ord} → V$가 존재한다.</p>

\[F(\alpha) = G(F \upharpoonright \alpha)\]
</blockquote>

<p><strong>증명.</strong> 초한귀납법을 겁나게 쓰면 된다. (불친절해서 ㅈㅅ)</p>

  </div>
  <div style="margin-bottom: 6em"></div>
  
</div>

<div class="pagination">
  
  <a
    class="pagination-item older lang-ko"
    href="/page11"
    >이전 글</a
  >
  <a
  class="pagination-item older lang-en"
  href="/page11"
  >Previous</a
>
    
  <a
    class="pagination-item newer lang-ko"
    href="/page9"
    >다음 글</a
  >
  <a
  class="pagination-item newer lang-en"
  href="/page9"
  >Next</a
>
   
</div>

<script>
  const faders = document.querySelectorAll(".fade-in-section");

  const appearOptions = {
    // threshold: 0.05,
    // rootMargin: "0px 0px 50px 0px",
  };

  const appearOnScroll = new IntersectionObserver((entries, observer) => {
    entries.forEach((entry) => {
      if (entry.isIntersecting) {
        entry.target.classList.add("is-visible");
        observer.unobserve(entry.target);
      }
    });
  }, appearOptions);

  faders.forEach((fader) => {
    appearOnScroll.observe(fader);
  });

  // 배너 이미지 로드 후 애니메이션 트리거 스크립트
  document.addEventListener("DOMContentLoaded", () => {

    const lang = localStorage.getItem("lang") || "ko";
  document.querySelectorAll('.post[data-lang]').forEach(post => {
    if (post.dataset.lang === lang) {
      post.style.display = '';
    }
  });

    const bannerImages = document.querySelectorAll(
      '.fade-rise-1[src="/public/banner.png"], .fade-rise-2[src="/public/banner-2.png"]'
    ); // 애니메이션 시작을 기다릴 이미지들
    const elementsToAnimate = document.querySelectorAll(
      ".fade-rise-1, .fade-rise-2, .fade-rise-3"
    ); // 애니메이션 될 요소들
    let loadedImagesCount = 0;
    const totalImagesToWait = bannerImages.length;

    // 기다릴 이미지가 없으면 즉시 애니메이션 시작
    if (totalImagesToWait === 0) {
      elementsToAnimate.forEach((el) => el.classList.add("is-loaded"));
      return;
    }

    const checkAllImagesLoaded = () => {
      if (loadedImagesCount === totalImagesToWait) {
        // 모든 이미지가 로드되면 애니메이션 클래스 추가
        elementsToAnimate.forEach((el) => el.classList.add("is-loaded"));
      }
    };

    bannerImages.forEach((img) => {
      // 이미지가 캐시되어 이미 로드 완료된 경우
      if (img.complete) {
        loadedImagesCount++;
      } else {
        // 이미지 로드 완료 이벤트 리스너 추가
        img.addEventListener("load", () => {
          loadedImagesCount++;
          checkAllImagesLoaded(); // 이미지 로드될 때마다 체크
        });
        // 에러 발생 시 처리 (선택 사항)
        img.addEventListener("error", () => {
          console.error("Failed to load image:", img.src);
          // 에러 발생 시에도 애니메이션을 시작하려면 여기서 loadedImagesCount를 증가시키거나 다른 로직 추가
          // 현재 로직에서는 에러 시 카운트가 증가하지 않아 모든 이미지 로드되지 않으면 애니메이션 안 시작
          loadedImagesCount++; // 에러 발생 시에도 카운트 증가 (모든 이미지를 처리했음을 알림)
          checkAllImagesLoaded();
        });
      }
    });

    // 모든 이미지에 대해 complete 상태를 확인하거나 리스너를 설정한 후,
    // 이미 모든 이미지가 로드 완료 상태였을 경우를 대비해 마지막으로 체크
    checkAllImagesLoaded();


    // Listen for language toggle changes and update post visibility dynamically
    const langToggle = document.getElementById("lang-toggle");
    if (langToggle) {
      langToggle.addEventListener("change", () => {
        const newLang = langToggle.checked ? "en" : "ko";
        localStorage.setItem("lang", newLang);
        document.querySelectorAll('.post[data-lang]').forEach(post => {
          post.style.display = post.dataset.lang === newLang ? '' : 'none';
        });
      });
    }
  });
</script>
</div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script src="/public/js/script.js"></script>
    <script src="/public/js/lang.js"></script>
  </body>
</html>
