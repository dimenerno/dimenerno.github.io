<!DOCTYPE html>
<html lang="en-us">
  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile" />
  <link href="https://fonts.googleapis.com/css2?family=Libre+Baskerville&display=swap" rel="stylesheet">
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />

  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=1"
  />

  <title>
     디멘의 블로그 &middot; 이데아를 여행하는 히치하이커
    
  </title>

  <style>
    .answer {
      display: none;
      margin-top: 10px;
      color: #333;
    }
  </style>

<style>
  .lang-toggle-wrapper {
    display: flex;
    align-items: center;
    gap: 0.4em;
    margin-right: 0.5em;
  }

  .lang-label {
    font-size: 0.9em;
    line-height: 1;
  }

  .switch {
    position: relative;
    display: inline-block;
    width: 44px;
    height: 24px;
  }

  .switch input {
    opacity: 0;
    width: 0;
    height: 0;
  }

  .slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #e7e8eb;
    transition: 0.4s;
    border-radius: 24px;
  }

  .slider::before {
    position: absolute;
    content: "";
    height: 18px;
    width: 18px;
    left: 3px;
    bottom: 3px;
    background-color: white;
    transition: 0.4s;
    border-radius: 50%;
  }

  .switch input:checked + .slider {
    background-color: #2e2e2e;
  }

  .switch input:checked + .slider::before {
    transform: translateX(20px);
  }

  .lang-ko, .lang-en {
  transition: opacity 0.3s ease;
}
</style>

  <script>
    function toggleAnswer(id) {
      const answer = document.getElementById("answer" + id);
      if (answer.style.display === "none" || answer.style.display === "") {
        answer.style.display = "block";
      } else {
        answer.style.display = "none";
      }
    }
  </script>

  <script>
    MathJax = {
      tex: {
        inlineMath: [
          ["$", "$"],
          ["\\(", "\\)"],
        ],
      },
      svg: {
        fontCache: "global",
      },
    };
  </script>
  <script
    type="text/javascript"
    id="MathJax-script"
    async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
  ></script>

  
  <link rel="canonical" href="/page10/" />
  

  <link rel="stylesheet" href="/public/css/poole.css" />
  <link rel="stylesheet" href="/public/css/syntax.css" />
  <link rel="stylesheet" href="/public/css/lanyon.css" />
  <link
    rel="stylesheet"
    href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400"
  />


  <link
    rel="apple-touch-icon-precomposed"
    sizes="144x144"
    href="/public/apple-touch-icon.png"
  />
  <link rel="shortcut icon" href="/public/favicon.ico" />
  <link
    rel="alternate"
    type="application/rss+xml"
    title="RSS"
    href=""
  />

  <script
    async
    src="https://www.googletagmanager.com/gtag/js?id=G-PVGYLWF7GR"
  ></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
      dataLayer.push(arguments);
    }
    gtag("js", new Date());

    gtag("config", "G-PVGYLWF7GR");
  </script>
</head>


  <style>
    /* 검색 입력창 */
    #search-input {
      padding: 6px 12px;
      font-size: 15px;
      border: 1px solid #eee;
      border-radius: 20px;
      outline: none;
      transition: all 0.2s ease-in-out;
      width: 90%;
      max-width: 240px;
      background-color: #fefefe;
    }

    #search-input::placeholder {
      color: var(--slate);
    }

    /* 입력창 포커스 시 */
    #search-input:focus {
      border-color: #9ea0a3;
      background-color: white;
    }

    @media (max-width: 600px) {
      .lang-label {
        display: none;
      }
    }
  </style>

  <body>
    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox" />

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p class="lang-ko">이데아를 여행하는 히치하이커</p>
    <p class="lang-en" style="display: none;">Alice in Logicland</p>
  </div>

  <nav class="sidebar-nav">
    <a
    class="sidebar-nav-item lang-ko"
    href="/"
    >메인</a>
    <a
    class="sidebar-nav-item lang-en"
    href="/"
    >Main</a
  >
       
    <a
      class="sidebar-nav-item lang-ko"
      href="/about/"
      >저에 대하여</a
    >
    <a
    class="sidebar-nav-item lang-en"
    href="/about/"
    >About Me</a
  >
        
    <a
      class="sidebar-nav-item lang-ko"
      href="/archive-date/"
      >날짜별로 보기</a
    >
    <a
    class="sidebar-nav-item lang-en"
    href="/archive-date/"
    >List by dates</a
  >
        
    <a
      class="sidebar-nav-item lang-ko"
      href="/archive-tag/"
      >주제별로 보기</a
    >
    <a
    class="sidebar-nav-item lang-en"
    href="/archive-tag/"
    >List by topics</a
  >
        
    <a
      class="sidebar-nav-item lang-ko"
      href="/random/"
      >랜덤 포스트</a
    >
    <a
    class="sidebar-nav-item lang-en"
    href="/random/"
    >Go to a random post</a
  >
        
    <a
      class="sidebar-nav-item lang-ko"
      href="/book/"
      >새벽의 자연학 수업</a
    >
    <a
    class="sidebar-nav-item lang-en"
    href="/book/"
    >Twilight Wonders (Korean)</a
  >
        
    <a
      class="sidebar-nav-item lang-ko"
      href="/notes/"
      >복습노트 아카이브</a
    >
    <a
    class="sidebar-nav-item lang-en"
    href="/notes/"
    >Maths Review Notes (Korean)</a
  >
        
    <a
      class="sidebar-nav-item lang-ko"
      href="/guestbook/"
      >방명록</a
    >
    <a
    class="sidebar-nav-item lang-en"
    href="/guestbook/"
    >Guestbook</a
  >
          
  </nav>

  <div class="sidebar-item">
    <p>&copy; 2025. All rights reserved.</p>
    <p style="color: #202020">
      &copy; 2025. 디멘 reserved by 곰댕.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead" style="width: 100%">
        <div
          class="container"
          style="
            display: flex;
            justify-content: space-evenly;
            align-items: center;
            padding: 0px;
            margin-left: 4em;
            margin-right: 0;
            max-width: none;
            overflow-y: hidden;
          "
        >
          <h3
            class="masthead-title"
            style="
              display: flex;
              flex-direction: row;
              gap: 0.3em;
              align-items: end;
              line-height: 1;
            "
          >
            <a
              href="/"
              style="white-space: nowrap"
              class="lang-ko"
              title="Home"
              >디멘의 블로그</a>
            <a
              href="/"
              style="white-space: nowrap"
              class="lang-en"
              title="Home"
            >Dimen's Blog</a>
            <small><div class="lang-ko">이데아를 여행하는 히치하이커</div>
              <div class="lang-en">Alice in Logicland</div></small>

          </h3>
          <form
            id="search-form"
            action="/search.html"
            method="get"
            style="display: flex; justify-content: end; padding-right: 1em"
          >
            <input
              type="text"
              name="q"
              id="search-input"
              placeholder="검색"
            />
          </form>

          <div class="lang-toggle-wrapper">
            <span class="lang-label">한</span>
            <label class="switch">
              <input type="checkbox" id="lang-toggle" />
              <span class="slider round"></span>
            </label>
            <span class="lang-label">EN</span>
          </div>
        </div>
      </div>

      <div class="container content"><head>
  <style>
    .fade-rise-1 {
      opacity: 0;
      transform: translateY(20px);
      /* animation: fadeRise 0.8s ease-out forwards;
      animation-delay: 0.2s; */
    }

    .fade-rise-2 {
      opacity: 0;
      transform: translateY(20px);
      /* animation: fadeRise 0.8s ease-out forwards;
      animation-delay: 0.4s; */
    }

    .fade-rise-3 {
      opacity: 0;
      transform: translateY(20px);
      /* animation: fadeRise 0.8s ease-out forwards;
      animation-delay: 0.6s; */
    }

    /* 이미지가 로드된 후 추가될 클래스에 animation 속성 추가 */
    .fade-rise-1.is-loaded {
      animation: fadeRise 0.8s ease-out forwards 0.2s;
    }
    .fade-rise-2.is-loaded {
      animation: fadeRise 0.8s ease-out forwards 0.4s;
    }
    .fade-rise-3.is-loaded {
      animation: fadeRise 0.8s ease-out forwards 0.6s;
    }

    @keyframes fadeRise {
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .fade-in-section {
      opacity: 0;
      transform: translateY(10px);
      transition: opacity 0.5s ease-out, transform 0.5s ease-out;
    }

    .fade-in-section.is-visible {
      opacity: 1;
      transform: none;
    }

    .spacer {
      height: 100vh;
    }
  </style>
</head>



<div class="posts">
  
    <div class="post fade-in-section" data-lang="en" style="display: none">
      <h1 class="post-title">
        <a href="/2025/02/13/three-definitions-of-adjoint/en"> Three Approaches to Adjoints </a>
      </h1>
    <span class="post-date">13 Feb 2025</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/mathematics/'">
        Mathematics
      </div>
      
      <div class="tag" onclick="location.href='/tags/category-theory/'">
        Category Theory
      </div>
      
    </div>
     <blockquote>
  <p>This post was machine translated and has not yet been proofread. It may contain minor errors or unnatural expressions. Proofreading will be done in the near future.</p>
</blockquote>

<blockquote>
  <p>The content of this text is based on Tom Leinster, <em>Basic Category Theory</em>.</p>
</blockquote>

<p>Let $\mathcal{A}, \mathcal{B}$ be categories and $F: \mathcal{A} \to \mathcal{B}, G: \mathcal{B} \to \mathcal{A}$ be functors.</p>

<h2 id="1-definition-of-adjoint-using-the-naturality-axiom">1. Definition of Adjoint Using the Naturality Axiom</h2>

<p>$F \dashv G$ means that for any $A \in \mathcal{A}, B \in \mathcal{B}$, there exists a bijection $\Psi_{A, B} : \mathrm{Hom}_\mathcal{A}(A, G(B)) \to \mathrm{Hom}_\mathcal{B}(F(A), B)$ such that for any $p: A’ \to A, q: B \to B’$, the following commutative diagram is satisfied.</p>

<!-- https://q.uiver.app/#q=WzAsNixbMCwwLCJcXG1hdGhybXtIb219KEEnLCBHKEIpKSJdLFswLDEsIlxcbWF0aHJte0hvbX0oQSwgRyhCKSkiXSxbMCwyLCJcXG1hdGhybXtIb219KEEsIEcoQicpKSJdLFsyLDAsIlxcbWF0aHJte0hvbX0oRihBJyksIEIpIl0sWzIsMSwiXFxtYXRocm17SG9tfShGKEEpLCBCKSJdLFsyLDIsIlxcbWF0aHJte0hvbX0oRihBKSwgQicpIl0sWzAsMywiXFxQc2lfe0EnLCBCfSJdLFsxLDQsIlxcUHNpX3tBLCBCfSJdLFsyLDUsIlxcUHNpX3tBLCBCJ30iXSxbMCwxLCIoLSlcXGNpcmMgcCIsMl0sWzEsMiwiRyhxKVxcY2lyYyAoLSkiLDJdLFszLDQsIigtKVxcY2lyYyBGKHApIl0sWzQsNSwicSBcXGNpcmMgKC0pIl1d -->
<iframe class="quiver-embed" src="https://q.uiver.app/#q=WzAsNixbMCwwLCJcXG1hdGhybXtIb219KEEnLCBHKEIpKSJdLFswLDEsIlxcbWF0aHJte0hvbX0oQSwgRyhCKSkiXSxbMCwyLCJcXG1hdGhybXtIb219KEEsIEcoQicpKSJdLFsyLDAsIlxcbWF0aHJte0hvbX0oRihBJyksIEIpIl0sWzIsMSwiXFxtYXRocm17SG9tfShGKEEpLCBCKSJdLFsyLDIsIlxcbWF0aHJte0hvbX0oRihBKSwgQicpIl0sWzAsMywiXFxQc2lfe0EnLCBCfSJdLFsxLDQsIlxcUHNpX3tBLCBCfSJdLFsyLDUsIlxcUHNpX3tBLCBCJ30iXSxbMCwxLCIoLSlcXGNpcmMgcCIsMl0sWzEsMiwiRyhxKVxcY2lyYyAoLSkiLDJdLFszLDQsIigtKVxcY2lyYyBGKHApIl0sWzQsNSwicSBcXGNpcmMgKC0pIl1d&amp;embed" width="100%" height="300px" style="border-radius: 8px; border: none;"></iframe>

<p>For convenience, we denote $\Psi_{A, B}(f) = \bar{f}$ for $f: A \to G(B)$, and $\Psi_{A, B}^{-1}(g) = \bar{g}$ for $g: F(A) \to B$. Accordingly, the above commutative diagram can be expressed as follows:</p>

\[\begin{gather}
\overline{A \xrightarrow{f} G(B) \xrightarrow{G(q)} G(B') } = F(A) \xrightarrow{\bar{f}} B \xrightarrow{q} B' \\
\overline{F(A') \xrightarrow{F(p)} F(A) \xrightarrow{g} B} = A' \xrightarrow{p} A \xrightarrow{\bar{g}} G(B) \\\\
\mathrm{i.e.}\\\\
\overline{G(q) \circ f} = q \circ \bar{f}\\
\overline{g \circ F(p)} = \bar{g} \circ p
\end{gather}\]

<p>The above two conditions are called the naturality axioms. From the naturality axioms, we can prove the following:</p>

<blockquote>
  <p><strong>Theorem 1.</strong> The transformation $\eta: 1_{\mathcal{A}} \to GF$ defined by $\eta_A := \overline{1_{F(A)}} : A \to GF(A)$ is a natural transformation. Moreover, the transformation $\epsilon: FG \to 1_{\mathcal{B}}$ defined by $\epsilon_B := \overline{1_{G(B)}} : FG(B) \to B$ is also a natural transformation. We call $\eta$ the <strong>unit</strong> and $\epsilon$ the <strong>counit</strong>.</p>
</blockquote>

<p><strong>Proof.</strong> This follows from the following commutative diagram.</p>

<!-- https://q.uiver.app/#q=WzAsNixbMCwwLCJcXG1hdGhybXtIb219KEEnLCBHRihBJykpIFxcbWlkX3tcXGV0YV97QSd9fSJdLFswLDEsIlxcbWF0aHJte0hvbX0oQSwgR0YoQScpKSBcXG1pZF97e1xcZXRhX3tBJ30gXFxjaXJjIGZ9LFxcOyB7R0YoZikgXFxjaXJjIFxcZXRhX0F9fSJdLFsyLDAsIlxcbWF0aHJte0hvbX0oRihBJyksIEYoQScpKSBcXG1pZF97MV97RihBJyl9fSJdLFsyLDEsIlxcbWF0aHJte0hvbX0oRihBKSwgRihBJykpIFxcbWlkX3tGKGYpfSJdLFswLDIsIlxcbWF0aHJte0hvbX0oQSwgR0YoQSkpIFxcbWlkX3tcXGV0YV9BfSJdLFsyLDIsIlxcbWF0aHJte0hvbX0oRihBKSwgRihBKSkgXFxtaWRfezFfe0YoQSl9fSJdLFswLDEsIigtKVxcY2lyYyBmIiwyXSxbMiwzLCIoLSlcXGNpcmMgRihmKSJdLFswLDIsIlxcb3ZlcmxpbmV7KC0pfSIsMCx7InN0eWxlIjp7InRhaWwiOnsibmFtZSI6ImFycm93aGVhZCJ9fX1dLFs0LDEsIkdGKGYpIFxcY2lyYyAoLSkiXSxbNSwzLCJGKGYpIFxcY2lyYyAoLSkiLDJdLFs0LDUsIlxcb3ZlcmxpbmV7KC0pfSIsMix7InN0eWxlIjp7InRhaWwiOnsibmFtZSI6ImFycm93aGVhZCJ9fX1dLFsxLDMsIlxcb3ZlcmxpbmV7KC0pfSIsMix7InN0eWxlIjp7InRhaWwiOnsibmFtZSI6ImFycm93aGVhZCJ9fX1dXQ== -->
<iframe class="quiver-embed" src="https://q.uiver.app/#q=WzAsNixbMCwwLCJcXG1hdGhybXtIb219KEEnLCBHRihBJykpIFxcbWlkX3tcXGV0YV97QSd9fSJdLFswLDEsIlxcbWF0aHJte0hvbX0oQSwgR0YoQScpKSBcXG1pZF97e1xcZXRhX3tBJ30gXFxjaXJjIGZ9LFxcOyB7R0YoZikgXFxjaXJjIFxcZXRhX0F9fSJdLFsyLDAsIlxcbWF0aHJte0hvbX0oRihBJyksIEYoQScpKSBcXG1pZF97MV97RihBJyl9fSJdLFsyLDEsIlxcbWF0aHJte0hvbX0oRihBKSwgRihBJykpIFxcbWlkX3tGKGYpfSJdLFswLDIsIlxcbWF0aHJte0hvbX0oQSwgR0YoQSkpIFxcbWlkX3tcXGV0YV9BfSJdLFsyLDIsIlxcbWF0aHJte0hvbX0oRihBKSwgRihBKSkgXFxtaWRfezFfe0YoQSl9fSJdLFswLDEsIigtKVxcY2lyYyBmIiwyXSxbMiwzLCIoLSlcXGNpcmMgRihmKSJdLFswLDIsIlxcb3ZlcmxpbmV7KC0pfSIsMCx7InN0eWxlIjp7InRhaWwiOnsibmFtZSI6ImFycm93aGVhZCJ9fX1dLFs0LDEsIkdGKGYpIFxcY2lyYyAoLSkiXSxbNSwzLCJGKGYpIFxcY2lyYyAoLSkiLDJdLFs0LDUsIlxcb3ZlcmxpbmV7KC0pfSIsMix7InN0eWxlIjp7InRhaWwiOnsibmFtZSI6ImFycm93aGVhZCJ9fX1dLFsxLDMsIlxcb3ZlcmxpbmV7KC0pfSIsMix7InN0eWxlIjp7InRhaWwiOnsibmFtZSI6ImFycm93aGVhZCJ9fX1dXQ==&amp;embed" width="100%" height="260" style="border-radius: 8px; border: none;"></iframe>

<blockquote>
  <p><strong>Theorem 2.</strong> For $f: A \to G(B), g: F(A) \to B$, the following holds:</p>

\[\begin{gather}
\bar{f} = \epsilon_B \circ F(f) \\
\bar{g} = G(g) \circ \eta_A
\end{gather}\]
</blockquote>

<p><strong>Proof.</strong> This follows from the following commutative diagram.</p>

<!-- https://q.uiver.app/#q=WzAsNixbMCwwLCJcXG1hdGhybXtIb219KEEsIEdGKEEpKSBcXG1pZF97XFxldGFfQX0iXSxbMCwxLCJcXG1hdGhybXtIb219KEEsIEcoQikpIFxcbWlkX3tHKGcpIFxcY2lyY1xcZXRhX0EgPVxcYmFye2d9fSJdLFsyLDAsIlxcbWF0aHJte0hvbX0oRihBKSwgRihBKSkgXFxtaWRfezFfe0YoQSl9fSJdLFsyLDEsIlxcbWF0aHJte0hvbX0oRihBKSwgQikgXFxtaWRfe2d9Il0sWzEsMCwiXFxvdmVyc2V0e1xcb3ZlcmxpbmV7KC0pfX17XFxsb25ncmlnaHRhcnJvd30iXSxbMSwxLCJcXG92ZXJzZXR7XFxvdmVybGluZXsoLSl9fXtcXGxvbmdyaWdodGFycm93fSJdLFswLDEsIkcoZykgXFxjaXJjICgtKSIsMl0sWzIsMywiZyBcXGNpcmMgKC0pIl1d -->
<iframe class="quiver-embed" src="https://q.uiver.app/#q=WzAsNixbMCwwLCJcXG1hdGhybXtIb219KEEsIEdGKEEpKSBcXG1pZF97XFxldGFfQX0iXSxbMCwxLCJcXG1hdGhybXtIb219KEEsIEcoQikpIFxcbWlkX3tHKGcpIFxcY2lyY1xcZXRhX0EgPVxcYmFye2d9fSJdLFsyLDAsIlxcbWF0aHJte0hvbX0oRihBKSwgRihBKSkgXFxtaWRfezFfe0YoQSl9fSJdLFsyLDEsIlxcbWF0aHJte0hvbX0oRihBKSwgQikgXFxtaWRfe2d9Il0sWzEsMCwiXFxvdmVyc2V0e1xcb3ZlcmxpbmV7KC0pfX17XFxsb25ncmlnaHRhcnJvd30iXSxbMSwxLCJcXG92ZXJzZXR7XFxvdmVybGluZXsoLSl9fXtcXGxvbmdyaWdodGFycm93fSJdLFswLDEsIkcoZykgXFxjaXJjICgtKSIsMl0sWzIsMywiZyBcXGNpcmMgKC0pIl1d&amp;embed" width="100%" height="200" style="border-radius: 8px; border: none;"></iframe>

<h2 id="2-definition-of-adjoint-using-unit-and-counit">2. Definition of Adjoint Using Unit and Counit</h2>

<p>$F \dashv G$ means that there exist natural transformations $\eta: 1_{\mathcal{A}} \to GF$ and $\epsilon: FG \to 1_{\mathcal{B}}$ such that for any $A \in \mathcal{A}, B \in \mathcal{B}$, the following commutative diagrams are always satisfied:</p>

<!-- https://q.uiver.app/#q=WzAsNixbMCwwLCJGKEEpIl0sWzEsMCwiXFw7RkdGKEEpIl0sWzEsMSwiRihBKSJdLFsyLDAsIkcoQikiXSxbMywwLCJcXDtHRkcoQikiXSxbMywxLCJHKEIpIl0sWzAsMSwiRihcXGV0YV9BKSJdLFsxLDIsIlxcZXBzaWxvbl97RihBKX0iXSxbMCwyLCIxX3tGKEEpfSIsMl0sWzMsNCwiXFxldGFfe0coQil9Il0sWzQsNSwiRyhcXGVwc2lsb25fQikiXSxbMyw1LCIxX3tHKEIpfSIsMl1d -->
<iframe class="quiver-embed" src="https://q.uiver.app/#q=WzAsNixbMCwwLCJGKEEpIl0sWzEsMCwiXFw7RkdGKEEpIl0sWzEsMSwiRihBKSJdLFsyLDAsIkcoQikiXSxbMywwLCJcXDtHRkcoQikiXSxbMywxLCJHKEIpIl0sWzAsMSwiRihcXGV0YV9BKSJdLFsxLDIsIlxcZXBzaWxvbl97RihBKX0iXSxbMCwyLCIxX3tGKEEpfSIsMl0sWzMsNCwiXFxldGFfe0coQil9Il0sWzQsNSwiRyhcXGVwc2lsb25fQikiXSxbMyw1LCIxX3tHKEIpfSIsMl1d&amp;embed" width="100%" height="220" style="border-radius: 8px; border: none;"></iframe>

<p>The above two conditions are called the triangle identities.</p>

<h2 id="3-definition-of-adjoint-using-initial-objects">3. Definition of Adjoint Using Initial Objects</h2>

<blockquote>
  <p><strong>Definition.</strong> When $P: \mathcal{A} \to \mathcal{C}$ and $Q: \mathcal{B} \to \mathcal{C}$ are functors, we define the <strong>comma category</strong> $(P \Rightarrow Q)$ as follows:</p>

  <ul>
    <li>Objects: For a morphism $h: P(A) \to Q(B)$ in $\mathcal{C}$, the triplet $(A, h, B)$</li>
    <li>Morphisms: When the following commutative diagram holds, $(f, g): (A, h, B) \to (A’, h’, B’)$</li>
  </ul>
</blockquote>

<iframe class="quiver-embed" src="https://q.uiver.app/#q=WzAsNCxbMCwwLCJQKEEpIl0sWzIsMCwiUChBJykiXSxbMCwxLCJRKEIpIl0sWzIsMSwiUShCJykiXSxbMCwyLCJoIiwyXSxbMSwzLCJoJyJdLFswLDEsIlAoZikiXSxbMiwzLCJRKGcpIiwyXV0=&amp;embed" width="100%" height="230" style="border-radius: 8px; border: none;"></iframe>

<p>$F \dashv G$ means that there exists a natural transformation $\eta: 1_{\mathcal{A}} \to GF$ such that for each $A \in \mathcal{A}$, when we regard $A$ as a functor $A: 1 \mapsto A$ from the singleton category $\mathbf{1}$ to $\mathcal{A}$, $\eta_A : A \to GF(A)$ is an initial object in the comma category $(A \Rightarrow G)$.</p>

<h2 id="4-proof-of-equivalence">4. Proof of Equivalence</h2>

<p>The definitions 1, 2, and 3 are all equivalent. Specifically, the following theorem holds:</p>

<blockquote>
  <p><strong>Theorem 3.</strong> Let $\mathcal{A}, \mathcal{B}$ be categories and $F: \mathcal{A} \to \mathcal{B}, G: \mathcal{B} \to \mathcal{A}$ be functors. Then 1, 2, and 3 are in one-to-one correspondence.</p>

  <ol>
    <li>A bijection $\Psi$ satisfying the naturality axioms</li>
    <li>A pair of natural transformations $(\eta: 1_{\mathcal{A}} \to GF, \epsilon: FG \to 1_{\mathcal{B}})$ satisfying the triangle identities</li>
    <li>A natural transformation $\eta: 1_{\mathcal{A}} \to GF$ such that for each $A \in \mathcal{A}$, $\eta_A : A \to GF(A)$ is an initial object in $(A \Rightarrow G)$</li>
  </ol>
</blockquote>

<p><strong>Proof.</strong> We show that 1 and 2 are in one-to-one correspondence, and that 2 and 3 are in one-to-one correspondence.</p>

<h4 id="1-and-2-are-in-one-to-one-correspondence">1 and 2 are in one-to-one correspondence.</h4>

<p>Given $\Psi$, we define $\eta$ and $\epsilon$ as the unit and counit respectively. That $\eta$ and $\epsilon$ satisfy the triangle identities follows easily from Theorem 2.</p>

<p>Conversely, suppose we are given a pair of natural transformations $(\eta, \epsilon)$ satisfying the triangle identities. From this, we define $\Psi$ as follows. For $f: A \to G(B), g: F(A) \to B$:</p>

\[\begin{gather}
\Psi_{A, B}(f) = \bar{f} = \epsilon_B \circ F(f) \\
\Psi_{A, B}^{-1} = \bar{g} = G(g) \circ \eta_A
\end{gather}\]

<p>First, we show that $\Psi_{A, B}^{-1}$ is indeed the inverse of $\Psi_{A, B}$, i.e., that $\bar{\bar{g}} = g, \bar{\bar{f}} = f$. The former follows from the following commutative diagram. The latter can be obtained by replacing $F, G$ with $G, F$ respectively in the diagram and then taking the appropriate dual.</p>

<!-- https://q.uiver.app/#q=WzAsNSxbMCwwLCJGKEEpIl0sWzEsMCwiRkdGKEEpIl0sWzEsMSwiRihBKSJdLFsyLDAsIkZHKEIpIl0sWzIsMSwiQiJdLFsxLDMsIkZHKGcpIl0sWzIsNCwiZyJdLFsxLDIsIlxcZXBzaWxvbl97RihBKX0iLDJdLFszLDQsIlxcZXBzaWxvbl9CIl0sWzAsMSwiRihcXGV0YV9BKSJdLFswLDIsIjEiLDIseyJjdXJ2ZSI6Mn1dXQ== -->
<iframe class="quiver-embed" src="https://q.uiver.app/#q=WzAsNSxbMCwwLCJGKEEpIl0sWzEsMCwiRkdGKEEpIl0sWzEsMSwiRihBKSJdLFsyLDAsIkZHKEIpIl0sWzIsMSwiQiJdLFsxLDMsIkZHKGcpIl0sWzIsNCwiZyJdLFsxLDIsIlxcZXBzaWxvbl97RihBKX0iLDJdLFszLDQsIlxcZXBzaWxvbl9CIl0sWzAsMSwiRihcXGV0YV9BKSJdLFswLDIsIjEiLDIseyJjdXJ2ZSI6Mn1dXQ==&amp;embed" width="100%" height="250" style="border-radius: 8px; border: none;"></iframe>

<p>Now we show that $\Psi$ satisfies the naturality axioms. We shall prove only one axiom. For $f: A \to G(B), q: B \to B’$, we show that $\overline{G(q) \circ f} = q \circ \bar{f}$. First,</p>

\[\overline{G(q) \circ f} = \epsilon_{B'} \circ FG(q) \circ F(f)\]

<p>and</p>

\[q \circ \bar{f} = q \circ \epsilon_B \circ F(f)\]

<p>Therefore, it suffices to show that $\epsilon_{B’} \circ FG(q) = q \circ \epsilon_B$. This is nothing other than the definition of a natural transformation. Hence $\Psi$ satisfies the naturality axioms.</p>

<h4 id="2-and-3-are-in-one-to-one-correspondence">2 and 3 are in one-to-one correspondence.</h4>

<p>Given a pair of natural transformations $(\eta, \epsilon)$ satisfying the triangle identities, let us show that for each $A \in \mathcal{A}$, $\eta_A : A \to GF(A)$ is an initial object in $(A \Rightarrow G)$.</p>

<p>Conversely, when $\eta$ is a natural transformation such that for each $A \in \mathcal{A}$, $\eta_A : A \to GF(A)$ is an initial object in $(A \Rightarrow G)$, let us show that there exists a unique $\epsilon: FG \to 1_{\mathcal{B}}$ such that $(\eta, \epsilon)$ satisfies the triangle identities.</p>


  </div>
  <div style="margin-bottom: 6em"></div>
  
    <div class="post fade-in-section" data-lang="ko" style="display: none">
      <h1 class="post-title">
        <a href="/2025/02/09/godel-lucas-penrose"> 정신은 기계로 환원될 수 있는가: 괴델의 조건문과 펜로즈-루카스 논증 </a>
      </h1>
    <span class="post-date">09 Feb 2025</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/수학/'">
        수학
      </div>
      
      <div class="tag" onclick="location.href='/tags/철학/'">
        철학
      </div>
      
      <div class="tag" onclick="location.href='/tags/논리학/'">
        논리학
      </div>
      
    </div>
     <p><img src="https://velog.velcdn.com/images/dimenerno/post/b71a00d7-efdf-4ec3-ad5c-cc32b67cf70c/image.jpeg" alt="" /></p>

<blockquote>
  <p>이 글은 <a href="/public/On the question of whether the mind can be mechanized 1.pdf">Peter Koellner, <em>On the question of whether the mind can be mechanized</em> (2018)</a>을 정리한 것이다.</p>
</blockquote>

<p><strong>초록.</strong> 처치-튜링 논제와 괴델의 불완전성 정리는 기계로 증명할 수 없는 수학적 참의 존재를 시사한다. 그러나 만약 이상적인 인간 정신은 모든 수학적 참을 증명할 수 있다면, 이상적인 인간 정신은 기계와 같지 않다는 결론이 얻어진다. 이 글에서는 이같은 방식으로 반기계주의를 입증하려는 루카스와 펜로즈의 논증을 검토하고, 이 논증을 반박하는 형식 증명을 소개한다.</p>

<h2 id="서론">서론</h2>

<p>다음은 논리학에서 잘 알려진 결과들이다.</p>

<ul>
  <li>
    <p><strong>처치-튜링 논제.</strong> 이상적인 기계에 의해 <strong>계산 가능하다<sub>computable</sub></strong>는 것은 튜링 기계로 구현 가능하다는 것이다.</p>
  </li>
  <li>
    <p><strong>괴델의 불완전성 정리.</strong> $F$가 특정 조건을 만족하는 형식 체계라면, 참이지만 $F$로 증명 불가능한 문장이 존재한다.</p>
  </li>
  <li>
    <p><strong>형식 체계-튜링 기계 대응.</strong> $F$가 특정 조건을 만족하는 형식 체계라면, $F$로 증명 가능한 명제들을 열거하는 튜링 기계가 존재한다.</p>
  </li>
</ul>

<p>위 세 가지 논제에 더해, 우리 인간은 형식 체계가 포착하지 못하는 수학적 참 — 이를테면 산술의 무모순성 — 또한 포착할 수 있는 것으로 보인다는 사실을 종합해 보면, 불완전성 정리는 이상적인 인간 정신이 도출할 수 있는 수학적 결과들의 외연이 이상적인 유한 기계로 도출할 수 있는 결과들의 외연을 초과함을 시사하는 것으로 보인다. 즉, 불완전성 정리는 정신이 기계로 환원될 수 없다는 반기계주의를 시사하는 것으로 보인다.</p>

<p>이 글에서는 과연 이 시사 관계가 얼마나 정당화될 수 있는지 검토한다. 그 결과, 불완전성 정리는 반기계주의 <em>또는</em> 플라톤주의를 시사하긴 하지만 반기계주의를 직접적으로 시사하지는 않음을 보일 것이다.</p>

<h2 id="1-괴델-조건문">1. 괴델 조건문</h2>

<p>괴델은 불완전성 정리로부터, 다음 두 입장 중 <em>적어도 하나가 참</em>이라는 결론이 따라 나온다고 주장했다. 이것을 <strong>괴델 조건문<sub>Gödel’s Disjunction</sub></strong>이라고 부르자.</p>

<ol>
  <li>
    <p><strong>반기계주의:</strong> 이상적인 인간 정신이 도출할 수 있는 수학적 결과들은 언제나 이상적인 유한 기계가 도출하는 수학적 결과들을 초과한다. 따라서 인간 정신은 기계로 환원될 수 없다.</p>
  </li>
  <li>
    <p><strong>플라톤주의:</strong> 이상적인 인간 정신이 포착할 수 없는 수학적 참이 존재한다. 따라서 수학적 참은 인간 정신과 독립적으로 존재한다.</p>
  </li>
</ol>

<p>두 입장 모두 유물론적 철학에 반한다는 점이 주목할 만하다. 괴델은 평소 철학적 논증에 유보적이었지만, 해당 논증에 관해서만큼은 “수학적으로 입증된 사실”이라고 강하게 주장했다. 우리의 첫 번째 과제는, 과연 이 논증이 “수학적으로 입증된 사실”인지를 검증하는 것이다.</p>

<h3 id="11-괴델의-세-가지-주장">1.1. 괴델의 세 가지 주장</h3>

<p>몇 가지 기호를 도입하자.</p>

<ol>
  <li>
    <p>$F$는 형식 체계 $F$가 증명할 수 있는 모든 문장들의 집합이다.</p>
  </li>
  <li>
    <p>$K$는 이상적인 인간 정신이 증명할 수 있는 모든 문장들의 집합이다.</p>
  </li>
  <li>
    <p>$T$는 참인 문장들의 집합이다.</p>
  </li>
</ol>

<p>이 글에 걸쳐 $K \subseteq T$를 가정할 것이다. 또한 $F$는 괴델의 불완전성 정리가 적용되는 형식 체계 — 즉, 페아노 산술(사실 이 조건은 로빈슨 산술로 약화시킬 수 있다)을 포함하는 무모순적인 체계 — 임을 전제한다.</p>

<p>본론에 들어가기 앞서 괴델의 불완전성 정리를 복습해 보자.</p>

<blockquote>
  <p><strong>괴델의 불완전성 정리.</strong> $F$가 산술을 포함하는 무모순적인 수학 체계일 때, 다음이 성립한다.</p>

  <ul>
    <li><strong>제1정리.</strong> 참이지만 $F$로 증명 불가능한 명제가 존재한다.</li>
    <li><strong>제2정리.</strong> $F$의 무모순성이 제1정리의 실례에 해당한다.</li>
  </ul>
</blockquote>

<p>첨언하자면 전통적으로 불완전성 정리가 대상으로 하는 산술은 페아노 산술이지만, 로빈슨 산술을 비롯한 더 약한 산술 체계에서도 불완전성 정리가 성립한다.</p>

<h4 id="111-첫-번째-주장">1.1.1. 첫 번째 주장</h4>

<p>괴델은 먼저 다음을 주장한다.</p>

<blockquote>
  <p><strong>주장 1.</strong> $F \subseteq T \implies F \subsetneq T$</p>
</blockquote>

<p>증명은 다음과 같다. $F \subseteq T$라면 $\mathrm{Con}(F) \in T$이다. 그런데 제2불완전성 정리에 의해 $\mathrm{Con}(F) \notin F$이다. 따라서 $F \subsetneq T$이다.</p>

<h4 id="112-두-번째-주장">1.1.2. 두 번째 주장</h4>

<p>괴델의 두 번째 주장은 다음과 같다.</p>

<blockquote>
  <p><strong>주장 2.</strong> $K(F \subseteq T) \implies F \subsetneq K$</p>
</blockquote>

<p>증명은 다음과 같다. $K(F \subseteq T)$라면 $\mathrm{Con}(F) \in K$이다. 하지만 앞서 보았듯이 $F \subseteq T \implies \mathrm{Con}(F) \notin F$이므로 $F \subsetneq K$이다.</p>

<p>그런데 만약 $F \subsetneq K$가 참이라면, 이것을 어떤 식으로 이해해야 할까? 한 가지 방식은 형식 체계의 위계를 생각하는 것이다.</p>

<p>괴델은 불완전성 정리가 시사하는 증명 불가능한 문장들이, <em>절대적으로</em> 증명 불가능할 필요는 없다고 강조한다. 형식 체계 $F$에서 증명 불가능한 문장이 $F$보다 고차적인 체계에서는 증명 가능해질 수 있기 때문이다. 예를 들어 $\mathsf{PA}$가 무모순적이라면 $\mathsf{PA}$는 $\mathrm{Con}(\mathsf{PA})$를 증명하지 못하지만, 2차 페아노 산술 $\mathsf{PA}_2$는 $\mathrm{Con}(\mathsf{PA})$를 증명할 수 있음이 알려져 있다. 물론 $\mathsf{PA}_2$는 $\mathrm{Con}(\mathsf{PA}_2)$를 증명하지는 못하지만, 이것은 3차 페아노 산술에서 증명 가능하며, 이런 식의 위계가 이어진다.</p>

<p>그리고 이 위계 전체는 $K$에 포섭되는 것으로 보인다. 이 관점으로 보았을 때 각각의 형식 체계는 집합과 같고, $K$는 모든 집합을 모은 것과 같다. 그리고 모든 집합의 모임이 집합일 수 없듯이, $K$는 형식 체계일 수 없다는 유비가 성립한다.</p>

<h4 id="113-세-번째-주장">1.1.3. 세 번째 주장</h4>

<p>그런데 이런 의문이 든다. ”주장 2“를 조건문으로 적는 대신, $K(F \subsetneq T)$가 참이라고 주장함으로써 $F \subsetneq K$를 주장할 수는 없을까?</p>

<p>괴델은 불완전성 정리만으로 그런 주장에 도착할 수는 없다고 지적한다. 왜냐하면 $K$와 일치하는 형식 체계 $F^\ast$의 존재 가능성을 완전히 배제할 수는 없기 때문이다 (앞선 고차 페아노 산술과 관련된 논의는 어디까지나 유비였음에 유의하라).</p>

<p>이에 대해 괴델은 다음과 같이 말한다.</p>

<blockquote>
  <p>[만약 그러한 형식 체계가 존재한다면] 인간 이성은 — 적어도 수학적인 측면에서는 — 유한한 기계와 동등하다. 그러나 그 기계는 자기 자신의 동작을 [스스로의 무모순성을 증명할 수 없다는 점에서] 완전히 이해할 수는 없다. 이 불능은 인간에게 있어 정신의 무한한 확장성으로 오인될 것이다.</p>
</blockquote>

<p>대신 괴델의 세 번째 주장은 다음과 같다. 이 주장이 괴델의 조건문이다.</p>

<blockquote>
  <p><strong>주장 3.</strong> $\forall F (F \subsetneq K) \;  \lor \; K \subsetneq T$</p>
</blockquote>

<p>증명은 다음과 같다. $F^\ast = K$인 형식 체계 $F^\ast$가 있다고 가정하자. $K \subset T$를 가정했으므로 $F^\ast \subset T$이며, 주장 1에 의해 $F^\ast \subsetneq T$이다.</p>

<p>전자는 반기계주의를, 후자는 플라톤주의를 의미한다.</p>

<h3 id="12-괴델-조건문의-형식화">1.2. 괴델 조건문의 형식화</h3>

<p>지금까지 우리는 괴델의 세 가지 주장을 제시하고, 그에 대한 간략한 증명을 소개했다. 하지만 이 증명들은 사실 정확하지 않았다. 왜냐하면 $F, K, T$의 엄밀한 정의를 도입하지 않았을 뿐더러, 어디까지가 형식 체계 <em>내에서</em> 증명 가능한 내용이고 어디까지가 형식 체계 <em>외에서</em>만 증명 가능한 내용인지 구분하지 않았기 때문이다. 이 한계를 극복하기 위해, $F, K, T$ 및 괴델의 세 가지 주장에 대한 증명을 엄밀하게 형식화해 보도록 한다.</p>

<h4 id="121-f">1.2.1. $F$</h4>

<p>$F$는 가장 형식화하기 쉬운 개념이다. 특히 다음 사실들이 알려져 있다.</p>

<blockquote>
  <p><strong>형식 체계-튜링 기계 대응.</strong> $F$가 재귀적으로 공리화 가능한<sub>recursively axiomatisable</sub> 형식 체계일 때, $F$로부터 증명 가능한 명제들을 재귀적으로 열거<sub>recursively enumerate</sub>하는 튜링 기계가 존재한다.</p>
</blockquote>

<p>덧붙이자면, 우리가 관심을 가질 만한 형식 체계는 재귀적으로 공리화 가능하다.</p>

<blockquote>
  <p><strong>클레이니 술어의 재귀성.</strong> 튜링 기계의 작동은 페아노 산술 내에서 형식화될 수 있다. 구체적으로, 괴델 수가 $x$인 튜링 기계가 자연수 $y$를 입력받았을 때 괴델 수가 $z$인 작동 기록<sub>computation record</sub>으로 끝나는지를 판단하는 1차 논리 술어 $K(x, y, z)$가 존재한다.</p>
</blockquote>

<p>위 두 정리의 따름정리로 다음을 얻는다.</p>

<blockquote>
  <p><strong>따름정리.</strong> 형식 체계는 재귀적으로 열거 가능하다. 즉, ”$e$번째 형식 체계“ $F_e$를 페아노 산술에서 정의할 수 있다.</p>
</blockquote>

<p>예를 들어 $F_{123}$은 로빈슨 산술, $F_{456}$은 ZFC 등과 같은 식이다. $F_{123}(\ulcorner 1 + 1 = 2 \urcorner)$은 $1 + 1 = 2$가 로빈슨 산술에서 증명 가능하다는 것이다. 그리고 $\mathsf{PA} \vdash F_{123}(\ulcorner 1 + 1 = 2 \urcorner)$이다.</p>

<h4 id="122-t">1.2.2. $T$</h4>

<p>$T$의 형식적 정의로는 <strong>타르스키의 유형적 참 정의<sub>Tarski’s typed truth definition</sub></strong>가 가장 유망하다. 타르스키의 유형적 참 정의는 의미론적 정의가 아니라 형태론적 정의이지만, 현 논의의 목적으로는 적합하다. 타르스키의 정의는 다음을 비롯한 공리들로 이루어져 있다.</p>

<ul>
  <li>
    <p>$\forall x : \mathrm{Sent}(x) \rightarrow (T(\hat{\lnot} x) \leftrightarrow \lnot T(x))$</p>
  </li>
  <li>
    <p>$\forall x, y : [\mathrm{Sent}(x) \land \mathrm{Sent}(y)] \rightarrow [T(x\; \hat{\lor} \;y) \leftrightarrow T(x) \lor T(y)]$</p>
  </li>
</ul>

<p>여기서 $\mathrm{Sent}$는 주어진 문장(의 괴델 수)가 적형식인지를 판단한다. 한편 $\hat{\quad}$은 언어와 메타언어를 구분하기 위해 도입되는데, 자세한 설명은 크게 중요하지 않기 때문에 이 정도로 줄인다.</p>

<h4 id="123-k">1.2.3. $K$</h4>

<p>$K$는 세 개념 중 가장 까다로운 개념이다. 완전한 의미론적 정의를 제시할 수 없음은 물론, 형태론적 정의를 제시하기에도 의문스러운 구석이 많다. 그러나 이 글의 목표는 불완전성 정리로부터 $F \subsetneq K$를 직접적으로 보일 수 없음을 논증하는 것이므로, 자비의 원칙에 따라 $K$의 외연을 최대한으로 보장하는 다음의 형태론적 정의를 제시하도록 하겠다.</p>

<blockquote>
  <p><strong>$K$의 형태론적 정의.</strong></p>

  <ol>
    <li>$\phi$가 논리적으로 참일 때, $K\phi$이다.</li>
    <li>임의의 문장 $\phi, \psi$에 대해 $(K(\phi \rightarrow \psi) \land K\phi) \rightarrow K\psi$이다.</li>
    <li>임의의 문장 $\phi$에 대해 $K\phi \rightarrow \phi$이다.</li>
    <li>임의의 문장 $\phi$에 대해 $K\phi \rightarrow KK\phi$이다.</li>
  </ol>
</blockquote>

<p>여기서 $K$는 논리 연산자이다. 때문에 $K(\phi)$ 또는 $K(\ulcorner \phi \urcorner)$가 아닌 $K\phi$와 같이 적었다. $K$가 술어가 아닌 논리 연산자로 간주되어야 하는 이유는 본 논문의 주석 29를 참고하라.</p>

<h4 id="124-mathsfea와-mathsfea_t">1.2.4. $\mathsf{EA}$와 $\mathsf{EA}_T$</h4>

<p>$F, K, T$에 대해 추론할 수 있는 형식 체계를 구성해 보자. 먼저 1.2.1에서 보았듯이 $F$는 이미 $\mathsf{PA}$에서 형식화 가능하므로 별다른 조치가 필요하지 않다.</p>

<p>$L_{\mathsf{EA}}$를 $\mathsf{PA}$에 함수 $K$를 추가한 것으로 정의하자. $\Sigma$를 $\mathsf{PA}$의 공리들과, $K$의 형태론적 정의의 공리들의 모임이라고 하자 (단, $\mathsf{PA}$의 귀납 공리꼴을 $L_{\mathsf{PA}}$가 아닌 $L_{\mathsf{EA}}$의 문장들에 대해 취한다). $\mathsf{EA}$의 공리는 $\Sigma \cup K\Sigma$이다.</p>

<p>$L_{\mathsf{EA}_T}$를 $\mathsf{EA}$에 술어 $T$를 추가한 것으로 정의하자. $\Sigma^\ast$를 $\Sigma$와, $T$의 형태론적 정의의 공리들의 모임이라고 하자 (단, $\mathsf{PA}$의 귀납 공리꼴을 $L_{\mathsf{EA}_T}$의 문장들에 대해 취한다. $\mathsf{EA}_T$의 공리는 $\Sigma^\ast \cup K\Sigma^\ast$이다.</p>

<h3 id="13-괴델-조건문의-형식적-증명">1.3. 괴델 조건문의 형식적 증명</h3>

<p>괴델의 세 가지 주장은 $\mathsf{EA}_T$에서 형식적으로 증명 가능함을 보인다.</p>

<h4 id="131-첫-번째-주장">1.3.1. 첫 번째 주장</h4>

<blockquote>
  <p><strong>주장 1.</strong> $F \subseteq T \implies F \subsetneq T$</p>
</blockquote>

<p>이 주장은 $\mathsf{EA}_T$에서 쉽게 증명 가능하다. 괴델의 불완전성 정리의 직접적인 결과이기 때문이다.</p>

<h4 id="132-두-번째-주장">1.3.2. 두 번째 주장</h4>

<blockquote>
  <p><strong>주장 2.</strong> $K(F \subseteq T) \implies F \subsetneq K$</p>
</blockquote>

<p>이 주장 또한 $\mathsf{EA}_T$에서 증명 가능하다. 사실 다음의 더 강한 결과가 증명 가능하다.</p>

<blockquote>
  <p><strong>라인하르트 제1정리.</strong> 임의의 문장 $\phi$에 대해</p>

\[\mathsf{EA} \vdash K(F(\ulcorner \phi \urcorner) \rightarrow \phi)\]

  <p>라면, 어떤 문장 $\psi$가 존재하여</p>

\[\mathsf{EA} \vdash K\psi \land K\lnot F(\ulcorner \psi \urcorner)\]

  <p>이다 (즉, $\mathsf{EA} \vdash F \subsetneq K$이다).</p>
</blockquote>

<h4 id="133-세-번째-주장">1.3.3. 세 번째 주장</h4>

<blockquote>
  <p><strong>주장 3.</strong> $\forall F (F \subsetneq K) \;  \lor \; K \subsetneq T$</p>
</blockquote>

<p>위 주장에서 $F \subsetneq K$를 풀어 쓰면 다음과 같다.</p>

\[\forall e \; \exists x \;(\mathrm{Sent}_{L_{\mathsf{PA}}}(x) \land K(x) \land x \notin F_e  )\]

<p>그리고 $K \subsetneq T$를 풀어 쓰면 다음과 같다.</p>

\[\exists x \;(\mathrm{Sent}_{L_{\mathsf{PA}}}(x) \land T(x) \land \lnot  K(x) \land \lnot K(\lnot x))\]

<p>그런데 여기에는 문제가 있다. 앞서 말했듯이 $K$는 술어가 아닌 논리 연산자이기 때문에 양화 맥락에 속할 수 없다. 이를테면 $\exists \phi : \lnot\phi$가 문법적으로 올바르지 않듯이 말이다. 이 문제를 회피하기 위해, $\exists x \; K(x)$라고 적는 대신 $\exists x\; T(\hat{K}x)$와 같이 적도록 한다. 따라서 주장 3의 올바른 형식화는 다음과 같다.</p>

\[\begin{gather}
\forall e \; \exists x \;(\mathrm{Sent}_{L_{\mathsf{PA}}}(x) \land T(\hat{K}x) \land x \notin F_e  ) \\\\
\lor\\\\
\exists x \;(\mathrm{Sent}_{L_{\mathsf{PA}}}(x) \land T(x) \land \lnot T(\hat{K}x) \land \lnot T(\hat{K}\lnot x))
\end{gather}\]

<p>위 논리식을 $\mathrm{GD}$라고 하자. 다음 정리가 알려져 있다.</p>

<blockquote>
  <p><strong>라인하르트 제2정리.</strong> $\mathsf{EA}_T \vdash \mathrm{GD}$.</p>
</blockquote>

<p>따라서 <strong>괴델 조건문은 적절한 형식 체계 하에서 증명 가능하다.</strong></p>

<h2 id="2-루카스와-펜로즈">2. 루카스와 펜로즈</h2>

<h3 id="21-무모순성-판별-문제">2.1. 무모순성 판별 문제</h3>

<p>루카스와 펜로즈는 $K(F \subseteq T)$임을 주장함으로써 $F \subsetneq K$를 직접적으로 보이고자 한다. 즉, 루카스와 펜로즈는 이상적인 인간 정식은 주어진 임의의 형식 체계가 모순적인지 아닌지를 판별할 능력이 있으며, 이에 따라 $\forall F \subseteq T: F \subsetneq K$라고 주장한다.</p>

<p>그러나 과연 이상적인 인간 정신에게 임의의 형식 체계의 무모순성을 판별할 능력이 있는지는 매우 의문스럽다. 일례로 $R$이 리만 가설이라고 하자. $R$은 페아노 산술에서 $\Pi_1$ 명제로 형식화될 수 있다. 그리고 앞서 언급했듯이 $\mathsf{PA}$는 $\Sigma_1$-완전하기 때문에, $\mathsf{PA} + R$의 무모순성은 $R$과 동치이다. 이 예시는 형식 체계의 무모순성 판별 문제가 리만 가설 이상으로 어려운 문제인 경우도 있음을 보여준다.</p>

<h3 id="22-기계주의의-상대적-무모순성">2.2. 기계주의의 상대적 무모순성</h3>

<p>이 사실만으로 루카스와 펜로즈의 기획은 난관에 봉착하겠으나, 여기서 나아가 우리는 더 강력한 사실을 보일 수 있다. 그 사실이란, $K(F\subseteq T)$는 형식적으로 증명 불가능하다는 것이다. 왜냐하면 기계주의적 논제들이 $\mathsf{EA}_T$와 무모순적이기 때문이다.</p>

<p>이것을 보이기에 앞서, 기계주의적 논제들을 그 강도에 따라 분류하는 것이 유용하다. 이 글에서 채택하는 라인하르트의 구분법은 다음과 같다.</p>

<ul>
  <li><strong>약한 기계주의<sub>Weak Mechanical Thesis, WMT</sub>:</strong> $\exists e \; ( K = F_e )$</li>
  <li><strong>강한 기계주의<sub>Strong Mechanical Thesis, SMT</sub>:</strong> $K\exists e\; (K = F_e)$</li>
  <li><strong>아주 강한 기계주의<sub>Super Strong Mechanical Thesis, SSMT</sub>:</strong> $\exists e \; K(K = F_e)$</li>
</ul>

<p>각각 풀어 설명하자면,</p>

<ul>
  <li>WMT: 이상적인 인간 정신은 <em>어떠한</em> 튜링 기계와 동등하다.</li>
  <li>SMT: 이상적인 인간 정신은, 자신이 <em>어떠한</em> 튜링 기계와 동등함을 안다.</li>
  <li>SSMT: 이상적인 인간 정신은, 자신이 <em>특정한</em> 튜링 기계와 동등함을 안다.</li>
</ul>

<p>다음이 알려져 있다.</p>

<blockquote>
  <p><strong>라인하르트 제3정리.</strong> $\mathsf{EA}_T + \mathsf{SSMT}$는 모순적이다.</p>
</blockquote>

<p>따라서 $\mathsf{EA}_T$의 공리를 가정하면 아주 강한 기계주의는 거짓이다. 요컨데 설령 이상적인 인간 정신과 동등한 컴퓨터가 주어지더라도, 우리는 그것이 <em>정말로</em> 인간 정신과 동등한지 알 수는 없다.</p>

<p>그러나 이 사실만으로 루카스와 펜로즈의 손을 들어주기는 어렵다. 기계주의의 핵심 논제는 우리와 동등한 능력을 가지는 기계의 판별법이 아닌 우리와 동등한 능력을 가지는 기계의 존재성이기 때문이다. 그리고 이에 관해서는 다음이 알려져 있다.</p>

<blockquote>
  <p><strong>라인하르트 제4정리.</strong> $\mathsf{EA}_T + \mathsf{WMT}$는 무모순적이다.</p>
</blockquote>

<p>더 나아가 다음이 알려져 있다.</p>

<blockquote>
  <p><strong>칼슨의 정리.</strong> $\mathsf{EA}_T + \mathsf{SMT}$는 무모순적이다.</p>
</blockquote>

<p>즉 $\mathsf{EA}_T$는 이상적인 인간 정신과 동등한 기계의 존재 가능성을 열어둘 뿐 아니라, 그 사실을 인간 정신이 스스로 입증하는 가능성 또한 열어둔다. 위 사실들은 불완전성 정리만으로 반기계주의를 입증하려는 시도가 수포로 돌아갈 수밖에 없음을 보여준다.</p>

<h3 id="23-괴델의-혜안">2.3. 괴델의 혜안</h3>

<p>놀랍게도 괴델은 처음부터 이 모든 논의를 꿰고 있었던 것으로 보인다. 왕<sub>Wang</sub>이 남긴 괴델과의 대화 회고에 따르면,</p>

<blockquote>
  <p>불완전성 정리는 인간의 수학적 직관과 동등한 결과를 내놓는 컴퓨터의 가능성 [$\exists e\; (F_e = K)$]을 배제하지 않는다. 그러나 다음을 시사하기는 한다. 만약 그 가능성이 — 비록 다른 고려 사항으로 인해 확률은 지극히 낮지만 — 사실이라면, 우리는 그러한 컴퓨터의 설계를 알 수 없거나 [$\lnot K (F_e = K)$], 그 컴퓨터가 올바르게 작동한다는 사실을 알 수 없다 [$\lnot K (F_e \subseteq T)$].</p>
</blockquote>

<s>괴델은 신이야</s>

<h2 id="3-결론">3. 결론</h2>

<p>지금까지의 논의는 괴델의 조건문으로부터 반기계주의를 직접적으로 이끌어내려는 더이상의 시도를 방지하는 데 충분할 것이다. 그러나 논리학의 결과로부터 반기계주의를 논증하려는 또다른 접근 방식이 있다. 흔히 <strong>펜로즈의 새 논증</strong>이라고 불리는 이 논증은 타르스키의 유형적 참과는 구별되는, 유형 독립적 참<sub>type-free truth</sub>을 내세우는 논증이다. 해당 논증의 형식화와 그것이 시사하는 바는 본 논문의 2편에서 다루도록 한다.</p>

  </div>
  <div style="margin-bottom: 6em"></div>
  
    <div class="post fade-in-section" data-lang="en" style="display: none">
      <h1 class="post-title">
        <a href="/2025/02/09/godel-lucas-penrose/en"> Can the Mind Be Reduced to a Machine: Gödel's Disjunction and the Penrose-Lucas Argument </a>
      </h1>
    <span class="post-date">09 Feb 2025</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/mathematics/'">
        Mathematics
      </div>
      
      <div class="tag" onclick="location.href='/tags/philosophy/'">
        Philosophy
      </div>
      
      <div class="tag" onclick="location.href='/tags/logic/'">
        Logic
      </div>
      
    </div>
     <blockquote>
  <p>This post was machine translated and has not yet been proofread. It may contain minor errors or unnatural expressions. Proofreading will be done in the near future.</p>
</blockquote>

<p><img src="https://velog.velcdn.com/images/dimenerno/post/b71a00d7-efdf-4ec3-ad5c-cc32b67cf70c/image.jpeg" alt="" /></p>

<blockquote>
  <p>This article is a summary of <a href="/public/On the question of whether the mind can be mechanized 1.pdf">Peter Koellner, <em>On the question of whether the mind can be mechanized</em> (2018)</a>.</p>
</blockquote>

<p><strong>Abstract.</strong> The Church-Turing thesis and Gödel’s incompleteness theorems suggest the existence of mathematical truths that cannot be proved mechanically. However, if an ideal human mind can prove all mathematical truths, then the conclusion follows that the ideal human mind is not equivalent to a machine. This article examines the arguments of Lucas and Penrose, who attempt to establish anti-mechanism in such a manner, and introduces formal proofs that refute these arguments.</p>

<h2 id="introduction">Introduction</h2>

<p>The following are well-known results in logic:</p>

<ul>
  <li>
    <p><strong>Church-Turing Thesis.</strong> To be <strong>computable</strong> by an ideal machine is to be implementable by a Turing machine.</p>
  </li>
  <li>
    <p><strong>Gödel’s Incompleteness Theorem.</strong> If $F$ is a formal system satisfying certain conditions, then there exists a sentence that is true but unprovable in $F$.</p>
  </li>
  <li>
    <p><strong>Formal System-Turing Machine Correspondence.</strong> If $F$ is a formal system satisfying certain conditions, then there exists a Turing machine that enumerates the propositions provable in $F$.</p>
  </li>
</ul>

<p>Combining these three theses with the fact that we humans appear to be capable of grasping mathematical truths not captured by formal systems—such as the consistency of arithmetic—the incompleteness theorem appears to suggest that the extension of mathematical results derivable by an ideal human mind exceeds the extension of results derivable by an ideal finite machine. That is, the incompleteness theorem appears to suggest anti-mechanism: that the mind cannot be reduced to a machine.</p>

<p>In this article, we examine how far this suggestion can be justified. As a result, we shall show that whilst the incompleteness theorem suggests anti-mechanism <em>or</em> Platonism, it does not directly suggest anti-mechanism.</p>

<h2 id="1-gödels-disjunction">1. Gödel’s Disjunction</h2>

<p>Gödel argued that from the incompleteness theorem, it follows that <em>at least one</em> of the following two positions is true. We shall call this <strong>Gödel’s Disjunction</strong>.</p>

<ol>
  <li>
    <p><strong>Anti-mechanism:</strong> The mathematical results derivable by an ideal human mind always exceed the mathematical results derivable by an ideal finite machine. Therefore, the human mind cannot be reduced to a machine.</p>
  </li>
  <li>
    <p><strong>Platonism:</strong> There exist mathematical truths that cannot be grasped by an ideal human mind. Therefore, mathematical truth exists independently of the human mind.</p>
  </li>
</ol>

<p>It is noteworthy that both positions are contrary to materialist philosophy. Whilst Gödel was generally reserved about philosophical arguments, he argued strongly that this particular argument was a “mathematically established fact”. Our first task is to verify whether this argument is indeed a “mathematically established fact”.</p>

<h3 id="11-gödels-three-claims">1.1. Gödel’s Three Claims</h3>

<p>Let us introduce some notation.</p>

<ol>
  <li>
    <p>$F$ is the set of all sentences that the formal system $F$ can prove.</p>
  </li>
  <li>
    <p>$K$ is the set of all sentences that an ideal human mind can prove.</p>
  </li>
  <li>
    <p>$T$ is the set of true sentences.</p>
  </li>
</ol>

<p>Throughout this article, we shall assume $K \subseteq T$. We also presuppose that $F$ is a formal system to which Gödel’s incompleteness theorem applies—that is, a consistent system containing Peano arithmetic (in fact, this condition can be weakened to Robinson arithmetic).</p>

<p>Before proceeding to the main discussion, let us review Gödel’s incompleteness theorem.</p>

<blockquote>
  <p><strong>Gödel’s Incompleteness Theorem.</strong> When $F$ is a consistent mathematical system containing arithmetic, the following holds:</p>

  <ul>
    <li><strong>First Theorem.</strong> There exists a proposition that is true but unprovable in $F$.</li>
    <li><strong>Second Theorem.</strong> The consistency of $F$ is an instance of the First Theorem.</li>
  </ul>
</blockquote>

<p>Incidentally, whilst the incompleteness theorem traditionally targets Peano arithmetic, the incompleteness theorem also holds for weaker arithmetic systems, including Robinson arithmetic.</p>

<h4 id="111-first-claim">1.1.1. First Claim</h4>

<p>Gödel first claims the following:</p>

<blockquote>
  <p><strong>Claim 1.</strong> $F \subseteq T \implies F \subsetneq T$</p>
</blockquote>

<p>The proof is as follows. If $F \subseteq T$, then $\mathrm{Con}(F) \in T$. However, by the Second Incompleteness Theorem, $\mathrm{Con}(F) \notin F$. Therefore, $F \subsetneq T$.</p>

<h4 id="112-second-claim">1.1.2. Second Claim</h4>

<p>Gödel’s second claim is as follows:</p>

<blockquote>
  <p><strong>Claim 2.</strong> $K(F \subseteq T) \implies F \subsetneq K$</p>
</blockquote>

<p>The proof is as follows. If $K(F \subseteq T)$, then $\mathrm{Con}(F) \in K$. However, as we have seen, $F \subseteq T \implies \mathrm{Con}(F) \notin F$, so $F \subsetneq K$.</p>

<p>But if $F \subsetneq K$ is true, how should we understand this? One approach is to consider a hierarchy of formal systems.</p>

<p>Gödel emphasises that the unprovable sentences suggested by the incompleteness theorem need not be <em>absolutely</em> unprovable. This is because sentences unprovable in formal system $F$ may become provable in systems of higher order than $F$. For example, if $\mathsf{PA}$ is consistent, then whilst $\mathsf{PA}$ cannot prove $\mathrm{Con}(\mathsf{PA})$, it is known that second-order Peano arithmetic $\mathsf{PA}_2$ can prove $\mathrm{Con}(\mathsf{PA})$. Of course, $\mathsf{PA}_2$ cannot prove $\mathrm{Con}(\mathsf{PA}_2)$, but this is provable in third-order Peano arithmetic, and such a hierarchy continues.</p>

<p>This entire hierarchy appears to be subsumed under $K$. From this perspective, each formal system is like a set, and $K$ is like the collection of all sets. And just as the collection of all sets cannot be a set, an analogy holds that $K$ cannot be a formal system.</p>

<h4 id="113-third-claim">1.1.3. Third Claim</h4>

<p>However, one might wonder: instead of writing “Claim 2” as a conditional, could we not claim $F \subsetneq K$ by asserting that $K(F \subsetneq T)$ is true?</p>

<p>Gödel points out that the incompleteness theorem alone cannot lead to such a claim. This is because the possibility of the existence of a formal system $F^*$ that coincides with $K$ cannot be completely ruled out (note that the previous discussion regarding higher-order Peano arithmetic was merely an analogy).</p>

<p>Regarding this, Gödel says:</p>

<blockquote>
  <p>[If such a formal system exists] human reason—at least in its mathematical aspect—is equivalent to a finite machine. However, that machine cannot completely understand its own operation [in the sense that it cannot prove its own consistency]. This inability would be mistaken by humans as the infinite extensibility of the mind.</p>
</blockquote>

<p>Instead, Gödel’s third claim is as follows. This claim is Gödel’s disjunction.</p>

<blockquote>
  <p><strong>Claim 3.</strong> $\forall F (F \subsetneq K) \;  \lor \; K \subsetneq T$</p>
</blockquote>

<p>The proof is as follows. Suppose there is a formal system $F^<em>$ such that $F^</em> = K$. Since we have assumed $K \subset T$, we have $F^* \subset T$, and by Claim 1, $F^* \subsetneq T$.</p>

<p>The former signifies anti-mechanism, whilst the latter signifies Platonism.</p>

<h3 id="12-formalisation-of-gödels-disjunction">1.2. Formalisation of Gödel’s Disjunction</h3>

<p>So far, we have presented Gödel’s three claims and introduced brief proofs thereof. However, these proofs were not actually precise. This is because we did not introduce rigorous definitions of $F, K, T$, nor did we distinguish between what content can be proved <em>within</em> a formal system and what content can only be proved <em>outside</em> a formal system. To overcome this limitation, let us rigorously formalise $F, K, T$ and the proofs of Gödel’s three claims.</p>

<h4 id="121-f">1.2.1. $F$</h4>

<p>$F$ is the easiest concept to formalise. In particular, the following facts are known:</p>

<blockquote>
  <p><strong>Formal System-Turing Machine Correspondence.</strong> When $F$ is a recursively axiomatisable formal system, there exists a Turing machine that recursively enumerates the propositions provable from $F$.</p>
</blockquote>

<p>Additionally, the formal systems of interest to us are recursively axiomatisable.</p>

<blockquote>
  <p><strong>Recursiveness of Kleene Predicates.</strong> The operation of Turing machines can be formalised within Peano arithmetic. Specifically, there exists a first-order logical predicate $K(x, y, z)$ that determines whether a Turing machine with Gödel number $x$, when given natural number $y$ as input, terminates with a computation record with Gödel number $z$.</p>
</blockquote>

<p>As a corollary of the above two theorems, we obtain:</p>

<blockquote>
  <p><strong>Corollary.</strong> Formal systems are recursively enumerable. That is, the “$e$-th formal system” $F_e$ can be defined in Peano arithmetic.</p>
</blockquote>

<p>For example, $F_{123}$ might be Robinson arithmetic, $F_{456}$ might be ZFC, and so forth. $F_{123}(\ulcorner 1 + 1 = 2 \urcorner)$ means that $1 + 1 = 2$ is provable in Robinson arithmetic. And $\mathsf{PA} \vdash F_{123}(\ulcorner 1 + 1 = 2 \urcorner)$.</p>

<h4 id="122-t">1.2.2. $T$</h4>

<p>The most promising formal definition of $T$ is <strong>Tarski’s typed truth definition</strong>. Whilst Tarski’s typed truth definition is a syntactic rather than semantic definition, it is suitable for the purposes of the present discussion. Tarski’s definition consists of axioms including the following:</p>

<ul>
  <li>
    <p>$\forall x : \mathrm{Sent}(x) \rightarrow (T(\hat{\lnot} x) \leftrightarrow \lnot T(x))$</p>
  </li>
  <li>
    <p>$\forall x, y : [\mathrm{Sent}(x) \land \mathrm{Sent}(y)] \rightarrow [T(x\; \hat{\lor} \;y) \leftrightarrow T(x) \lor T(y)]$</p>
  </li>
</ul>

<p>Here, $\mathrm{Sent}$ determines whether a given sentence (or its Gödel number) is well-formed. Meanwhile, $\hat{\quad}$ is introduced to distinguish between language and meta-language; a detailed explanation is not particularly important, so we shall leave it at this.</p>

<h4 id="123-k">1.2.3. $K$</h4>

<p>$K$ is the most challenging of the three concepts. Not only can we not provide a complete semantic definition, but there are also questionable aspects to providing a syntactic definition. However, since the goal of this article is to demonstrate that $F \subsetneq K$ cannot be directly shown from the incompleteness theorem, according to the principle of charity, we shall present the following syntactic definition that maximally guarantees the extension of $K$.</p>

<blockquote>
  <p><strong>Syntactic Definition of $K$.</strong></p>

  <ol>
    <li>When $\phi$ is logically true, $K\phi$.</li>
    <li>For arbitrary sentences $\phi, \psi$: $(K(\phi \rightarrow \psi) \land K\phi) \rightarrow K\psi$.</li>
    <li>For arbitrary sentence $\phi$: $K\phi \rightarrow \phi$.</li>
    <li>For arbitrary sentence $\phi$: $K\phi \rightarrow KK\phi$.</li>
  </ol>
</blockquote>

<p>Here, $K$ is a logical operator. Therefore, we write $K\phi$ rather than $K(\phi)$ or $K(\ulcorner \phi \urcorner)$. For the reason why $K$ should be regarded as a logical operator rather than a predicate, see footnote 29 of the original paper.</p>

<h4 id="124-mathsfea-and-mathsfea_t">1.2.4. $\mathsf{EA}$ and $\mathsf{EA}_T$</h4>

<p>Let us construct a formal system capable of reasoning about $F, K, T$. Firstly, as we saw in 1.2.1, $F$ is already formalisable in $\mathsf{PA}$, so no special measures are required.</p>

<p>Let $L_{\mathsf{EA}}$ be defined as $\mathsf{PA}$ with the function $K$ added. Let $\Sigma$ be the collection of axioms of $\mathsf{PA}$ and the axioms of the syntactic definition of $K$ (where the induction schema of $\mathsf{PA}$ is taken over sentences of $L_{\mathsf{EA}}$ rather than $L_{\mathsf{PA}}$). The axioms of $\mathsf{EA}$ are $\Sigma \cup K\Sigma$.</p>

<p>Let $L_{\mathsf{EA}<em>T}$ be defined as $\mathsf{EA}$ with the predicate $T$ added. Let $\Sigma^*$ be the collection of $\Sigma$ and the axioms of the syntactic definition of $T$ (where the induction schema of $\mathsf{PA}$ is taken over sentences of $L</em>{\mathsf{EA}_T}$). The axioms of $\mathsf{EA}_T$ are $\Sigma^* \cup K\Sigma^*$.</p>

<h3 id="13-formal-proof-of-gödels-disjunction">1.3. Formal Proof of Gödel’s Disjunction</h3>

<p>We show that Gödel’s three claims are formally provable in $\mathsf{EA}_T$.</p>

<h4 id="131-first-claim">1.3.1. First Claim</h4>

<blockquote>
  <p><strong>Claim 1.</strong> $F \subseteq T \implies F \subsetneq T$</p>
</blockquote>

<p>This claim is easily provable in $\mathsf{EA}_T$. This is because it is a direct consequence of Gödel’s incompleteness theorem.</p>

<h4 id="132-second-claim">1.3.2. Second Claim</h4>

<blockquote>
  <p><strong>Claim 2.</strong> $K(F \subseteq T) \implies F \subsetneq K$</p>
</blockquote>

<p>This claim is also provable in $\mathsf{EA}_T$. In fact, the following stronger result is provable:</p>

<blockquote>
  <p><strong>Reinhardt’s First Theorem.</strong> For arbitrary sentence $\phi$, if</p>

\[\mathsf{EA} \vdash K(F(\ulcorner \phi \urcorner) \rightarrow \phi)\]

  <p>then there exists some sentence $\psi$ such that</p>

\[\mathsf{EA} \vdash K\psi \land K\lnot F(\ulcorner \psi \urcorner)\]

  <p>(that is, $\mathsf{EA} \vdash F \subsetneq K$).</p>
</blockquote>

<h4 id="133-third-claim">1.3.3. Third Claim</h4>

<blockquote>
  <p><strong>Claim 3.</strong> $\forall F (F \subsetneq K) \;  \lor \; K \subsetneq T$</p>
</blockquote>

<p>Expanding $F \subsetneq K$ in the above claim gives:</p>

\[\forall e \; \exists x \;(\mathrm{Sent}_{L_{\mathsf{PA}}}(x) \land K(x) \land x \notin F_e  )\]

<p>And expanding $K \subsetneq T$ gives:</p>

\[\exists x \;(\mathrm{Sent}_{L_{\mathsf{PA}}}(x) \land T(x) \land \lnot  K(x) \land \lnot K(\lnot x))\]

<p>However, there is a problem here. As mentioned earlier, since $K$ is a logical operator rather than a predicate, it cannot be placed within a quantified context. Just as $\exists \phi : \lnot\phi$ is not grammatically correct. To circumvent this problem, instead of writing $\exists x \; K(x)$, we write $\exists x\; T(\hat{K}x)$. Therefore, the correct formalisation of Claim 3 is as follows:</p>

\[\begin{gather}
\forall e \; \exists x \;(\mathrm{Sent}_{L_{\mathsf{PA}}}(x) \land T(\hat{K}x) \land x \notin F_e  ) \\\\
\lor\\\\
\exists x \;(\mathrm{Sent}_{L_{\mathsf{PA}}}(x) \land T(x) \land \lnot T(\hat{K}x) \land \lnot T(\hat{K}\lnot x))
\end{gather}\]

<p>Let us call the above formula $\mathrm{GD}$. The following theorem is known:</p>

<blockquote>
  <p><strong>Reinhardt’s Second Theorem.</strong> $\mathsf{EA}_T \vdash \mathrm{GD}$.</p>
</blockquote>

<p>Therefore, <strong>Gödel’s disjunction is provable under an appropriate formal system.</strong></p>

<h2 id="2-lucas-and-penrose">2. Lucas and Penrose</h2>

<h3 id="21-the-consistency-decision-problem">2.1. The Consistency Decision Problem</h3>

<p>Lucas and Penrose attempt to directly show $F \subsetneq K$ by claiming $K(F \subseteq T)$. That is, Lucas and Penrose argue that the ideal human mind has the ability to determine whether any given formal system is consistent or not, and accordingly claim $\forall F \subseteq T: F \subsetneq K$.</p>

<p>However, it is highly questionable whether the ideal human mind has the ability to determine the consistency of arbitrary formal systems. For instance, let $R$ be the Riemann hypothesis. $R$ can be formalised as a $\Pi_1$ proposition in Peano arithmetic. And as mentioned earlier, since $\mathsf{PA}$ is $\Sigma_1$-complete, the consistency of $\mathsf{PA} + R$ is equivalent to $R$. This example shows that there are cases where the consistency decision problem for formal systems is at least as difficult as the Riemann hypothesis.</p>

<h3 id="22-relative-consistency-of-mechanism">2.2. Relative Consistency of Mechanism</h3>

<p>This fact alone would put Lucas and Penrose’s project in difficulty, but we can go further and show a more powerful fact. That fact is that $K(F\subseteq T)$ is formally unprovable. This is because mechanistic theses are consistent with $\mathsf{EA}_T$.</p>

<p>Before showing this, it is useful to classify mechanistic theses according to their strength. Reinhardt’s classification adopted in this article is as follows:</p>

<ul>
  <li><strong>Weak Mechanical Thesis (WMT):</strong> $\exists e \; ( K = F_e )$</li>
  <li><strong>Strong Mechanical Thesis (SMT):</strong> $K\exists e\; (K = F_e)$</li>
  <li><strong>Super Strong Mechanical Thesis (SSMT):</strong> $\exists e \; K(K = F_e)$</li>
</ul>

<p>To explain each:</p>

<ul>
  <li>WMT: The ideal human mind is equivalent to <em>some</em> Turing machine.</li>
  <li>SMT: The ideal human mind knows that it is equivalent to <em>some</em> Turing machine.</li>
  <li>SSMT: The ideal human mind knows that it is equivalent to a <em>specific</em> Turing machine.</li>
</ul>

<p>The following is known:</p>

<blockquote>
  <p><strong>Reinhardt’s Third Theorem.</strong> $\mathsf{EA}_T + \mathsf{SSMT}$ is inconsistent.</p>
</blockquote>

<p>Therefore, assuming the axioms of $\mathsf{EA}<em>T$, the super strong mechanical thesis is false. In short, even if a computer equivalent to the ideal human mind were given, we could not know whether it is _truly</em> equivalent to the human mind.</p>

<p>However, this fact alone is insufficient to support Lucas and Penrose. This is because the core thesis of mechanism is not the method of identifying machines with capabilities equivalent to ours, but the existence of machines with capabilities equivalent to ours. Regarding this, the following is known:</p>

<blockquote>
  <p><strong>Reinhardt’s Fourth Theorem.</strong> $\mathsf{EA}_T + \mathsf{WMT}$ is consistent.</p>
</blockquote>

<p>Furthermore, the following is known:</p>

<blockquote>
  <p><strong>Carlson’s Theorem.</strong> $\mathsf{EA}_T + \mathsf{SMT}$ is consistent.</p>
</blockquote>

<p>That is, $\mathsf{EA}_T$ not only leaves open the possibility of the existence of a machine equivalent to the ideal human mind, but also leaves open the possibility that the human mind can prove this fact itself. These facts show that attempts to establish anti-mechanism solely through the incompleteness theorem are bound to fail.</p>

<h3 id="23-gödels-insight">2.3. Gödel’s Insight</h3>

<p>Remarkably, Gödel appears to have understood all of this discussion from the beginning. According to Wang’s recollections of conversations with Gödel:</p>

<blockquote>
  <p>The incompleteness theorem does not rule out the possibility of a computer that produces results equivalent to human mathematical intuition [$\exists e\; (F_e = K)$]. However, it does suggest the following: if that possibility—though the probability is extremely low due to other considerations—is true, then either we cannot know the design of such a computer [$\lnot K (F_e = K)$], or we cannot know that the computer operates correctly [$\lnot K (F_e \subseteq T)$].</p>
</blockquote>

<s>Gödel is a god</s>

<h2 id="3-conclusion">3. Conclusion</h2>

<p>The discussion thus far should be sufficient to prevent further attempts to directly derive anti-mechanism from Gödel’s disjunction. However, there is another approach to arguing for anti-mechanism from logical results. This argument, commonly called <strong>Penrose’s new argument</strong>, is an argument that puts forward type-free truth, as distinguished from Tarski’s typed truth. The formalisation of this argument and its implications will be addressed in Part 2 of this paper.</p>


  </div>
  <div style="margin-bottom: 6em"></div>
  
    <div class="post fade-in-section" data-lang="ko" style="display: none">
      <h1 class="post-title">
        <a href="/2025/02/07/arithmetic-hierarchy"> 산술 위계 </a>
      </h1>
    <span class="post-date">07 Feb 2025</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/수학/'">
        수학
      </div>
      
      <div class="tag" onclick="location.href='/tags/논리학/'">
        논리학
      </div>
      
    </div>
     <p><img src="/public/arithmetic-hierarchy.png" width="340px" style="margin: 2em auto;" /></p>

<blockquote>
  <p><strong>주의.</strong> 이 글은 뇌피셜로 쓰였기 때문에 엄밀하지 않고, 심지어 틀린 내용이 있을 수 있습니다.</p>
</blockquote>

<p><strong>산술 위계(arithmetical hierarchy)</strong>는 산술 — 엄밀히는 1차 페아노 산술 — 의 명제들을 양화사의 복잡도에 따라 분류한 것이다. 산술 위계는 증명 이론 및 계산 복잡도 이론의 핵심 개념이며, 기술적 집합론과도 연관이 있다.</p>

<h2 id="1-delta_0-명제">1. $\Delta_0$ 명제</h2>

<h3 id="11-정의">1.1. 정의</h3>

<blockquote>
  <p><strong>정의.</strong> $\Sigma_0 = \Pi_0 = \Delta_0$는 상한이 있는 양화사만을 가지는 명제들의 집합이다.</p>
</blockquote>

<p>왜 같은 부류의 명제를 세 개의 이름으로 부르는지는 곧 명확해질 것이다. 이 글에서는 특별한 이유가 없을 때에는 세 이름 중 $\Delta_0$라는 이름을 대표로 사용하겠다.</p>

<p>예를 들어 다음 네 명제들은 모두 $\Delta_0$ 명제들이다.</p>

\[\begin{gather}
\phi_1 : 0 = 1\\
\phi_2(x) : \exists y &lt; x \; [y + y = x] \\
\phi_3(x, y) : \exists z \leq y \;[ xz = y ] \\
\end{gather}\]

<p>$\phi_1$은 거짓인 문장이다. $\phi_2$는 $x$가 짝수일 때, $\phi_3$는 $x$가 $y$의 약수일 때 참인 명제이다.</p>

<p>$\Delta_0$ 명제들은 양화사에 상한이 걸려 있기 때문에, 임의의 $x$가 주어졌을 때 $x$가 해당 명제에 부합하는지를 튜링 기계로 판단할 수 있다. 예를 들어 $x$가 $\phi_2$를 만족하는지 판단하는 튜링 기계는 다음과 같다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for y &lt; x:
   if y + y == x:
      return true;

return false;
</code></pre></div></div>

<p>위 튜링 기계는 $x$번의 반복 이내에 정지한다. 따라서 $\Delta_0$는 또는 튜링 기계 등의 기계 장치로 <strong>결정 가능(decidable)</strong>한, 또는 <strong>재귀적인(recursive)</strong>, 또는 <strong>계산 가능(computable)</strong>한 명제들이다(세 표현은 동의어이다). 그러나 뒤에서 자세히 설명하듯이, 모든 결정 가능한 명제들이 $\Delta_0$인 것은 아니다.</p>

<p>괴델의 표현가능성 정리에 따라 결정 가능한 참인 명제는 증명 가능하다. 그리고 이 글에서 $\phi$가 ‘참’이라 함은, $\mathsf{PA} \vDash \phi$가 아니라, 표준 자연수 모형 $\mathcal{N}$에 대해 $\mathcal{N} \vDash \phi$라는 의미이다. 다시 말해, 다음이 성립한다.</p>

<blockquote>
  <p><strong>정리.</strong> 참인 $\Delta_0$ 문장들의 집합은 완전하다. (즉, $\phi$가 참인 $\Delta_0$ 문장이라면 $\mathsf{PA} \vdash \phi$이다.)</p>
</blockquote>

<h3 id="12-계산-이론에서의-delta_0">1.2. 계산 이론에서의 $\Delta_0$</h3>

<p>프로그래밍 언어의 관점에서 보았을 때 $\Delta_0$ 문장들은 다음만을 허용하는 코드의 집합과 대응된다.</p>

<ul>
  <li>조건문</li>
  <li>상한이 있는 반복문</li>
  <li>덧셈과 곱셈</li>
</ul>

<p>주의할 점은, <em>상한이 없는 반복문</em>과 <em>변수 재지정</em>은 허용되지 않는다는 것이다. 예를 들어 다음의 코드는 소수 판별이 $\Delta_0$임을 입증한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for y &lt; x:
  for z &lt;= y:
    if yz == x:
      return false;

return true;
</code></pre></div></div>

<p>그러나 $x^y$를 계산하는 다음의 코드는 $\Delta_0$에 해당되지 않는다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let a = 1
for 1&lt;= z &lt;= y:
   a = a * x

return a
</code></pre></div></div>

<p>그렇다면 지수 연산은 $\Delta_0$가 아닌 것일까? 그렇지는 않다. 복잡하긴 하지만, $\Delta_0$ 명제로 지수를 표현하는 방법이 <a href="https://math.stackexchange.com/questions/5032077/how-to-express-exponentiation-with-a-delta-0-formula">있다</a>. 이 사례는 주어진 연산 또는 술어가 $\Delta_0$인지 판단하는 일이 까다로울 수 있음을 방증한다. 일례로 다음이 알려져 있다.</p>

<blockquote>
  <p><strong>정리.</strong> 팩토리얼은 $\Delta_0$이지만 테트레이션은 $\Delta_0$가 아니다.</p>
</blockquote>

<p>그러나 테트레이션은 결정 가능하다. 따라서 모든 결정 가능한 명제들이 $\Delta_0$인 것은 아니다.</p>

<h2 id="2-한-단계-올라가기">2. 한 단계 올라가기</h2>

<blockquote>
  <p><strong>정의.</strong></p>

\[\begin{gather}
\Sigma_1 := \{ \exists x_1 \cdots \exists x_n \;\phi : \phi \in \Pi_0 \}\\
\Pi_1 := \{ \forall x_1 \cdots \forall x_n \;\phi : \phi \in \Sigma_0 \}\\
\Delta_1 := \Sigma_1 \cap \Pi_1
\end{gather}\]
</blockquote>

<h3 id="21-sigma_1-명제">2.1. $\Sigma_1$ 명제</h3>

<p>다음 명제들은 $\Sigma_1$이다.</p>

\[\begin{gather}
\phi_1(x): \exists y \; \underbrace{[y^2 + y + 1 = x]}_{\Pi_0}\\
\phi_2(x): ∃y\; ∃z\; \underbrace{(y \text{ is prime} ∧ z \text{ is prime} ∧ x = y + z ∧ x \text{ is even})}_{\Pi_0}
\end{gather}\]

<p>$\phi_1$은 집합 $\lbrace 1, 3, 7, 13, \dots \rbrace$에서 참이다. $\phi_2$는 골드바흐의 추측으로, 모든 $x$가 이를 만족하는지는 알려져 있지 않다.</p>

<p>$\Sigma_1$은 <strong>재귀적으로 열거 가능(recursively enumerable)</strong>한 집합들의 모임이다. 즉, $\phi \in \Sigma_1$이라면 다음의 튜링 기계 $M$이 존재한다.</p>

<ul>
  <li>$\phi(c)$가 참이라면 $M$이 $\phi(c)$를 결정함이 보장된다.</li>
  <li>$\phi(c)$가 거짓이라면 $M$이 $\phi(c)$를 결정함이 보장되지 않는다.</li>
</ul>

<p>예를 들어 다음의 튜링 기계는 $\phi_2$가 재귀적으로 열거 가능함을 보여준다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for y &gt; 1:
   for z &gt; 1:
      if isPrime(y) &amp; isPrime(z) &amp; x = y + z &amp; isEven(x):
         return true;

return false;
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">return false</code> 문이 있기는 하지만, 반복문에서 빠져나올 <code class="language-plaintext highlighter-rouge">break</code> 문이 없으므로 <code class="language-plaintext highlighter-rouge">return false</code>는 도달 불가능하다. 즉, $\phi_2(c)$가 참이라면 위의 튜링 기계는 참을 반환하지만 거짓이라면 무한 루프에 빠진다.</p>

<p>$\phi \in \Sigma_1$이 표준 자연수 모형에서 참인 문장이라면 $\mathsf{PA} \vdash \phi$이다. $\phi : \exists x \; \psi(x)$ 꼴의 명제가 표준 자연수 모형에서 참이라는 것은 어떤 $c \in \mathbb{N}$에 대해 $\psi(c)$가 참이라는 의미이며, $\psi(c)$는 참인 $\Pi_0$ 문장이므로 증명 가능하기 때문이다. 따라서 다음이 성립한다.</p>

<blockquote>
  <p><strong>정리.</strong> 참인 $\Sigma_1$ 문장들의 집합은 완전하다.</p>
</blockquote>

<h3 id="22-sigma_1-setminus-delta_0-명제">2.2. $\Sigma_1 \setminus \Delta_0$ 명제</h3>

<p>그런데 사실 지금까지 필자는 독자를 오도했다. 앞서 $\Sigma_1$의 예시로 나열한 명제들은 사실 $\Delta_0$로 쓸 수 있기 때문이다.</p>

\[\begin{gather}
\phi_1: \exists y&lt;x \;{[y^2 + y + 1 = x]}\\
\phi_2(x): ∃y&lt;x\; ∃z&lt;x\; {(y \text{ is prime} ∧ z \text{ is prime} ∧ x = y + z ∧ x \text{ is even})}
\end{gather}\]

<p>그렇다면 $\Delta_0$에 속하지 않는 $\Sigma_1$ 명제는 어떻게 생겼을까? 한 가지 답은 <strong>정지 문제</strong>에서 찾을 수 있다.</p>

<p>먼저 $\mathrm{HaltsIn}(x, n)$를, “괴델 수가 $x$인 튜링 기계”가 $n$회의 연산 이내에 출력값을 내놓는지를 판별하는 술어라고 하자. 이 술어는 <strong>클레이니 술어</strong>로부터 쉽게 정의할 수 있으며, 클레이니 술어는 $\Sigma_0$임이 알려져 있다. 예를 들어 3의 제곱을 2회의 연산으로 계산하는 튜링 기계의 괴델 수가 $123$이라면 $\mathrm{HaltsIn}(123, 3)$은 참이지만 $\mathrm{HaltsIn}(123, 1)$는 거짓이다.</p>

<p>이제 다음 명제를 고려하자.</p>

\[\phi_1(x): \exists y \;[ \mathrm{HaltsIn}(x, y) ]\]

<p>위 명제가 말하는 바는, 괴델 수가 $x$인 튜링 기계가 언젠가 정지한다는 것이다. 즉, 위 명제는 정지 문제와 동치이다. 그런데 정지 문제는 결정 불가능하다. 앞서 $\Delta_0$ 명제는 모두 결정 가능함을 보았으므로, $\phi$는 $\Delta_0$에 속하지 않는 $\Sigma_1$ 명제이다.</p>

<p>다른 예시로, 다음 명제를 고려하자.</p>

\[\phi_2(x): \exists y \; [ \mathrm{Proves}(x, y) ]\]

<p>여기서 $\mathrm{Proves}(x, y)$는 “괴델 수가 $x$인 문장의 증명”의 괴델 수가 $y$일 때 참인 술어이다. 즉, $\phi_2(x)$는 괴델 수가 $x$인 문장이 증명 가능하다는 술어이다. 그런데 이 술어는 결정 가능하지 않다. 만약 $\phi_2$가 결정 가능하다면 (PA가 무모순적이라는 가정 하에) $\phi_2(\ulcorner 0 = 1 \urcorner)$이 거짓이라는 증명이 PA에 존재하게 되어 괴델의 불완전성 정리와 상충하기 때문이다.</p>

<h3 id="23-pi_1-명제">2.3. $\Pi_1$ 명제</h3>

<p>$\Sigma_1$ 명제가 재귀적으로 열거 가능한 명제들의 모임이라면, $\Pi_1$ 명제는 <strong>쌍대-재귀적으로 열거 가능한(co-recursively enumerable)</strong> 명제들의 모임이다. 즉 $\Pi_1$의 문장은 거짓이라면 결정 가능하지만 참이라면 결정 가능성이 보장되지 않는다. 예를 들어 다음 두 명제는 $\Delta_0$가 아닌 $\Pi_1$ 문장이다.</p>

\[\begin{gather}
\phi_3(x): \forall y \;[ \lnot \mathrm{HaltsIn}(x, y) ] \\
\phi_4(x): \forall y \; [ \lnot \mathrm{Proves}(x, y) ]
\end{gather}\]

<p>$\Sigma_1$의 경우와 달리, $\Pi_1$은 완전하지 않다. $\Sigma_1$ 문장의 부정이 $\Pi_1$이기 때문에, $\Pi_1$ 또한 완전하다면 $\Sigma_1 = \Pi_1=$ (결정 가능한 명제들의 모임)이 되기 때문이다.</p>

<blockquote>
  <p><strong>정리.</strong> 참인 $\Pi_1$ 문장들의 집합은 완전하지 않다.</p>
</blockquote>

<h3 id="24-delta_1-명제">2.4. $\Delta_1$ 명제</h3>

<p>$\Delta_1$ 명제는 $\Sigma_1$과 $\Pi_1$에 모두 속한다. 따라서 $\Delta_1$은 <strong>결정 가능한</strong> 명제들의 모임이다. 앞서 본 테트레이션은 $\Delta_0$가 아닌 $\Delta_1$ 명제이다.</p>

<h2 id="3-한-단계-더-올라가기">3. 한 단계 더 올라가기</h2>

<blockquote>
  <p><strong>정의.</strong></p>

\[\begin{gather}
\Sigma_2 := \{ \exists x_1 \cdots \exists x_n \;\phi : \phi \in \Pi_1 \}\\
\Pi_2 := \{ \forall x_1 \cdots \forall x_n \;\phi : \phi \in \Sigma_1 \}\\
\Delta_2 := \Sigma_2 \cap \Pi_2
\end{gather}\]
</blockquote>

<p>이제 패턴이 보일 거라 생각한다. $\Sigma_2$ 명제의 예시로, 다음을 보자.</p>

\[\phi_5(x) : \exists y \; [ \mathrm{DoesNotHaltOn}(x, y)]\]

<p>여기서 $\mathrm{DoesNotHaltOn}(x, y)$는, “괴델 수가 $x$인 튜링 기계”에 $y$를 입력했을 때 정지하지 않으면 참인 술어이다. 앞선 논의로부터 $\mathrm{DoesNotHaltOn}$이 $\Pi_1$임을 어렵지 않게 알 수 있다.</p>

<blockquote>
  <p><strong>정리.</strong> $\phi_5 \notin \Pi_1$</p>
</blockquote>

<p><strong>증명.</strong> $\phi_5 \in \Pi_1$이라고 가정하자. 우리의 목표는 이 가정이 “참인 $\Pi_1$ 문장들의 집합은 완전하다”를 시사함을 보이는 것이다.</p>

<p>$\psi(x)$가 임의의 $\Delta_0$ 명제라고 하자. $\theta : \forall x \;\psi(x)$는 $\Pi_1$ 문장이다. 다음의 튜링 기계 $M$을 생각하자.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if ψ(x):
   return 1;

while True:
</code></pre></div></div>

<p>이 튜링 기계는 값 $x$에 대해 $\psi(x)$가 참이면 정지하고 거짓이면 정지하지 않는다. 따라서 $\theta$가 참이라는 것은 모든 $x$에 대해 $M$이 정지한다는 것과 동치이며, 이것은 $\phi_5(\ulcorner M \urcorner)$이 거짓임과 동치이다. 그리고 가정에 의해 $\phi_5 \in \Pi_1$이므로, $\phi_5(\ulcorner M \urcorner)$이 거짓이라면 $\mathsf{PA} \vdash \lnot \phi(\ulcorner M \urcorner)$이다. 즉, $\mathsf{PA} \vdash \theta$가 되어 모든 참인 $\Pi_1$ 문장은 증명 가능하게 된다. 이것은 모순이다. ■</p>

<p><em>Remark.</em> 엄밀히는 위의 증명이 PA 내에서 표현 가능함을 보여야 한다.</p>

<p>앞서 $\Sigma_1$ 명제는 참일 때 결정 가능하고, $\Pi_1$ 명제는 거짓일 때 결정 가능하다고 했다. 그런데 $\Sigma_2$ 문장은 $\forall$과 $\exists$가 섞여 있기 때문에, 참일 때에도, 거짓일 때에도 결정이 불가능한 문장이 있을 수 있다.</p>

<h3 id="31-오라클">3.1. 오라클</h3>

<blockquote>
  <p><strong>정의.</strong> $\mathcal{O}$가 단 한 번의 연산으로 문제 $P$의 결과를 구할 수 있을 때 $\mathcal{O}$을 $P$의 <strong>오라클</strong>이라고 한다.</p>
</blockquote>

<p>예를 들어 정지 문제의 오라클은 주어진 튜링 기계의 정지 연부를 단 한 번의 연산으로 알아낼 수 있는, 그야말로 신적인 존재다.</p>

<p>산술 위계를 오르는 것은 점점 더 강한 오라클이 주어지는 것과 같다. 앞서 $\Sigma_1$ 명제의 예시로 다음을 보았다.</p>

\[\phi_1(x): \exists y \;[ \mathrm{HaltsIn}(x, y) ]\]

<p>그런데 만약 정지 문제 오라클 $\mathcal{O}$가 주어졌다면, $\phi_1$은 $\Delta_0$ 명제로 단순하게 표현 가능하다.</p>

\[\phi_1(x) : \mathcal{O}(x)\]

<p>또한 앞서 $\Sigma_2$ 명제의 예시로 다음을 보았다.</p>

\[\phi_5(x) : \exists y \; [ \mathrm{DoesNotHaltOn}(x, y)]\]

<p>정지 문제 오라클 $\mathcal{O}$가 주어졌다면, $\phi_5$는 $\Sigma_1$ 명제로 표현 가능하다.</p>

\[\phi_5(x): \exists y \; \lnot \mathcal{O}(x|_y)\]

<p>여기서 $x|_y$는 괴델 수가 $x$인 튜링 기계에 $y$를 입력한 상태의 괴델 수이다. 즉, $\Sigma_2$ 명제는 정지 문제의 오라클이 주어졌을 때 $\Sigma_1$ 명제로 환원된다. 비슷한 원리로, $\Pi_2$ 명제와 $\Delta_2$ 명제는 각각 정지 문제의 오라클이 주어졌을 때 $\Pi_1$ 명제와 $\Delta_1$ 명제로 환원된다.</p>

<p>나아가 <strong>2차 오라클</strong>을 정의할 수 있다. 2차 정지 문제 오라클은, 정지 문제 오라클을 사용하는 튜링 기계들에 대한 정지 문제 오라클이다. 예를 들어 $\mathcal{O}$가 다음 코드의 정지 여부를 판단하는 데 그치는 데 반해,</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for x &gt; 0:
   for y &gt; 0:
      for z &gt; 0:
         for n &gt; 2:
            if x^n + y^n == z^n:
               return True;
return False;
</code></pre></div></div>

<p>$\mathcal{O}^2$은 다음 코드의 정지 여부를 판단할 수도 있다. 다음의 코드는 NP 튜링 기계의 괴델 수 $x$를 입력받았을 때, $x$와 출력이 일치하는 P 튜링 기계가 존재하면 정지하고 존재하지 않으면 정지하지 않는다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let x ∈ NP;
for y ∈ P:
   if !Halts(
      let z = 0
      while x(z) == y(z):
         z = z + 1
   ):
      return 1; // x가 P에 속하는 NP일 때 정지
</code></pre></div></div>

<p>일반적으로 다음이 성립한다.</p>

<blockquote>
  <p><strong>정리.</strong> $\Pi_n, \Sigma_n, \Delta_n$의 명제들은 $k$차 오라클이 주어졌을 때 각각 $\Pi_{n - k}, \Sigma_{n - k}, \Delta_{n - k}$의 명제들이 된다.</p>
</blockquote>

  </div>
  <div style="margin-bottom: 6em"></div>
  
    <div class="post fade-in-section" data-lang="en" style="display: none">
      <h1 class="post-title">
        <a href="/2025/02/07/arithmetic-hierarchy/en"> Arithmetic Hierarchy </a>
      </h1>
    <span class="post-date">07 Feb 2025</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/mathematics/'">
        Mathematics
      </div>
      
      <div class="tag" onclick="location.href='/tags/logic/'">
        Logic
      </div>
      
    </div>
     <blockquote>
  <p>This post was machine translated and has not yet been proofread. It may contain minor errors or unnatural expressions. Proofreading will be done in the near future.</p>
</blockquote>

<p><img src="/public/arithmetic-hierarchy.png" width="340px" style="margin: 2em auto;" /></p>

<blockquote>
  <p><strong>Warning.</strong> This article was written informally and may therefore lack rigour or even contain incorrect content.</p>
</blockquote>

<p>The <strong>arithmetic hierarchy</strong> is a classification of propositions in arithmetic — more precisely, first-order Peano arithmetic — according to the complexity of their quantifiers. The arithmetic hierarchy is a central concept in proof theory and computational complexity theory, and is also related to descriptive set theory.</p>

<h2 id="1-delta_0-propositions">1. $\Delta_0$ Propositions</h2>

<h3 id="11-definition">1.1. Definition</h3>

<blockquote>
  <p><strong>Definition.</strong> $\Sigma_0 = \Pi_0 = \Delta_0$ is the set of propositions containing only bounded quantifiers.</p>
</blockquote>

<p>Why the same class of propositions is referred to by three names will become clear shortly. In this article, unless there is a specific reason otherwise, we shall use $\Delta_0$ as the representative name among the three.</p>

<p>For example, the following four propositions are all $\Delta_0$.</p>

\[\begin{gather}
\phi_1 : 0 = 1\\
\phi_2(x) : \exists y &lt; x \; [y + y = x] \\
\phi_3(x, y) : \exists z \leq y \;[ xz = y ] \\
\end{gather}\]

<p>$\phi_1$ is a false statement. $\phi_2$ is true when $x$ is even, and $\phi_3$ is true when $x$ is a divisor of $y$.</p>

<p>Since $\Delta_0$ propositions have bounded quantifiers, it is possible to determine whether an arbitrary $x$ satisfies the corresponding proposition using a Turing machine. For instance, a Turing machine that determines whether $x$ satisfies $\phi_2$ is as follows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for y &lt; x:
   if y + y == x:
      return true;

return false;
</code></pre></div></div>

<p>The above Turing machine halts within $x$ iterations. Therefore, $\Delta_0$ propositions are <strong>decidable</strong>, <strong>recursive</strong>, or <strong>computable</strong> (the three expressions are synonymous). However, as we shall explain in detail later, not all decidable propositions are $\Delta_0$.</p>

<p>According to Gödel’s representability theorem, decidable true propositions are provable. In this article, when we say that $\phi$ is ‘true’, we mean $\mathcal{N} \vDash \phi$ for the standard model of arithmetics $\mathcal{N}$, rather than $\mathsf{PA} \vDash \phi$.</p>

<p>The following holds:</p>

<blockquote>
  <p><strong>Theorem.</strong> The set of true $\Delta_0$ sentences is complete. (That is, if $\phi$ is a true $\Delta_0$ sentence, then $\mathsf{PA} \vdash \phi$.)</p>
</blockquote>

<h3 id="12-delta_0-in-computational-theory">1.2. $\Delta_0$ in Computational Theory</h3>

<p>From a programming language perspective, $\Delta_0$ sentences correspond to the set of code that permits only the following:</p>

<ul>
  <li>Conditional statements</li>
  <li>Bounded loops</li>
  <li>Addition and multiplication</li>
</ul>

<p>It should be noted that <em>unbounded loops</em> and <em>variable reassignment</em> are not permitted. For example, the following code demonstrates that primality testing is $\Delta_0$:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for y &lt; x:
  for z &lt;= y:
    if yz == x:
      return false;

return true;
</code></pre></div></div>

<p>However, the following code that computes $x^y$ does not correspond to $\Delta_0$:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let a = 1
for 1&lt;= z &lt;= y:
   a = a * x

return a
</code></pre></div></div>

<p>So is exponentiation not $\Delta_0$? Not necessarily. Although complex, there are <a href="https://math.stackexchange.com/questions/5032077/how-to-express-exponentiation-with-a-delta-0-formula">methods</a> to express exponentiation with a $\Delta_0$ proposition. This case demonstrates that determining whether a given operation or predicate is $\Delta_0$ can be intricate. For instance, the following is known:</p>

<blockquote>
  <p><strong>Theorem.</strong> Factorial is $\Delta_0$, but tetration is not $\Delta_0$.</p>
</blockquote>

<p>However, tetration is decidable. Therefore, not all decidable propositions are $\Delta_0$.</p>

<h2 id="2-moving-up-one-level">2. Moving Up One Level</h2>

<blockquote>
  <p><strong>Definition.</strong></p>

\[\begin{gather}
\Sigma_1 := \{ \exists x_1 \cdots \exists x_n \;\phi : \phi \in \Pi_0 \}\\
\Pi_1 := \{ \forall x_1 \cdots \forall x_n \;\phi : \phi \in \Sigma_0 \}\\
\Delta_1 := \Sigma_1 \cap \Pi_1
\end{gather}\]
</blockquote>

<h3 id="21-sigma_1-propositions">2.1. $\Sigma_1$ Propositions</h3>

<p>The following propositions are $\Sigma_1$:</p>

\[\begin{gather}
\phi_1(x): \exists y \; \underbrace{[y^2 + y + 1 = x]}_{\Pi_0}\\
\phi_2(x): ∃y\; ∃z\; \underbrace{(y \text{ is prime} ∧ z \text{ is prime} ∧ x = y + z ∧ x \text{ is even})}_{\Pi_0}
\end{gather}\]

<p>$\phi_1$ is true in the set $\lbrace 1, 3, 7, 13, \ldots\rbrace $. $\phi_2$ is Goldbach’s conjecture; it is not known whether all $x$ satisfy this.</p>

<p>$\Sigma_1$ is the collection of <strong>recursively enumerable</strong> sets. That is, if $\phi \in \Sigma_1$, then there exists a Turing machine $M$ such that:</p>

<ul>
  <li>If $\phi(c)$ is true, then $M$ is guaranteed to decide $\phi(c)$.</li>
  <li>If $\phi(c)$ is false, then $M$ is not guaranteed to decide $\phi(c)$.</li>
</ul>

<p>For example, the following Turing machine shows that $\phi_2$ is recursively enumerable:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for y &gt; 1:
   for z &gt; 1:
      if isPrime(y) &amp; isPrime(z) &amp; x = y + z &amp; isEven(x):
         return true;

return false;
</code></pre></div></div>

<p>Although there is a <code class="language-plaintext highlighter-rouge">return false</code> statement, since there is no <code class="language-plaintext highlighter-rouge">break</code> statement to exit the loop, <code class="language-plaintext highlighter-rouge">return false</code> is unreachable. That is, if $\phi_2(c)$ is true, the above Turing machine returns true, but if it is false, it falls into an infinite loop.</p>

<p>If $\phi \in \Sigma_1$ is a sentence that is true in the standard model of arithmetics, then $\mathsf{PA} \vdash \phi$. A proposition of the form $\phi : \exists x \; \psi(x)$ being true in the standard model of arithmetics means that $\psi(c)$ is true for some $c \in \mathbb{N}$, and since $\psi(c)$ is a true $\Pi_0$ sentence, it is provable. Therefore, the following holds:</p>

<blockquote>
  <p><strong>Theorem.</strong> The set of true $\Sigma_1$ sentences is complete.</p>
</blockquote>

<h3 id="22-sigma_1-setminus-delta_0-propositions">2.2. $\Sigma_1 \setminus \Delta_0$ Propositions</h3>

<p>However, I have in fact been misleading the reader thus far. The propositions I listed earlier as examples of $\Sigma_1$ can actually be written as $\Delta_0$:</p>

\[\begin{gather}
\phi_1: \exists y&lt;x \;{[y^2 + y + 1 = x]}\\
\phi_2(x): ∃y&lt;x\; ∃z&lt;x\; {(y \text{ is prime} ∧ z \text{ is prime} ∧ x = y + z ∧ x \text{ is even})}
\end{gather}\]

<p>So what do propositions that strictly belong to $\Sigma_1$ look like? One answer can be found in the <strong>halting problem</strong>.</p>

<p>First, let $\mathrm{HaltsIn}(x, n)$ be a predicate that determines whether “the Turing machine with Gödel number $x$” produces an output within $n$ operations. This predicate can be easily defined from the <strong>Kleene predicate</strong>, and the Kleene predicate is known to be $\Sigma_0$. For example, if the Gödel number of a Turing machine that computes the square of 3 in 2 operations is $123$, then $\mathrm{HaltsIn}(123, 3)$ is true but $\mathrm{HaltsIn}(123, 1)$ is false.</p>

<p>Now consider the following proposition:</p>

\[\phi_1(x): \exists y \;[ \mathrm{HaltsIn}(x, y) ]\]

<p>What this proposition states is that the Turing machine with Gödel number $x$ eventually halts. That is, the above proposition is equivalent to the halting problem. However, the halting problem is undecidable. Since we showed earlier that all $\Delta_0$ propositions are decidable, $\phi$ is a $\Sigma_1$ proposition that does not belong to $\Delta_0$.</p>

<p>As another example, consider the following proposition:</p>

\[\phi_2(x): \exists y \; [ \mathrm{Proves}(x, y) ]\]

<p>Here, $\mathrm{Proves}(x, y)$ is a predicate that is true when the Gödel number of “a proof of the sentence with Gödel number $x$” is $y$. That is, $\phi_2(x)$ is a predicate stating that the sentence with Gödel number $x$ is provable. However, this predicate is not decidable. If $\phi_2$ were decidable, then (under the assumption that PA is consistent) there would exist a proof in PA that $\phi_2(\ulcorner 0 = 1 \urcorner)$ is false, which would conflict with Gödel’s incompleteness theorem.</p>

<h3 id="23-pi_1-propositions">2.3. $\Pi_1$ Propositions</h3>

<p>If $\Sigma_1$ propositions are the collection of recursively enumerable propositions, then $\Pi_1$ propositions are the collection of <strong>co-recursively enumerable</strong> propositions. That is, a $\Pi_1$ sentence is decidable if false, but not necessarily decidable if true. For example, the following two propositions are $\Pi_1$ sentences that are not $\Delta_0$:</p>

\[\begin{gather}
\phi_3(x): \forall y \;[ \lnot \mathrm{HaltsIn}(x, y) ] \\
\phi_4(x): \forall y \; [ \lnot \mathrm{Proves}(x, y) ]
\end{gather}\]

<p>Unlike the case of $\Sigma_1$, $\Pi_1$ is not complete. Since the negation of a $\Sigma_1$ sentence is $\Pi_1$, if $\Pi_1$ were also complete, then $\Sigma_1 = \Pi_1 =$ (collection of decidable propositions).</p>

<blockquote>
  <p><strong>Theorem.</strong> The set of true $\Pi_1$ sentences is not complete.</p>
</blockquote>

<h3 id="24-delta_1-propositions">2.4. $\Delta_1$ Propositions</h3>

<p>$\Delta_1$ propositions belong to both $\Sigma_1$ and $\Pi_1$. Therefore, $\Delta_1$ is the collection of <strong>decidable</strong> propositions. The tetration we saw earlier is a $\Delta_1$ proposition that is not $\Delta_0$.</p>

<h2 id="3-moving-up-another-level">3. Moving Up Another Level</h2>

<blockquote>
  <p><strong>Definition.</strong></p>

\[\begin{gather}
\Sigma_2 := \{ \exists x_1 \cdots \exists x_n \;\phi : \phi \in \Pi_1 \}\\
\Pi_2 := \{ \forall x_1 \cdots \forall x_n \;\phi : \phi \in \Sigma_1 \}\\
\Delta_2 := \Sigma_2 \cap \Pi_2
\end{gather}\]
</blockquote>

<p>I believe the pattern should now be clear. As an example of a $\Sigma_2$ proposition, consider the following:</p>

\[\phi_5(x) : \exists y \; [ \mathrm{DoesNotHaltOn}(x, y)]\]

<p>Here, $\mathrm{DoesNotHaltOn}(x, y)$ is a predicate that is true if “the Turing machine with Gödel number $x$” does not halt when given input $y$. From the preceding discussion, it is not difficult to see that $\mathrm{DoesNotHaltOn}$ is $\Pi_1$.</p>

<blockquote>
  <p><strong>Theorem.</strong> $\phi_5 \notin \Pi_1$</p>
</blockquote>

<p><strong>Proof.</strong> Suppose $\phi_5 \in \Pi_1$. Our goal is to show that this assumption implies “the set of true $\Pi_1$ sentences is complete”.</p>

<p>Let $\psi(x)$ be an arbitrary $\Delta_0$ proposition. Then $\theta : \forall x \;\psi(x)$ is a $\Pi_1$ sentence. Consider the following Turing machine $M$:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if ψ(x):
   return 1;

while True:
</code></pre></div></div>

<p>This Turing machine halts for value $x$ if $\psi(x)$ is true and does not halt if it is false. Therefore, $\theta$ being true is equivalent to $M$ halting for all $x$, which is equivalent to $\phi_5(\ulcorner M \urcorner)$ being false. By assumption, $\phi_5 \in \Pi_1$, so if $\phi_5(\ulcorner M \urcorner)$ is false, then $\mathsf{PA} \vdash \lnot \phi(\ulcorner M \urcorner)$. That is, $\mathsf{PA} \vdash \theta$, making all true $\Pi_1$ sentences provable. This is a contradiction. ■</p>

<p><em>Remark.</em> Strictly speaking, one should show that the above proof is expressible within PA.</p>

<p>We said earlier that $\Sigma_1$ propositions are decidable when true, and $\Pi_1$ propositions are decidable when false. However, since $\Sigma_2$ sentences have mixed $\forall$ and $\exists$ quantifiers, there may be sentences that are undecidable both when true and when false.</p>

<h3 id="31-oracles">3.1. Oracles</h3>

<blockquote>
  <p><strong>Definition.</strong> When $\mathcal{O}$ can obtain the result of problem $P$ in a single operation, we call $\mathcal{O}$ an <strong>oracle</strong> for $P$.</p>
</blockquote>

<p>For example, an oracle for the halting problem is a truly divine entity that can determine whether a given Turing machine halts in a single operation.</p>

<p>Ascending the arithmetic hierarchy is equivalent to being given increasingly powerful oracles. We saw earlier the following as an example of a $\Sigma_1$ proposition:</p>

\[\phi_1(x): \exists y \;[ \mathrm{HaltsIn}(x, y) ]\]

<p>However, if a halting problem oracle $\mathcal{O}$ were given, $\phi_1$ could be expressed simply as a $\Delta_0$ proposition:</p>

\[\phi_1(x) : \mathcal{O}(x)\]

<p>Also, we saw earlier the following as an example of a $\Sigma_2$ proposition:</p>

\[\phi_5(x) : \exists y \; [ \mathrm{DoesNotHaltOn}(x, y)]\]

<p>If a halting problem oracle $\mathcal{O}$ were given, $\phi_5$ could be expressed as a $\Sigma_1$ proposition:</p>

\[\phi_5(x): \exists y \; \lnot \mathcal{O}(x|_y)\]

<p>Here, $x|_y$ is the Gödel number of the state where input $y$ is given to the Turing machine with Gödel number $x$. That is, $\Sigma_2$ propositions reduce to $\Sigma_1$ propositions when given an oracle for the halting problem. By similar principles, $\Pi_2$ and $\Delta_2$ propositions reduce to $\Pi_1$ and $\Delta_1$ propositions, respectively, when given an oracle for the halting problem.</p>

<p>Furthermore, we can define <strong>second-order oracles</strong>. A second-order halting problem oracle is a halting problem oracle for Turing machines that use halting problem oracles. For example, whilst $\mathcal{O}$ is limited to determining whether the following code halts:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for x &gt; 0:
   for y &gt; 0:
      for z &gt; 0:
         for n &gt; 2:
            if x^n + y^n == z^n:
               return True;
return False;
</code></pre></div></div>

<p>$\mathcal{O}^2$ can also determine whether the following code halts. The following code takes as input the Gödel number $x$ of an NP Turing machine, halts if there exists a P Turing machine whose output matches $x$, and does not halt if no such machine exists:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let x ∈ NP;
for y ∈ P:
   if !Halts(
      let z = 0
      while x(z) == y(z):
         z = z + 1
   ):
      return 1; // halts when x is an NP that belongs to P
</code></pre></div></div>

<p>In general, the following holds:</p>

<blockquote>
  <p><strong>Theorem.</strong> Propositions in $\Pi_n$, $\Sigma_n$, $\Delta_n$ become propositions in $\Pi_{n-k}$, $\Sigma_{n-k}$, $\Delta_{n-k}$, respectively, when given a $k$-th order oracle.</p>
</blockquote>

  </div>
  <div style="margin-bottom: 6em"></div>
  
    <div class="post fade-in-section" data-lang="ko" style="display: none">
      <h1 class="post-title">
        <a href="/2025/02/05/order"> 곱군과 위수에 관한 노트: 페르마 소수 정리와 윌슨의 정리 </a>
      </h1>
    <span class="post-date">05 Feb 2025</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/수학/'">
        수학
      </div>
      
      <div class="tag" onclick="location.href='/tags/대수학/'">
        대수학
      </div>
      
    </div>
     <h3 id="remarks">Remarks</h3>

<table>
  <thead>
    <tr>
      <th><strong>곱군</strong></th>
      <th><strong>합군</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1이 항등원</td>
      <td>0이 항등원</td>
    </tr>
    <tr>
      <td>$x$의 위수가 $r$일 때, $x^r = 1$</td>
      <td>$x$의 위수가 $r$일 때, $rx = 0$</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>소수 $p$에 대해 $p - 1$에 대한 정보가 주어졌다면 위수가 $p - 1$인 곱군 $(\mathbb{Z}/p\mathbb{Z})^\times$을 생각해 보자.</li>
  <li>유한체의 곱군은 순환군이다.</li>
  <li>순환적 곱군 $G$에 대해 $nm \mid |G|$는, $x^{nm} = 1$이지만 $x^n, x^m \neq 1$인 원소 $x$의 존재성과 동치이다.</li>
  <li>위수는 주기와 다르다. 일반적으로 <strong>(주기) = (위수) + 1</strong>이다.</li>
</ul>

<h3 id="페르마-소수-정리">페르마 소수 정리</h3>

<blockquote>
  <p><strong>정리.</strong> 소수 $p$가 두 정수 $a, b$에 대해 $p = a^2 + b^2$ 꼴로 나타내어질 필요충분조건은 $p \bmod 1 = 4$인 것이다.</p>
</blockquote>

<p><strong>증명.</strong></p>

<p>(⇒) 자명</p>

<p>(⇐) $G = (\mathbb{Z}/p\mathbb{Z})^\times$라고 하자. 조건에 의해 $4 \mid |G|$이다. 따라서 $n^4 = 1$이지만 $n^2 \neq 1$인 원소 $n$이 존재한다. 즉, $n^2 = -1$이다. 따라서 $p \mid n^2 + 1$이다. 이제 $\mathbb{Z}[i]$에서 생각해 보면 $p \mid (n + i)(n - i)$이다. 만약 $p$가 $\mathbb{Z}[i]$에서 기약이었다면 $p \mid n + i$ 또는 $p \mid n - i$인데 둘 다 불가능하다. 따라서 $p$는 기약이 아니며, 켤레성에 의해</p>

\[p = (a + bi)(a - bi) = a^2 + b^2\]

<p>이다. ■</p>

<h3 id="윌슨의-정리">윌슨의 정리</h3>

<blockquote>
  <p><strong>정리.</strong> $p$가 소수일 필요충분조건은 $(p - 1)! \equiv -1 \mod p$인 것이다.</p>
</blockquote>

<p><strong>증명.</strong></p>

<p>(⇒) $G = (\mathbb{Z}/p\mathbb{Z})^\times$라고 하자. $G$의 원소를 모두 곱한 값은 $(p - 1)!$이다. $x^2 = 1$의 근인 $\pm 1$을 제외한 $G$의 모든 원소는 자기 자신을 역원으로 가지지 않는다. 따라서 $(p - 1)! \equiv -1$이다.</p>

<p>(⇐) $N = (p - 1)! + 1$이라고 하자. 조건에 의해 $p \mid N$이다. 만약 $p$가 소수가 아니라면 어떤 소수 $q &lt; p$에 대해 $q \mid N$이다. 그러나 $N \bmod q = 1$이므로 모순이다. ■</p>

  </div>
  <div style="margin-bottom: 6em"></div>
  
    <div class="post fade-in-section" data-lang="en" style="display: none">
      <h1 class="post-title">
        <a href="/2025/02/05/order/en"> Notes on Multiplicative Groups and Order: Fermat's Theorem on Primes and Wilson's Theorem </a>
      </h1>
    <span class="post-date">05 Feb 2025</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/mathematics/'">
        Mathematics
      </div>
      
      <div class="tag" onclick="location.href='/tags/algebra/'">
        Algebra
      </div>
      
    </div>
     <h3 id="remarks">Remarks</h3>

<table>
  <thead>
    <tr>
      <th><strong>Multiplicative Group</strong></th>
      <th><strong>Additive Group</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1 is the identity element</td>
      <td>0 is the identity element</td>
    </tr>
    <tr>
      <td>When the order of $x$ is $r$, $x^r = 1$</td>
      <td>When the order of $x$ is $r$, $rx = 0$</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>For a prime $p$, if information about $p - 1$ is given, consider the multiplicative group $(\mathbb{Z}/p\mathbb{Z})^\times$ of order $p - 1$.</li>
  <li>The multiplicative group of a finite field is cyclic.</li>
  <li>For a <em>cyclic</em> multiplicative group $G$, $nm \mid |G|$ is equivalent to the existence of an element $x$ such that $x^{nm} = 1$ but $x^n, x^m \neq 1$.</li>
  <li>Order is different from period. In general, <strong>(period) = (order) + 1</strong>.</li>
</ul>

<h3 id="fermats-theorem-on-primes">Fermat’s Theorem on Primes</h3>

<blockquote>
  <p><strong>Theorem.</strong> A prime $p$ can be expressed in the form $p = a^2 + b^2$ for two integers $a, b$ if and only if $p \equiv 1 \pmod{4}$.</p>
</blockquote>

<p><strong>Proof.</strong></p>

<p>(⇒) Trivial.</p>

<p>(⇐) Let $G = (\mathbb{Z}/p\mathbb{Z})^\times$. By the condition, $4 \mid |G|$. Therefore, there exists an element $n$ such that $n^4 = 1$ but $n^2 \neq 1$. That is, $n^2 = -1$. Hence, $p \mid n^2 + 1$. Now, considering in $\mathbb{Z}[i]$, we have $p \mid (n + i)(n - i)$. If $p$ were irreducible in $\mathbb{Z}[i]$, then $p \mid n + i$ or $p \mid n - i$ (note that the fact that $\mathbb{Z}[i]$ is UFD is used here) but both are impossible. Therefore, $p$ is not irreducible, and by conjugacy,</p>

\[p = (a + bi)(a - bi) = a^2 + b^2\]

<p>■</p>

<h3 id="wilsons-theorem">Wilson’s Theorem</h3>

<blockquote>
  <p><strong>Theorem.</strong> $p$ is prime if and only if $(p - 1)! \equiv -1 \pmod{p}$.</p>
</blockquote>

<p><strong>Proof.</strong></p>

<p>(⇒) Let $G = (\mathbb{Z}/p\mathbb{Z})^\times$. The product of all elements of $G$ is $(p - 1)!$. Except for $\pm 1$, which are the roots of $x^2 = 1$, all other elements of $G$ do not have themselves as their inverse. Therefore, $(p - 1)! \equiv -1$.</p>

<p>(⇐) Let $N = (p - 1)! + 1$. By the condition, $p \mid N$. If $p$ were not prime, then for some prime $q &lt; p$, we would have $q \mid N$. However, $N \equiv 1 \pmod{q}$, which is a contradiction. ■</p>

  </div>
  <div style="margin-bottom: 6em"></div>
  
    <div class="post fade-in-section" data-lang="ko" style="display: none">
      <h1 class="post-title">
        <a href="/2025/01/25/beta-function"> 베타 함수를 통한 페아노 산술에서의 괴델 수 정의 </a>
      </h1>
    <span class="post-date">25 Jan 2025</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/수학/'">
        수학
      </div>
      
      <div class="tag" onclick="location.href='/tags/논리학/'">
        논리학
      </div>
      
    </div>
     <p><strong>요약.</strong> 1차 페아노 산술은 술어에 대한 양화를 허용하지 않기 때문에 덧셈과 곱셈 공리를 별도로 요구한다. 그러나 지수나 계승 등의 추가적인 연산은 — 튜플을 페아노 산술에서 정의할 수 있는 한 — 별도의 공리 없이 정의 가능하다. 그리고 튜플은 베타 암호화를 통해 페아노 산술에서 정의 가능하기 때문에, 페아노 산술은 지수, 계승, 소인수분해, 나아가 괴델 수까지 형식화할 수 있다.</p>

<h2 id="1-서론">1. 서론</h2>

<blockquote>
  <p><strong>정의.</strong> <strong>페아노 산술(Peano arithmetics, PA)</strong>은 $(0, S, +, \cdot)$를 부호수(signature)로 가지는 이론으로, 공리는 다음과 같다.</p>

  <ol>
    <li>$\forall x : S(x) \neq 0$</li>
    <li>$\forall x, y : S(x) = S(y) \rightarrow x = y$</li>
    <li>$\forall x : x + 0 = x$</li>
    <li>$\forall x, y : x + S(y) = S(x + y)$</li>
    <li>$\forall x, y : x \cdot 0 = 0$</li>
    <li>$\forall x, y : x \cdot S(y) = (x \cdot y) + x$</li>
  </ol>

  <p>추가로 다음의 귀납 공리꼴(axiom schema)을 가진다. 임의의 1차 논리식 $\phi(x)$에 대해,</p>

  <p> 7. $\big[ \phi(0) \land \forall x \; [ \phi(x) \rightarrow \phi(S(x)) ] \big] \rightarrow \forall x \;\phi(x)$</p>
</blockquote>

<p>추가적으로 편의를 위해 $&lt;, -, \bmod$를 다음과 같이 정의한다.</p>

\[\begin{aligned}
&amp;x &lt; y : &amp;&amp;\exists z \neq 0\; [x + z = y]\\
&amp;x - y = z : &amp;&amp;x = y + z \\
&amp;x \bmod y = z: &amp;&amp; (z &lt; y) \land \exists q \;[ qy + z = x ]
\end{aligned}\]

<p>역사적으로 데데킨트가 처음 제시한 페아노 산술은 2차 논리 이론이었기 때문에 귀납 <em>공리꼴</em> 대신 귀납 <em>공리</em>가 있었다. 또한 3번부터 7번 공리가 없었다.</p>

<blockquote>
  <p><strong>정의.</strong> <strong>2차 논리 페아노 산술</strong>은 $(0, S)$를 부호수(signature)로 가지는 이론으로, 공리는 다음과 같다.</p>

  <ol>
    <li>$\forall x : S(x) \neq 0$</li>
    <li>$\forall x, y : S(x) = S(y) \rightarrow x = y$</li>
    <li>$\forall \phi \bigg[ \big[ \phi(0) \land \forall x \; [ \phi(x) \rightarrow \phi(S(x)) ] \big] \rightarrow \forall x \;\phi(x)\bigg]$</li>
  </ol>
</blockquote>

<p>나머지 공리가 불필요한 이유는, 2차 논리는 술어에 대한 양화를 허용하기 때문에 2차 논리식만으로 덧셈과 곱셈을 정의할 수 있기 때문이다. 예를 들어 $w = u + v$는 다음 논리식과 동치이다.</p>

\[\forall \phi \bigg[ \forall x, y, z \big[ \phi(x, 0, x) \land (\phi(x, S(y), z) \rightarrow \phi(x, y, S(z)) \big] \rightarrow \phi(u, v, w) \bigg]\]

<p>그러나 2차 논리는 수많은 수학적 · 철학적 허점을 가지는 것으로 드러났기 때문에 서두에서 소개한 1차 논리 페아노 산술이 표준으로 선택되었다. 이 선택의 함의는 첫째로 귀납 공리가 귀납 공리꼴이 된다는 것이고, 둘째는 덧셈과 곱셈을 별도의 공리를 통해 정의해야 한다는 것이다.</p>

<p>그런데 이런 의문이 남는다. 덧셈과 곱셈 말고 다른 연산은 따로 정의할 필요가 없는 것일까? 예를 들어 지수, 소인수분해, 계승과 같은 연산은 별도의 공리 없이 정의 가능할까? 나아가, 임의의 논리식을 자연수에 대응시키는 괴델 수 기법은 페아노 산술만으로 정의 가능할까?</p>

<h2 id="2-튜플">2. 튜플</h2>

<p>이 의문에 답하는 혜안은, <strong>튜플</strong>을 페아노 산술에서 정의할 수 있다면 기타 수많은 연산이 정의 가능해진다는 사실이다. 여기서 튜플이란 $(1, 4, 2)$와 같은 유한한 자연수의 나열을 말한다.</p>

<p>일례로 다음과 같은 술어와 함수들이 정의되어 있다고 가정하자.</p>

<ul>
  <li>$\mathrm{Tup}(\tau):$ $\tau$가 튜플이다.</li>
  <li>$\mathrm{At}(\tau, i):$ $\tau$가 튜플일 때, $\tau$의 $i$번째 자연수를 반환한다.</li>
  <li>$\mathrm{Len}(\tau):$ $\tau$의 길이를 반환한다.</li>
</ul>

<p>편의를 위해 $\mathrm{At}(\tau, i)$를 $\tau[i]$로 쓰도록 하자. 예를 들어 $\tau = (1, 4, 2)$라면 다음이 성립한다. (인덱스는 0부터 시작하는 것으로 생각한다)</p>

\[\mathrm{Tup}(\tau) \; \land \;  \mathrm{Len}(\tau) = 3 \;\land\; \tau[1] = 4\]

<p>튜플을 사용하면 다음과 같이 $z = x^y$를 정의할 수 있다.</p>

\[\forall \tau \bigg[ \big[ \mathrm{Tup}(\tau)\; \land \; \tau[0] = 1 \;\land \forall i &lt; y (\tau[i + 1] = \tau[i] \cdot x) \big] \rightarrow \tau[y] = z \bigg]\]

<h2 id="3-베타-암호화">3. 베타 암호화</h2>

<p>그렇다면 튜플을 덧셈과 곱셈, 그리고 1차 논리식만으로 정의할 수 있을까? 이에 대한 답은 <strong>“가능하다”</strong>이다. 아니나다를까역시나적시나 이 결과를 처음 증명한 사람은 괴델이다. 먼저 다음의 정리를 상기하자.</p>

<blockquote>
  <p><strong>중국인의 나머지 정리.</strong> $(n_1, \dots, n_k)$가 켤레서로소(pairwise coprime)라고 하자. $0 \leq r_i &lt; n_i$인 임의의 $(r_1, \dots, r_k)$에 대해 다음을 만족하는 수 $x$가 언제나 존재한다.</p>

\[x \bmod n_i = r_i\]
</blockquote>

<p>괴델의 아이디어는 중국인의 나머지 정리에서 $x$에 해당하는 수를 튜플 $(r_1, \dots, r_k)$의 코드로 생각하는 것이다. 그런데 여기에는 문제가 있다. $x$로부터 $(r_1, \dots, r_k)$를 복호화하기 위해서는 $(n_1, \dots, n_k)$가 주어져야 하는데, 이는 또다시 튜플을 요구하기 때문이다.</p>

<p>이 문제를 해결하기 위해 괴델은 다음의 보조정리를 꺼내든다.</p>

<blockquote>
  <p><strong>보조정리.</strong> $n!+ 1, 2n! + 1, \dots, n \cdot n! + 1$은 켤레서로소이다.</p>
</blockquote>

<p><strong>증명.</strong> $1 \leq a &lt; b \leq n$에 대해 $u = an! + 1, v = bn! + 1$이라고 하자. 유클리드 호제법에 의해,</p>

\[\mathrm{gcd}(u, v) = \mathrm{gcd}(u, v - u) = \mathrm{gcd}(an! + 1, (b - a)n!)\]

<p>이다. $(b - a)n!$의 모든 약수의 집합은 $\lbrace  1, 2, \dots, n\rbrace $이다. 그런데 이중 어느 원소도 $an! + 1$의 약수가 아니므로 $\mathrm{gcd}(an! + 1, (b - a)n!) = \mathrm{gcd}(u, v) = 1$이다. □</p>

<p>이제 우리는 튜플을 <strong>순서쌍</strong>으로서 정의할 수 있다.</p>

<blockquote>
  <p><strong>정의.</strong> 튜플 $(r_1, \dots, r_k)$를 다음과 같이 순서쌍 $\langle a, b \rangle$로 표현한다.</p>

  <ul>
    <li>$b = n! \quad \text{where} \quad n = \max(r_1, \dots, r_k, k)$</li>
    <li>$a \bmod (kb + 1) = r_k$</li>
  </ul>

  <p>단, $a$는 2번 조건을 만족하는 자연수 중 가장 작은 자연수로 선택한다.</p>
</blockquote>

<p>한편 튜플은 칸토어 대응을 통해 자연수로 표현이 가능하다.</p>

<blockquote>
  <p><strong>정의.</strong></p>

\[\langle a, b \rangle = \frac{(a + b)(a + b + 1)}{2} + b\]
</blockquote>

<p>이로써 우리는 튜플 $\tau$를 자연수 $n$으로 암호화(coding)할 수 있다. 그리고 역으로 $n$이 주어지면 덧셈, 곱셈, 그리고 나머지 연산만을 사용하여 $\tau$를 복호화해낼 수 있다. 그리고 나머지 연산은 덧셈, 곱셈, 그리고 1차 논리로부터 쉽게 정의가 가능하므로, 목표가 달성되었다.</p>

<p>역사적으로 괴델이 증명한 정리는 다음과 같다.</p>

<blockquote>
  <p><strong>$\beta$-함수 보조정리.</strong> 임의의 자연수열 $(n_1, \dots, n_k)$에 대해, 어떤 자연수 $a, b$가 존재하여 $1 \leq i \leq k$에 대해 $\beta(a, b, i) = n_i$이다. 여기서 $\beta$는 다음과 같이 정의된 함수이다.</p>

\[\beta(x, y, i) = x \bmod (iy + 1)\]
</blockquote>

<p>이런 이유로 지금까지의 과정을 <strong>베타 암호화(Beta coding)</strong>라고 부른다. 괴델은 베타 암호화를 이용하여 지수 연산과 소인수분해를 PA에서 성공적으로 정의했으며, 이로부터 괴델 수와 비롯된 여러 술어를 PA에서 형식화할 수 있었다. 제목에서 드러나다시피 원래 이 글의 목표는 이 과정을 모두 개괄하는 것이었으나 때늦게 찾아온 필자의 귀찮음 이슈와, 글을 여기까지 읽은 독자라면 이후 내용은 어렵지 않게 유추 가능하리라는 생각으로 이만 줄인다.</p>

  </div>
  <div style="margin-bottom: 6em"></div>
  
    <div class="post fade-in-section" data-lang="en" style="display: none">
      <h1 class="post-title">
        <a href="/2025/01/25/beta-function/en"> Defining Gödel Numbers in Peano Arithmetic via the Beta Function </a>
      </h1>
    <span class="post-date">25 Jan 2025</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/mathematics/'">
        Mathematics
      </div>
      
      <div class="tag" onclick="location.href='/tags/logic/'">
        Logic
      </div>
      
    </div>
     <p><strong>Summary.</strong> First-order Peano arithmetic does not permit quantification over predicates, hence it requires separate axioms to define addition and multiplication. However, further operations such as exponentiation and factorial are definable without separate axioms, provided that tuples can be defined in Peano arithmetic. And since tuples are definable in Peano arithmetic through beta encoding, Peano arithmetic can formalise exponentiation, factorial, prime factorisation, and ultimately Gödel numbering.</p>

<h2 id="1-introduction">1. Introduction</h2>

<blockquote>
  <p><strong>Definition.</strong> <strong>Peano arithmetic (PA)</strong> is a theory with signature $(0, S, +, \cdot)$, where the axioms are as follows:</p>

  <ol>
    <li>$\forall x : S(x) \neq 0$</li>
    <li>$\forall x, y : S(x) = S(y) \rightarrow x = y$</li>
    <li>$\forall x : x + 0 = x$</li>
    <li>$\forall x, y : x + S(y) = S(x + y)$</li>
    <li>$\forall x, y : x \cdot 0 = 0$</li>
    <li>$\forall x, y : x \cdot S(y) = (x \cdot y) + x$</li>
  </ol>

  <p>Additionally, it has the following induction axiom schema. For any first-order formula $\phi(x)$:</p>

  <p> 7. $\big[ \phi(0) \land \forall x \; [ \phi(x) \rightarrow \phi(S(x)) ] \big] \rightarrow \forall x \;\phi(x)$</p>
</blockquote>

<p>For convenience, we define $&lt;, -, \bmod$ as follows:</p>

\[\begin{aligned}
&amp;x &lt; y : &amp;&amp;\exists z \neq 0\; [x + z = y]\\
&amp;x - y = z : &amp;&amp;x = y + z \\
&amp;x \bmod y = z: &amp;&amp; (z &lt; y) \land \exists q \;[ qy + z = x ]
\end{aligned}\]

<p>Historically, the Peano arithmetic first presented by Dedekind was a second-order logic theory, hence it had an induction <em>axiom</em> rather than induction <em>axiom schema</em>.</p>

<blockquote>
  <p><strong>Definition.</strong> <strong>Second-order Peano arithmetic</strong> is a theory with signature $(0, S)$, where the axioms are as follows:</p>

  <ol>
    <li>$\forall x : S(x) \neq 0$</li>
    <li>$\forall x, y : S(x) = S(y) \rightarrow x = y$</li>
    <li>$\forall \phi \bigg[ \big[ \phi(0) \land \forall x \; [ \phi(x) \rightarrow \phi(S(x)) ] \big] \rightarrow \forall x \;\phi(x)\bigg]$</li>
  </ol>
</blockquote>

<p>Note that second-order formalisation omits axioms 3-6. The reason they are unnecessary is that second-order logic permits quantification over predicates, enabling addition and multiplication to be defined using second-order formulae alone. For instance, $w = u + v$ is equivalent to the following formula:</p>

\[\forall \phi \bigg[ \forall x, y, z \big[ \phi(x, 0, x) \land (\phi(x, S(y), z) \rightarrow \phi(x, y, S(z)) \big] \rightarrow \phi(u, v, w) \bigg]\]

<p>However, since second-order logic was found to have numerous mathematical and philosophical shortcomings, the first-order Peano arithmetic introduced at the beginning became the standard norm. The implications of the transition from second to first are, firstly, that the induction axiom becomes an axiom schema, and secondly, that addition and multiplication must be defined through separate axioms.</p>

<p>This raises the question: are there no other operations besides addition and multiplication that need separate definition? For example, can operations such as exponentiation, prime factorisation, and factorial be defined without additional axioms? Furthermore, can Gödel numbering, which maps formulae to natural numbers one-to-one, be defined using Peano arithmetic alone?</p>

<h2 id="2-tuples">2. Tuples</h2>

<p>The insight that answers this question is that if <strong>tuples</strong> can be defined in Peano arithmetic, then numerous other operations become definable. Here, a tuple refers to a finite sequence of natural numbers such as $(1, 4, 2)$.</p>

<p>For instance, suppose the following predicates and functions are defined:</p>

<ul>
  <li>$\mathrm{Tup}(\tau):$ $\tau$ is a tuple.</li>
  <li>$\mathrm{At}(\tau, i):$ When $\tau$ is a tuple, returns the $i$-th index of $\tau$.</li>
  <li>$\mathrm{Len}(\tau):$ Returns the length of $\tau$.</li>
</ul>

<p>For convenience, let us write $\mathrm{At}(\tau, i)$ as $\tau[i]$. For example, if $\tau = (1, 4, 2)$, then the following holds (assuming the index starts from 0):</p>

\[\mathrm{Tup}(\tau) \; \land \;  \mathrm{Len}(\tau) = 3 \;\land\; \tau[1] = 4\]

<p>Using tuples, we can define $z = x^y$ as follows:</p>

\[\forall \tau \bigg[ \big[ \mathrm{Tup}(\tau)\; \land \; \tau[0] = 1 \;\land \forall i &lt; y (\tau[i + 1] = \tau[i] \cdot x) \big] \rightarrow \tau[y] = z \bigg]\]

<h2 id="3-beta-encoding">3. Beta Encoding</h2>

<p>Can tuples be defined using only addition, multiplication, and first-order formulae? The answer is <strong>yes</strong>. As might be expected, it was Gödel who first proved this result. Let us first recall the following theorem:</p>

<blockquote>
  <p><strong>Chinese Remainder Theorem.</strong> Let $(n_1, \dots, n_k)$ be pairwise coprime. For any $(r_1, \dots, r_k)$ with $0 \leq r_i &lt; n_i$, there always exists a number $x$ satisfying:</p>

\[x \bmod n_i = r_i\]
</blockquote>

<p>Gödel’s idea was to think of the number $x$ from the Chinese Remainder Theorem as a code for the tuple $(r_1, \dots, r_k)$. However, there is a problem here. To decode $(r_1, \dots, r_k)$ from $x$, we need $(n_1, \dots, n_k)$ to be given, which itself is a tuple.</p>

<p>To solve this problem, Gödel produced the following lemma:</p>

<blockquote>
  <p><strong>Lemma.</strong> $n!+ 1, 2n! + 1, \dots, n \cdot n! + 1$ are pairwise coprime.</p>
</blockquote>

<p><strong>Proof.</strong> For $1 \leq a &lt; b \leq n$, let $u = an! + 1, v = bn! + 1$. By the Euclidean algorithm,</p>

\[\mathrm{gcd}(u, v) = \mathrm{gcd}(u, v - u) = \mathrm{gcd}(an! + 1, (b - a)n!)\]

<p>The set of all divisors of $(b - a)n!$ is $\lbrace  1, 2, \dots, n\rbrace $. Since none of these elements divides $an! + 1$, we have $\mathrm{gcd}(an! + 1, (b - a)n!) = \mathrm{gcd}(u, v) = 1$. □</p>

<p>With this lemma, instead of individually specifying $n$ pairwise coprime numbers, we can simply let $n$ be an arbitrary number, and from it, $n$ pairwise coprime numbers $n! + 1, 2n! + 1, \dots, n \cdot n! + 1$ can be chosen canonically. We can now define tuples as an <strong>ordered pair</strong>.</p>

<blockquote>
  <p><strong>Definition.</strong> We represent the tuple $(r_1, \dots, r_k)$ as an ordered pair $\langle a, b \rangle$ as follows:</p>

  <ul>
    <li>$b = n! \quad \text{where} \quad n = \max(r_1, \dots, r_k, k)$</li>
    <li>$a \bmod (kb + 1) = r_k$</li>
  </ul>

  <p>where $a$ is chosen to be the smallest natural number satisfying the second condition.</p>
</blockquote>

<p>Meanwhile, tuples can be represented as natural numbers through a well-defined injection from $\mathbb{N}^2$ to $\mathbb{N}$. The following is an example:</p>

\[\pi(a, b) = \frac{(a + b)(a + b + 1)}{2} + b\]

<p>Check that $b$ is injective. Hence we can define as follows:</p>

<blockquote>
  <p><strong>Definition.</strong></p>

\[\langle a, b \rangle = \frac{(a + b)(a + b + 1)}{2} + b\]
</blockquote>

<p>This establishes that we can encode a tuple $\tau$ as a natural number $n$. Conversely, given $n$, we can decode $\tau$ using only addition, multiplication, and the modulo operation. Since the modulo operation is easily definable from addition, multiplication, and first-order logic, our goal is achieved.</p>

<p>Historically, Gödel’s theorem was as follows:</p>

<blockquote>
  <p><strong>$\beta$-function Lemma.</strong> For any sequence of natural numbers $(n_1, \dots, n_k)$, there exist natural numbers $a, b$ such that $\beta(a, b, i) = n_i$ for $1 \leq i \leq k$, where $\beta$ is the function defined as follows:</p>

\[\beta(x, y, i) = x \bmod (iy + 1)\]
</blockquote>

<p>For this reason, the entire process is called <strong>beta encoding</strong>. Gödel used beta encoding to successfully define exponentiation and prime factorisation in PA, enabling the formalisation of Gödel numbers and various related predicates in PA. As indicated by the title, the original goal of this article was to provide an overview of this entire process. However, due to the author’s tardily arising laziness and the belief that readers who have come this far can easily infer the subsequent content, let me finish off here.</p>

  </div>
  <div style="margin-bottom: 6em"></div>
  
    <div class="post fade-in-section" data-lang="ko" style="display: none">
      <h1 class="post-title">
        <a href="/2025/01/25/los"> 워시의 정리 </a>
      </h1>
    <span class="post-date">25 Jan 2025</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/수학/'">
        수학
      </div>
      
      <div class="tag" onclick="location.href='/tags/논리학/'">
        논리학
      </div>
      
    </div>
     <p><a href="https://dimenerno.github.io/2025/01/22/hypernaturals/">이전 글</a>에서 이어지는 내용이다.</p>

<h2 id="5-초자연수의-비표준적-특징">5. 초자연수의 비표준적 특징</h2>

<p>지금까지 우리가 살펴본 초자연수는 $[0], [1], [2], \dots$와 같이 표준 자연수와 상응하는 것들이었다. 이제 표준 자연수와는 괴리가 있는 초자연수들을 살펴 보자.</p>

<p>다음의 초자연수 $\mathfrak{n}$을 보자.</p>

\[(1, 2, 3, 4, \dots) \in \mathfrak{n}\]

<p>초자연수의 정의가 동치류이기 때문에 등호가 아닌 포함 관계로 표현함에 유의하라. 초자연수에서 부등호의 정의를 상기하면, 자연수 $n$에 대해 $[n] &lt; \mathfrak{n}$임을 알 수 있다. 즉, $\mathfrak{n}$은 모든 자연수보다 큰 초자연수이다. 따라서 초자연수에서는 다음이 성립한다.</p>

\[\phi_1 : \exists x \; ( \lbrace y : y &lt; x \rbrace \text{ is infinite } )\]

<p>위 명제는 자연수에서는 성립하지 않는다.</p>

<p>이번에는 다음의 초자연수 $\mathfrak{m}$을 보자.</p>

\[(1, 2!, 3!, 4!, \dots) \in \mathfrak{m}\]

<p>표준 자연수 $n$에 대해 $\mathfrak{m}$은 $[n]$으로 나누어떨어진다. 즉, $\mathfrak{m}$은 모든 자연수를 약수로 가진다. 따라서 초자연수에서는 다음이 성립한다.</p>

\[\phi_2 : \exists x \; (\lbrace y : y \mid x \rbrace \text{ is infinite })\]

<p>위 명제 또한 자연수에서는 성립하지 않는다.</p>

<p>그런데 이상한 점이 있다. 저번 글의 서론에서 필자는 자연수와 초자연수가 논리적으로 구분 불가능하다고 했다. 그러나 $\phi_1$과 $\phi_2$는 $\mathbb{N}^*$에서는 참이지만 $\mathbb{N}$에서는 거짓이므로, 둘은 논리적으로 구분 가능한 것으로 보인다. 필자가 거짓말을 한 것일까?</p>

<p>그렇지 않다. 이 표면적인 역설을 해결하는 실마리는, $\phi_1$과 $\phi_2$가 1차 논리로 표현 <em>불가능한</em> 문장이라는 사실이다. 콤팩트성 정리에 의해 “…가 유한하다”는 1차 논리로 표현 불가능하기 때문이다.</p>

<p>$\mathbb{N}^*$과 $\mathbb{N}$이 논리적으로 구분 불가능하다는 말의 엄밀한 의미는 다음과 같다.</p>

<blockquote>
  <p><strong>정의.</strong> 언어 $\mathcal{L}$의 모형 $\mathcal{M}_1$과 $\mathcal{M}_2$가 <strong>초등적으로 동등(elementarily equivalent)</strong>하다는 것은 임의의 (1차 논리) 문장 $\phi$에 대해</p>

\[\mathcal{M_1} \vDash \phi \iff \mathcal{M}_2 \vDash \phi\]

  <p>가 성립하는 것이다.</p>
</blockquote>

<blockquote>
  <p><strong>정리.</strong> $\mathbb{N}$과 $\mathbb{N}^*$은 초등적으로 동등하다.</p>
</blockquote>

<p>위 정리는 워시의 정리의 특수한 결과이다. 워시의 정리를 소개하기 앞서, 일반화된 초곱의 개념을 먼저 살펴보자.</p>

<h2 id="6-초곱">6. 초곱</h2>

<p>집합 $I$와, $I$ 위의 자유 초필터 $\mathcal{U}$가 주어졌다고 하자. 또한, 언어 $\mathcal{L}$의 모형 $\lbrace \mathcal{M}_i \rbrace_{i \in I}$가 주어졌다고 하자. 이때, <strong>초곱(ultraproduct)</strong> $\mathcal{M}^* = \prod \mathcal{M}_i / \mathcal{U}$를 다음과 같이 정의한다.</p>

<blockquote>
  <h4 id="초곱의-원소">초곱의 원소</h4>

  <p>$\mathcal{M}^*$의 원소는 $\lbrace (a_i)_{i\in I} : a_i \in \mathcal{M}_i \rbrace$가 $\sim$에 대해 이루는 동치류이다. 여기서 $\sim$은 다음과 같이 정의된다.</p>

\[(a_i)_{i\in I} \sim (b_i)_{i \in I} \iff \lbrace i \in I : a_i = b_i \rbrace \in \mathcal{U}\]

  <h4 id="초곱-위의-연산">초곱 위의 연산</h4>

  <p>$f(x)$가 $\mathcal{L}$의 함수라고 하자. $\mathcal{M}^*$의 원소 $\mathfrak{a} = [(a_i)_{i\in I}]$에 대해 다음과 같이 정의한다.</p>

\[f(\mathfrak{a}) = [(f(a_i))_{i \in I}]\]

  <p>위 정의는 자연스러운 방식으로 $n$항 함수로 일반화된다.</p>

  <h4 id="초곱-위의-술어">초곱 위의 술어</h4>

  <p>$P(x, y)$가 $\mathcal{L}$의 술어라고 하자. $\mathcal{M}^*$의 두 원소 $\mathfrak{a} = [(a_i)_{i\in I}]$와 $\mathfrak{b} = [(b_i)_{i\in I}]$에 대해 다음과 같이 정의한다.</p>

\[\mathcal{M}^* \vDash P(\mathfrak{a}, \mathfrak{b}) \iff \lbrace i \in I : \mathcal{M}_i \vDash P(a_i, b_i) \rbrace \in \mathcal{U}\]

  <p>위 정의는 자연스러운 방식으로 $n$항 술어로 일반화된다.</p>
</blockquote>

<p>초곱 위의 연산과 술어를 정의할 때, 연산과 술어의 결과가 동치류에서 어떤 원소를 대표자로 선택하든 상관없이 같음을 보여야 한다. 이것은 $\mathcal{U}$의 교집합 속성으로부터 어렵지 않게 얻어진다.</p>

<blockquote>
  <p><strong>연습문제.</strong> 주 초필터로 취한 초곱은 원소가 유한함을 보이시오. (이것은 우리가 초자연수를 정의할 때 프레셰 필터와 같은 자유 초필터를 사용해야 하는 이유이다)</p>
</blockquote>

<p>이로써 우리는 초자연수를, $I, \mathcal{U}, \mathcal{L}, \mathcal{M}_i$가 각각 다음과 같을 때 도출되는 초곱으로 재정의할 수 있다.</p>

<ul>
  <li>$I = \mathbb{N}$</li>
  <li>$\mathcal{U} =$ 프레셰 초필터</li>
  <li>$\mathcal{L} = (0, S, &lt;)$</li>
  <li>$\mathcal{M}_i = \mathbb{N}$</li>
</ul>

<p>비슷한 방식으로 <strong>초실수<sub>hyperreals</sub></strong>를 정의할 수 있다.</p>

<ul>
  <li>$I = \mathbb{N}$</li>
  <li>$\mathcal{U} =$ 프레셰 초필터</li>
  <li>$\mathcal{L} = (0, 1, +, ⋅, &lt;)$</li>
  <li>$\mathcal{M}_i = \mathbb{R}$</li>
</ul>

<h2 id="7-워시의-정리">7. 워시의 정리</h2>

<blockquote>
  <p><strong>워시<sub>Łoś</sub>의 정리.</strong> 초곱 $\mathcal{M}^* = \prod \mathcal{M}_i / \mathcal{U}$가 주어졌을 때, 임의의 $\mathcal{L}$-문장 $\phi$에 대해 다음이 성립한다.</p>

\[\mathcal{M}^* \vDash \phi \iff \lbrace i \in I : \mathcal{M}_i \vDash \phi \rbrace \in \mathcal{U}\]
</blockquote>

<p><em>Proof.</em> $\phi$에 대한 구조적 귀납법으로 증명한다.</p>

<h4 id="1-phi가-원자-명제이다">1. $\phi$가 원자 명제이다</h4>

<p>“초곱 위의 술어” 정의에 의해 자명하게 성립한다.</p>

<h4 id="2-phi--psi-land-theta">2. $\phi := \psi \land \theta$</h4>

\[\begin{aligned}
&amp;\mathcal{M}^* ⊨ φ\\
&amp;\iff \mathcal{M}^* ⊨ ψ \land \mathcal{M}^* ⊨ θ\\
&amp;\iff \lbrace i ∈ I \mid \mathcal{M}_i ⊨ ψ \rbrace ∈ \mathcal{U} \land \lbrace i ∈ I \mid \mathcal{M}_i ⊨ θ \rbrace ∈ \mathcal{U} &amp;&amp;(*)
\\
&amp;\iff \lbrace i ∈ I \mid \mathcal{M}_i ⊨ ψ \rbrace \cap \lbrace i ∈ I \mid \mathcal{M}_i ⊨ θ \rbrace ∈ \mathcal{U} &amp;&amp;(**) \\
&amp;\iff \lbrace i ∈ I \mid \mathcal{M}_i ⊨ ψ \land \mathcal{M}_i ⊨ θ \rbrace ∈ \mathcal{U}\\
&amp;\iff \lbrace i ∈ I \mid \mathcal{M}_i ⊨ ψ∧θ \rbrace ∈ \mathcal{U}\\
&amp;\iff \lbrace i ∈ I \mid \mathcal{M}_i ⊨ φ \rbrace ∈ \mathcal{U}
\end{aligned}\]

<p>$(*)$는 귀납 가정에 의해 성립하고, $(**)$는 $\mathcal{U}$의 교집합 닫힘 속성으로 성립한다.</p>

<h4 id="3-phi--lnot-psi">3. $\phi := \lnot \psi$</h4>

<p>2와 비슷한 방법으로 하면 된다. 단, 귀납 가정과 $\mathcal{U}$의 초필터 속성($A \in \mathcal{U} \lor A^c \in \mathcal{U}$)를 사용한다.</p>

<h4 id="4-phi--exists-x-psi">4. $\phi := \exists x\; \psi$</h4>

<p>2와 비슷한 방법으로 하면 된다. 단, 귀납 가정만 사용해도 충분하다.</p>

<p>모든 명제는 1, 2, 3, 4로 구성할 수 있으므로 귀납법에 의해 정리가 증명되었다. ■</p>

<blockquote>
  <p><strong>따름정리.</strong> $\mathbb{N}$과 $\mathbb{N}^*$은 초등적으로 동등하다.</p>
</blockquote>

<p><em>Proof.</em> 워시의 정리에 의해 $\mathbb{N}^* \vDash \phi$일 필요충분조건은 $\lbrace i \in \mathbb{N} : \mathbb{N}^\ast_i \vDash \phi \rbrace \in \mathcal{U}$인 것이다. 그런데 $\mathbb{N}^*_i = \mathbb{N}$이므로, 필요충분조건은 $\mathbb{N} \vDash \phi$로 환원된다. ■</p>

  </div>
  <div style="margin-bottom: 6em"></div>
  
</div>

<div class="pagination">
  
  <a
    class="pagination-item older lang-ko"
    href="/page11"
    >이전 글</a
  >
  <a
  class="pagination-item older lang-en"
  href="/page11"
  >Previous</a
>
    
  <a
    class="pagination-item newer lang-ko"
    href="/page9"
    >다음 글</a
  >
  <a
  class="pagination-item newer lang-en"
  href="/page9"
  >Next</a
>
   
</div>

<script>
  const faders = document.querySelectorAll(".fade-in-section");

  const appearOptions = {
    // threshold: 0.05,
    // rootMargin: "0px 0px 50px 0px",
  };

  const appearOnScroll = new IntersectionObserver((entries, observer) => {
    entries.forEach((entry) => {
      if (entry.isIntersecting) {
        entry.target.classList.add("is-visible");
        observer.unobserve(entry.target);
      }
    });
  }, appearOptions);

  faders.forEach((fader) => {
    appearOnScroll.observe(fader);
  });

  // 배너 이미지 로드 후 애니메이션 트리거 스크립트
  document.addEventListener("DOMContentLoaded", () => {

    const lang = localStorage.getItem("lang") || "ko";
  document.querySelectorAll('.post[data-lang]').forEach(post => {
    if (post.dataset.lang === lang) {
      post.style.display = '';
    }
  });

    const bannerImages = document.querySelectorAll(
      '.fade-rise-1[src="/public/banner.png"], .fade-rise-2[src="/public/banner-2.png"]'
    ); // 애니메이션 시작을 기다릴 이미지들
    const elementsToAnimate = document.querySelectorAll(
      ".fade-rise-1, .fade-rise-2, .fade-rise-3"
    ); // 애니메이션 될 요소들
    let loadedImagesCount = 0;
    const totalImagesToWait = bannerImages.length;

    // 기다릴 이미지가 없으면 즉시 애니메이션 시작
    if (totalImagesToWait === 0) {
      elementsToAnimate.forEach((el) => el.classList.add("is-loaded"));
      return;
    }

    const checkAllImagesLoaded = () => {
      if (loadedImagesCount === totalImagesToWait) {
        // 모든 이미지가 로드되면 애니메이션 클래스 추가
        elementsToAnimate.forEach((el) => el.classList.add("is-loaded"));
      }
    };

    bannerImages.forEach((img) => {
      // 이미지가 캐시되어 이미 로드 완료된 경우
      if (img.complete) {
        loadedImagesCount++;
      } else {
        // 이미지 로드 완료 이벤트 리스너 추가
        img.addEventListener("load", () => {
          loadedImagesCount++;
          checkAllImagesLoaded(); // 이미지 로드될 때마다 체크
        });
        // 에러 발생 시 처리 (선택 사항)
        img.addEventListener("error", () => {
          console.error("Failed to load image:", img.src);
          // 에러 발생 시에도 애니메이션을 시작하려면 여기서 loadedImagesCount를 증가시키거나 다른 로직 추가
          // 현재 로직에서는 에러 시 카운트가 증가하지 않아 모든 이미지 로드되지 않으면 애니메이션 안 시작
          loadedImagesCount++; // 에러 발생 시에도 카운트 증가 (모든 이미지를 처리했음을 알림)
          checkAllImagesLoaded();
        });
      }
    });

    // 모든 이미지에 대해 complete 상태를 확인하거나 리스너를 설정한 후,
    // 이미 모든 이미지가 로드 완료 상태였을 경우를 대비해 마지막으로 체크
    checkAllImagesLoaded();


    // Listen for language toggle changes and update post visibility dynamically
    const langToggle = document.getElementById("lang-toggle");
    if (langToggle) {
      langToggle.addEventListener("change", () => {
        const newLang = langToggle.checked ? "en" : "ko";
        localStorage.setItem("lang", newLang);
        document.querySelectorAll('.post[data-lang]').forEach(post => {
          post.style.display = post.dataset.lang === newLang ? '' : 'none';
        });
      });
    }
  });
</script>
</div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script src="/public/js/script.js"></script>
    <script src="/public/js/lang.js"></script>
  </body>
</html>
