<!DOCTYPE html>
<html lang="en-us">
  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile" />
  <link href="https://fonts.googleapis.com/css2?family=Libre+Baskerville&display=swap" rel="stylesheet">
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />

  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=1"
  />

  <title>
     디멘의 블로그 &middot; 이데아를 여행하는 히치하이커
    
  </title>

  <style>
    .answer {
      display: none;
      margin-top: 10px;
      color: #333;
    }
  </style>

<style>
  .lang-toggle-wrapper {
    display: flex;
    align-items: center;
    gap: 0.4em;
    margin-right: 0.5em;
  }

  .lang-label {
    font-size: 0.9em;
    line-height: 1;
  }

  .switch {
    position: relative;
    display: inline-block;
    width: 44px;
    height: 24px;
  }

  .switch input {
    opacity: 0;
    width: 0;
    height: 0;
  }

  .slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #e7e8eb;
    transition: 0.4s;
    border-radius: 24px;
  }

  .slider::before {
    position: absolute;
    content: "";
    height: 18px;
    width: 18px;
    left: 3px;
    bottom: 3px;
    background-color: white;
    transition: 0.4s;
    border-radius: 50%;
  }

  .switch input:checked + .slider {
    background-color: #2e2e2e;
  }

  .switch input:checked + .slider::before {
    transform: translateX(20px);
  }

  .lang-ko, .lang-en {
  transition: opacity 0.3s ease;
}
</style>

  <script>
    function toggleAnswer(id) {
      const answer = document.getElementById("answer" + id);
      if (answer.style.display === "none" || answer.style.display === "") {
        answer.style.display = "block";
      } else {
        answer.style.display = "none";
      }
    }
  </script>

  <script>
    MathJax = {
      tex: {
        inlineMath: [
          ["$", "$"],
          ["\\(", "\\)"],
        ],
      },
      svg: {
        fontCache: "global",
      },
    };
  </script>
  <script
    type="text/javascript"
    id="MathJax-script"
    async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
  ></script>

  
  <link rel="canonical" href="/page5/" />
  

  <link rel="stylesheet" href="/public/css/poole.css" />
  <link rel="stylesheet" href="/public/css/syntax.css" />
  <link rel="stylesheet" href="/public/css/lanyon.css" />
  <link
    rel="stylesheet"
    href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400"
  />


  <link
    rel="apple-touch-icon-precomposed"
    sizes="144x144"
    href="/public/apple-touch-icon.png"
  />
  <link rel="shortcut icon" href="/public/favicon.ico" />
  <link
    rel="alternate"
    type="application/rss+xml"
    title="RSS"
    href=""
  />

  <script
    async
    src="https://www.googletagmanager.com/gtag/js?id=G-PVGYLWF7GR"
  ></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
      dataLayer.push(arguments);
    }
    gtag("js", new Date());

    gtag("config", "G-PVGYLWF7GR");
  </script>
</head>


  <style>
    /* 검색 입력창 */
    #search-input {
      padding: 6px 12px;
      font-size: 15px;
      border: 1px solid #eee;
      border-radius: 20px;
      outline: none;
      transition: all 0.2s ease-in-out;
      width: 90%;
      max-width: 240px;
      background-color: #fefefe;
    }

    #search-input::placeholder {
      color: var(--slate);
    }

    /* 입력창 포커스 시 */
    #search-input:focus {
      border-color: #9ea0a3;
      background-color: white;
    }

    @media (max-width: 600px) {
      .lang-label {
        display: none;
      }
    }
  </style>

  <body>
    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox" />

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p class="lang-ko">이데아를 여행하는 히치하이커</p>
    <p class="lang-en" style="display: none;">Alice in Logicland</p>
  </div>

  <nav class="sidebar-nav">
    <a
    class="sidebar-nav-item lang-ko"
    href="/"
    >메인</a>
    <a
    class="sidebar-nav-item lang-en"
    href="/"
    >Main</a
  >
       
    <a
      class="sidebar-nav-item lang-ko"
      href="/about/"
      >저에 대하여</a
    >
    <a
    class="sidebar-nav-item lang-en"
    href="/about/"
    >About Me</a
  >
        
    <a
      class="sidebar-nav-item lang-ko"
      href="/archive-date/"
      >날짜별로 보기</a
    >
    <a
    class="sidebar-nav-item lang-en"
    href="/archive-date/"
    >List by dates</a
  >
        
    <a
      class="sidebar-nav-item lang-ko"
      href="/archive-tag/"
      >주제별로 보기</a
    >
    <a
    class="sidebar-nav-item lang-en"
    href="/archive-tag/"
    >List by topics</a
  >
        
    <a
      class="sidebar-nav-item lang-ko"
      href="/random/"
      >랜덤 포스트</a
    >
    <a
    class="sidebar-nav-item lang-en"
    href="/random/"
    >Go to a random post</a
  >
        
    <a
      class="sidebar-nav-item lang-ko"
      href="/book/"
      >새벽의 자연학 수업</a
    >
    <a
    class="sidebar-nav-item lang-en"
    href="/book/"
    >Twilight Wonders (Korean)</a
  >
        
    <a
      class="sidebar-nav-item lang-ko"
      href="/notes/"
      >복습노트 아카이브</a
    >
    <a
    class="sidebar-nav-item lang-en"
    href="/notes/"
    >Maths Review Notes (Korean)</a
  >
        
    <a
      class="sidebar-nav-item lang-ko"
      href="/guestbook/"
      >방명록</a
    >
    <a
    class="sidebar-nav-item lang-en"
    href="/guestbook/"
    >Guestbook</a
  >
        
    <a
      class="sidebar-nav-item lang-ko"
      href="/tractatus/"
      >⟪논리철학논고⟫ 읽기</a
    >
    <a
    class="sidebar-nav-item lang-en"
    href="/tractatus/"
    >Reading Tractatus</a
  >
          
  </nav>

  <div class="sidebar-item">
    <p>&copy; 2025. All rights reserved.</p>
    <p style="color: #202020">
      &copy; 2025. 디멘 reserved by 곰댕.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead" style="width: 100%">
        <div
          class="container"
          style="
            display: flex;
            justify-content: space-evenly;
            align-items: center;
            padding: 0px;
            margin-left: 4em;
            margin-right: 0;
            max-width: none;
            overflow-y: hidden;
          "
        >
          <h3
            class="masthead-title"
            style="
              display: flex;
              flex-direction: row;
              gap: 0.3em;
              align-items: end;
              line-height: 1;
            "
          >
            <a
              href="/"
              style="white-space: nowrap"
              class="lang-ko"
              title="Home"
              >디멘의 블로그</a>
            <a
              href="/"
              style="white-space: nowrap"
              class="lang-en"
              title="Home"
            >Dimen's Blog</a>
            <small><div class="lang-ko">이데아를 여행하는 히치하이커</div>
              <div class="lang-en">Alice in Logicland</div></small>

          </h3>
          <form
            id="search-form"
            action="/search.html"
            method="get"
            style="display: flex; justify-content: end; padding-right: 1em"
          >
            <input
              type="text"
              name="q"
              id="search-input"
              placeholder="검색"
            />
          </form>

          <div class="lang-toggle-wrapper">
            <span class="lang-label">한</span>
            <label class="switch">
              <input type="checkbox" id="lang-toggle" />
              <span class="slider round"></span>
            </label>
            <span class="lang-label">EN</span>
          </div>
        </div>
      </div>

      <div class="container content"><head>
  <style>
    .fade-rise-1 {
      opacity: 0;
      transform: translateY(20px);
      /* animation: fadeRise 0.8s ease-out forwards;
      animation-delay: 0.2s; */
    }

    .fade-rise-2 {
      opacity: 0;
      transform: translateY(20px);
      /* animation: fadeRise 0.8s ease-out forwards;
      animation-delay: 0.4s; */
    }

    .fade-rise-3 {
      opacity: 0;
      transform: translateY(20px);
      /* animation: fadeRise 0.8s ease-out forwards;
      animation-delay: 0.6s; */
    }

    /* 이미지가 로드된 후 추가될 클래스에 animation 속성 추가 */
    .fade-rise-1.is-loaded {
      animation: fadeRise 0.8s ease-out forwards 0.2s;
    }
    .fade-rise-2.is-loaded {
      animation: fadeRise 0.8s ease-out forwards 0.4s;
    }
    .fade-rise-3.is-loaded {
      animation: fadeRise 0.8s ease-out forwards 0.6s;
    }

    @keyframes fadeRise {
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .fade-in-section {
      opacity: 0;
      transform: translateY(10px);
      transition: opacity 0.5s ease-out, transform 0.5s ease-out;
    }

    .fade-in-section.is-visible {
      opacity: 1;
      transform: none;
    }

    .spacer {
      height: 100vh;
    }
  </style>
</head>



<div class="posts">
  
    <div class="post fade-in-section" data-lang="ko" style="display: none">
      <h1 class="post-title">
        <a href="/2025/04/17/los-tarski"> 워시-타르스키 보존 정리 </a>
      </h1>
    <span class="post-date">17 Apr 2025</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/수학/'">
        수학
      </div>
      
      <div class="tag" onclick="location.href='/tags/논리학/'">
        논리학
      </div>
      
      <div class="tag" onclick="location.href='/tags/대수학/'">
        대수학
      </div>
      
    </div>
     <p>군 $G$의 부분군 $H, K$에 대해 $H \cap K$는 언제나 군이다. 환과 체의 경우에도 마찬가지이다. 이는 워시-타르스키 정리의 따름결과로 설명할 수 있다.</p>

<blockquote>
  <p><em>Notation.</em> 본 글에서 $T$는 언어 $\mathcal{L}$의 1차 논리 이론이며, 프락투르 글자 $\mathfrak{M}, \mathfrak{N}, \dots$은 $\mathcal{L}$-구조<sub>structure</sub>이다. 또한 $\mathfrak{M}, \mathfrak{N}, \dots$의 정의역을 $M, N, \dots$와 같이 적는다.</p>
</blockquote>

<h2 id="기본-개념">기본 개념</h2>

<blockquote>
  <p><strong>정의.</strong> $N \subseteq M$이고 $\mathfrak{N}$에서의 해석<sub>interpretation</sub>이 $\mathfrak{M}$에서의 해석을 $N$으로 제한한 것일 때, $\mathfrak{N}$을 $\mathfrak{M}$의 <strong>부분모델<sub>submodel</sub></strong>이라고 하며, 기호로 $\mathfrak{N} \subseteq \mathfrak{M}$과 같이 적는다. 또한, $\mathfrak{M}$을 $\mathfrak{N}$의 <strong>확장<sub>extension</sub></strong>이라고 한다.</p>
</blockquote>

<p>일례로 $(2\mathbb{Z}, +)$는 $(\mathbb{Z}, +)$의 부분모델이고, $(\mathbb{Q}, +, \cdot)$는 $(\mathbb{R}, +, \cdot)$의 부분모델이다.</p>

<blockquote>
  <p><strong>정의.</strong> 임의의 $\mathcal{L}$-문장 $\phi$에 대해 $\mathfrak{M} \vDash \phi \iff \mathfrak{N} \vDash \phi$일 때 $\mathfrak{M}$과 $\mathfrak{N}$이 <strong>초등적으로 동등<sub>elementarily equivalent</sub></strong>하다고 하며, 기호로 $\mathfrak{M} \equiv \mathfrak{N}$과 같이 적는다.</p>
</blockquote>

<p><a href="https://dimenerno.github.io/2025/04/10/completeness-theorem/">뢰벤하임-스콜렘 정리</a>에 의해 $\kappa$가 $|\mathcal{L}|$ 이상의 무한 기수라면, 임의의 무한 구조 $\mathfrak{M}$과 초등적으로 동등하며 크기가 $\kappa$인 모델 $\mathfrak{N}$이 존재한다. (cf. 워시-보트 판별<sub>Łoś-Vaught test</sub>)</p>

<blockquote>
  <p><strong>정의.</strong> $\mathfrak{M}$과 $\mathfrak{N}$이 구조적으로 동일할 때 <strong>동형<sub>isomorphic</sub></strong>이라고 하며, 기호로 $\mathfrak{M} \cong \mathfrak{N}$과 같이 적는다. 구체적으로, 어떤 일대일 대응 $\phi: M \to N$이 존재하여, $\mathcal{L}$의 임의의 함수 $f$와 관계 $R$에 대해 다음이 임의의 $a_1, \dots, a_n \in M$에 대해 성립할 때 $\mathfrak{M} \cong \mathfrak{N}$이다.</p>

\[\begin{gather}
\phi(f_\mathfrak{M}(a_1, \dots, a_n)) = f_\mathfrak{N}(\phi(a_1), \dots, \phi(a_n)), \\\\
R_\mathfrak{M}(a_1, \dots, a_n) \iff R_\mathfrak{N}(\phi(a_1), \dots, \phi(a_n))
\end{gather}\]
</blockquote>

<p>$(\mathbb{Z}, +)$와 $(2\mathbb{Z}, +)$는 $\phi: x \mapsto 2x$를 통해 동형이지만 $(\mathbb{Q}, +, \cdot)$와 $(\mathbb{R}, +, \cdot)$은 동형이 아니다.</p>

<p>다음 정리의 증명은 거의 자명하다.</p>

<blockquote>
  <p><strong>정리.</strong> 동형인 두 구조는 초등적으로 동등하다.</p>
</blockquote>

<blockquote>
  <p><strong>정의.</strong> $\mathfrak{N} \subseteq \mathfrak{M}$이라고 하자. 임의의 $\mathcal{L}$-명제 $\phi$와 $\mathfrak{N}$에서의 자유변수 할당<sub>assignment</sub> $g$에 대해, $\mathfrak{N} \vDash \phi[g] \iff \mathfrak{M} \vDash \phi[g]$일 때 $\mathfrak{N}$이 $\mathfrak{M}$의 <strong>초등적 부분모델<sub>elementary submodel</sub></strong>이라고 하며, 기호로 $\mathfrak{N} \preceq \mathfrak{M}$과 같이 적는다.</p>
</blockquote>

<p>2와 3은 1보다 강하지만, 2와 3은 서로를 시사하지 않는다.</p>

<ol>
  <li>$\mathfrak{N} \subseteq \mathfrak{M}$, $\mathfrak{N} \equiv \mathfrak{M}$</li>
  <li>$\mathfrak{N} \subseteq \mathfrak{M}$, $\mathfrak{N} \cong \mathfrak{M}$</li>
  <li>$\mathfrak{N} \preceq \mathfrak{M}$</li>
</ol>

<p>2와 3이 서로를 시사하지 않는 이유는, 2가 구조적 동등을 요구한다는 점에서 3보다 약하지 않은 한편, 3이 임의의 할당에 대한 동등을 요구한다는 점에서 2보다 약하지 않기 때문이다. 예를 들어 $\mathfrak{M} = (\mathbb{R}, +, \cdot)$에 대해, $\mathfrak{N}$이 $\mathfrak{M}$의 동형인 부분모델이기 위해서는 <em>구성 가능한</em> 실수에 대해 <em>구조적으로</em> 동일해야 하는 반면, $\mathfrak{N}$이 $\mathfrak{M}$의 초등적 부분모델이기 위해서는 두 모델이 <em>모든</em> 실수에 대해 <em>초등적으로</em> 동등해야 한다.</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>2</th>
      <th>3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>2가 3보다 약하지 않다</td>
      <td>구조적 동일성</td>
      <td>초등적 동일성</td>
    </tr>
    <tr>
      <td>3이 2보다 약하지 않다</td>
      <td>구성 가능한 대상</td>
      <td>임의의 대상</td>
    </tr>
  </tbody>
</table>

<p>일례로 앞서 보았듯이 $(2\mathbb{Z}, +)$는 $(\mathbb{Z}, +)$의 동형인 부분모델이지만, $\exists y \; (y + y = x)$에 $x \mapsto 2$ 할당을 고려하면 초등적 부분모델은 아님을 알 수 있다.</p>

<h2 id="워시-타르스키-정리">워시-타르스키 정리</h2>

<p>$\mathfrak{M}$이 $T$의 모델이라고 하자. $T$가 어떤 이론이어야 $\mathfrak{M}$의 임의의 부분모델 또한 $T$의 모델이 될까? 그 답은 다음의 정리로 주어진다.</p>

<blockquote>
  <p><strong>워시-타르스키<sub>Łoś-Tarski</sub> 보존 정리.</strong> $T$의 모델의 부분모델 또한 $T$의 모델일 필요충분조건은 $T$가 $\Pi_1$ 문장으로 이루어진 이론과 동치인 것이다.</p>
</blockquote>

<p>$\Pi_1$ 문장이 무엇인지에 대해서는 <a href="https://dimenerno.github.io/2025/02/07/arithmetic-hierarchy/">산술 위계</a> 글에서 다룬 바 있다. 간략히만 설명하자면 $\forall$만을 양화사로 가지는 이론이다. 직관적으로 $\Pi_1$ 문장은 정의역이 제한될수록 만족시키기 쉬우므로, $T$가 $\Pi_1$ 이론이라면 $T$는 부분모델에 대해 보존될 것이다. 필요조건은 증명하기가 좀 더 까다롭다.</p>

<p><strong>증명.</strong> 충분조건은 거의 자명하므로 필요조건만 증명한다. 다음의 보조정리를 증명한다.</p>

<blockquote>
  <p><strong>보조정리.</strong> $T$가 언어 $\mathcal{L}$의 무모순적인 이론이라고 하자. $\mathcal{L}$ 문장들의 집합 $\Delta$가 다음 두 조건을 만족할 때, $\Delta$는 $T$의 공리화를 포함한다.</p>

  <ol>
    <li>$\Delta$는 선언<sub>disjunction</sub>에 대해 닫혀 있다. 즉, $\phi, \psi \in \Delta$라면 $\phi \lor \psi \in \Delta$이다.</li>
    <li>$T$의 모델 $\mathfrak{A}$에 대해, $\mathfrak{B}$가 $\mathfrak{A}$에서 만족되는 모든 $\Delta$의 문장들을 만족한다면 $\mathfrak{B}$ 또한 $T$의 모델이다.</li>
  </ol>
</blockquote>

<p><em>보조정리의 증명.</em> $\Gamma = \lbrace  \delta \in \Delta : T \vDash \delta \rbrace $라고 하자. $\Delta$가 $T$의 공리화를 포함함을 보이기 위해서는 다음을 보이면 충분하다.</p>

\[\mathfrak{B} \vDash \Gamma \implies \mathfrak{B} \vDash T\]

<p>$\mathfrak{B}$가 $\Gamma$의 모델이라고 하자. 다음과 같이 정의한다.</p>

\[\Sigma = \{ \lnot \delta : \delta \in \Delta, \mathfrak{B} \not\vDash \delta \}\]

<p>$T \cup \Sigma$는 무모순적인 이론임을 보이자. 만약 $T \cup \Sigma$가 모순적이라면 어떤 $\lnot\delta_1, \dots, \lnot\delta_n \in \Sigma$에 대해 $T \vdash \lnot(\lnot\delta_1 \land \cdots \land \lnot\delta_n)$이므로, $T \vdash \delta_1 \lor \cdots \lor \delta_n$이다. $\Delta$가 선언에 대해 닫혀 있으므로 $\delta_1 \lor \cdots \lor \delta_n \in \Delta$이다. $\Gamma$의 정의에 의해 $\delta_1 \lor \cdots \lor \delta_n \in \Gamma$이므로 $\mathfrak{B} \vDash \delta_1 \lor \cdots \lor \delta_n$이다. 이는 $\lnot\delta_1, \dots, \lnot\delta_n \in \Sigma$에 모순이다.</p>

<p>$T \cup \Sigma$가 무모순적이므로 완전성 정리에 의해 모델을 가진다. 해당 모델을 $\mathfrak{A}$라고 하자. $\mathfrak{B}$는 $\mathfrak{A}$가 만족시키는 $\Delta$의 문장들을 모두 만족시키므로, 가정에 의해 $T$의 모델이다. □</p>

<p>이제 본 정리의 증명으로 넘어가자. $\Delta$를 모든 $\mathcal{L}$의 $\Pi_1$ 문장들의 집합이라고 하자. 우리의 목표는 $\Delta$가 $T$의 공리화를 포함함을 보이는 것이다. $\Pi_1$ 문장들은 선언에 대해 닫혀 있으므로, 보조정리에 의해 다음을 보이면 충분하다.</p>

<blockquote>
  <p>$T$가 부분모델에 대해 보존적인 이론이라고 하자. $T$의 모델 $\mathfrak{A}$에 대해, $\mathfrak{B}$가 $\mathfrak{A}$에서 만족되는 모든 $\Pi_1$ 문장들을 만족한다면 $\mathfrak{B}$ 또한 $T$의 모델이다.</p>
</blockquote>

<p><a href="https://dimenerno.github.io/2025/05/01/elementary-embedding/">이 글</a>에서의 표기법을 따라 $E(\mathfrak{B})$를 정의하자. 즉, $\mathfrak{M}$이 $E(\mathfrak{B})$를 만족할 때 $\mathfrak{B} \preceq \mathfrak{M}$이다.</p>

<p>$T \cup E(\mathfrak{B})$는 무모순적임을 보이자. 만약 $T \cup E(\mathfrak{B})$가 모순적이라면, 어떤 $E(\mathfrak{B})$의 문장 $\phi(b_1, \dots, b_n)$이 존재하여 $T \cup \lbrace  \phi \rbrace $는 모델을 가지지 않는다. 따라서 $T$의 모델인 $\mathfrak{A}$는 $\phi$를 만족시키는 $\mathcal{L} \cup \lbrace b_1, \dots, b_n \rbrace $ 모델로 확장될 수 없다. 즉, 다음이 성립한다.</p>

\[\mathfrak{A} \vDash \forall x_1 \cdots \forall x_n \lnot \phi(x_1, \dots, x_n)\]

<p>우변은 $\Pi_1$ 문장이므로, 가정에 의해 $\mathfrak{B} \vDash \forall x_1 \cdots \forall x_n \lnot \phi(x_1, \dots, x_n)$이다. 그런데 $\phi(b_1, \dots, b_n) \in E(\mathfrak{B})$이므로, 이는 모순이다. 따라서 $T \cup E(\mathfrak{B})$는 무모순적이며, 완전성 정리에 의해 모델 $\mathfrak{C}$를 가진다. 그리고 $\mathfrak{C}$는 $E(\mathfrak{B})$를 만족하므로, $\mathfrak{B} \preceq \mathfrak{C}$이다. 한편 $\mathfrak{C}$는 부분모델에 대해 보존적인 이론 $T$의 모델이므로, $\mathfrak{B}$는 $T$의 모델이다. ■</p>

<h2 id="응용">응용</h2>

<p>군의 1차 논리적 공리화는, 항등원과 역원을 별도의 상수 $e$와 함수 $(-)^{-1}$로 표현하는지의 여부에 따라 구분된다.</p>

<h4 id="표현하지-않는-경우">표현하지 않는 경우</h4>

<p>언어 $\mathcal{L}_1 = \lbrace  G, \cdot \rbrace $의 이론 $T_1$를 다음과 같이 정의한다.</p>

<ul>
  <li>$\forall x, y, z : (x \cdot y) \cdot z = x \cdot (y \cdot z)$</li>
  <li>$\exists x \forall y : x \cdot y = y \cdot x = y$</li>
  <li>$\forall x \exists y \forall z : (x \cdot y) \cdot z = (y \cdot x) \cdot z = z$</li>
</ul>

<h4 id="표현하는-경우">표현하는 경우</h4>

<p>언어 $\mathcal{L}_2 = \lbrace  G, \cdot, e, (-)^{-1} \rbrace $의 이론 $T_2$를 다음과 같이 정의한다.</p>

<ul>
  <li>$\forall x, y, z : (x \cdot y) \cdot z = x \cdot (y \cdot z)$</li>
  <li>$\forall x : x \cdot e = e \cdot x = x$</li>
  <li>$\forall x : x \cdot x^{-1} = x^{-1} \cdot x = e$</li>
</ul>

<p>$T_1$은 $\Pi_1$ 이론이 아니지만 $T_2$는 $\Pi_1$ 이론이다. 따라서 워시-타르스키 정리에 의해, $T_1$은 부분모델 보존적이지 않지만 $T_2$는 보존적이다. $T_1$이 부분모델 보존적이지 않다는 것은, 군의 부분집합이 연산에 대해 닫혀 있다고 해서 언제나 부분군인 것은 아님을 의미한다<small>(일례로 $\mathbb{Z}$의 부분집합 $\mathbb{Z}_{&gt; 0}$은 연산에 대해 닫혀 있지만 역원을 결여하므로 군이 아니다)</small>. 반면 $T_2$가 부분모델 보존적이라는 것은 다음이 성립함을 의미한다.</p>

<blockquote>
  <p>군 $G$에 대해, $G$의 부분집합 $H$가 다음을 만족한다면 $H$는 $G$의 부분군이다.</p>

  <ol>
    <li>연산에 대해 닫혀 있다.</li>
    <li>역원에 대해 닫혀 있다.</li>
    <li>$G$의 항등원을 포함한다.</li>
  </ol>
</blockquote>

<p>그런데 위보다 더 강한 다음의 결과가 일반적으로 성립한다.</p>

<blockquote>
  <p>군 $G$에 대해, $G$의 부분집합 $H$가 다음을 만족한다면 $H$는 $G$의 부분군이다.</p>

  <ol>
    <li>연산에 대해 닫혀 있다.</li>
    <li>역원에 대해 닫혀 있다.</li>
  </ol>
</blockquote>

<p>즉, 항등원을 지시할 상수를 결여하는 언어 $\mathcal{L}_3 = \lbrace  G, \cdot, (-)^{-1} \rbrace$에서도 군의 이론은 부분모델 보존적이며, 이는 $\mathcal{L}_3$로 군을 형식화하는 $\Pi_1$ 이론이 존재함을 의미한다. 머리를 잘 굴려보면 실제로 다음의 이론 $T_3$가 존재함을 발견할 수 있다.</p>

<ul>
  <li>$\forall x, y, z : (x \cdot y) \cdot z = x \cdot (y \cdot z)$</li>
  <li>$\forall x, y : (x \cdot x^{-1}) \cdot y = y \cdot (x \cdot x^{-1}) = y$</li>
</ul>

  </div>
  <div style="margin-bottom: 6em"></div>
  
    <div class="post fade-in-section" data-lang="en" style="display: none">
      <h1 class="post-title">
        <a href="/2025/04/17/los-tarski/en"> The Łoś-Tarski Preservation Theorem </a>
      </h1>
    <span class="post-date">17 Apr 2025</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/mathematics/'">
        Mathematics
      </div>
      
      <div class="tag" onclick="location.href='/tags/logic/'">
        Logic
      </div>
      
      <div class="tag" onclick="location.href='/tags/algebra/'">
        Algebra
      </div>
      
    </div>
     <blockquote>
  <p>This post was machine translated and has not yet been proofread. It may contain minor errors or unnatural expressions. Proofreading will be done in the near future.</p>
</blockquote>

<p>For subgroups $H, K$ of a group $G$, the intersection $H \cap K$ is always a group. The same holds for rings and fields. This can be explained as a consequence of the Łoś-Tarski theorem.</p>

<blockquote>
  <p><em>Notation.</em> In this article, $T$ is a first-order theory in language $\mathcal{L}$, and Fraktur letters $\mathfrak{M}, \mathfrak{N}, \dots$ denote $\mathcal{L}$-structures. Furthermore, we write the domains of $\mathfrak{M}, \mathfrak{N}, \dots$ as $M, N, \dots$ respectively.</p>
</blockquote>

<h2 id="basic-concepts">Basic Concepts</h2>

<blockquote>
  <p><strong>Definition.</strong> When $N \subseteq M$ and the interpretation in $\mathfrak{N}$ is the restriction of the interpretation in $\mathfrak{M}$ to $N$, we call $\mathfrak{N}$ a <strong>submodel</strong> of $\mathfrak{M}$, and write $\mathfrak{N} \subseteq \mathfrak{M}$. Furthermore, $\mathfrak{M}$ is called an <strong>extension</strong> of $\mathfrak{N}$.</p>
</blockquote>

<p>For example, $(2\mathbb{Z}, +)$ is a submodel of $(\mathbb{Z}, +)$, and $(\mathbb{Q}, +, \cdot)$ is a submodel of $(\mathbb{R}, +, \cdot)$.</p>

<blockquote>
  <p><strong>Definition.</strong> When $\mathfrak{M} \vDash \phi \iff \mathfrak{N} \vDash \phi$ for any $\mathcal{L}$-sentence $\phi$, we say that $\mathfrak{M}$ and $\mathfrak{N}$ are <strong>elementarily equivalent</strong>, and write $\mathfrak{M} \equiv \mathfrak{N}$.</p>
</blockquote>

<p>By the <a href="https://dimenerno.github.io/2025/04/10/completeness-theorem/">Löwenheim-Skolem theorem</a>, if $\kappa$ is an infinite cardinal at least $|\mathcal{L}|$, then for any infinite structure $\mathfrak{M}$, there exists a model $\mathfrak{N}$ of cardinality $\kappa$ that is elementarily equivalent to $\mathfrak{M}$. (cf. Łoś-Vaught test)</p>

<blockquote>
  <p><strong>Definition.</strong> When $\mathfrak{M}$ and $\mathfrak{N}$ are structurally identical, they are called <strong>isomorphic</strong>, written $\mathfrak{M} \cong \mathfrak{N}$. Specifically, $\mathfrak{M} \cong \mathfrak{N}$ when there exists a bijection $\phi: M \to N$ such that for any function $f$ and relation $R$ in $\mathcal{L}$, the following holds for any $a_1, \dots, a_n \in M$:</p>

\[\begin{gather}
\phi(f_\mathfrak{M}(a_1, \dots, a_n)) = f_\mathfrak{N}(\phi(a_1), \dots, \phi(a_n)), \\\\
R_\mathfrak{M}(a_1, \dots, a_n) \iff R_\mathfrak{N}(\phi(a_1), \dots, \phi(a_n))
\end{gather}\]
</blockquote>

<p>$(\mathbb{Z}, +)$ and $(2\mathbb{Z}, +)$ are isomorphic via $\phi: x \mapsto 2x$, but $(\mathbb{Q}, +, \cdot)$ and $(\mathbb{R}, +, \cdot)$ are not isomorphic.</p>

<p>The proof of the following theorem is almost trivial.</p>

<blockquote>
  <p><strong>Theorem.</strong> Two isomorphic structures are elementarily equivalent.</p>
</blockquote>

<blockquote>
  <p><strong>Definition.</strong> Let $\mathfrak{N} \subseteq \mathfrak{M}$. When $\mathfrak{N} \vDash \phi[g] \iff \mathfrak{M} \vDash \phi[g]$ for any $\mathcal{L}$-formula $\phi$ and any assignment $g$ of free variables in $\mathfrak{N}$, we call $\mathfrak{N}$ an <strong>elementary submodel</strong> of $\mathfrak{M}$, and write $\mathfrak{N} \preceq \mathfrak{M}$.</p>
</blockquote>

<p>Conditions 2 and 3 are stronger than 1, but 2 and 3 do not imply each other.</p>

<ol>
  <li>$\mathfrak{N} \subseteq \mathfrak{M}$, $\mathfrak{N} \equiv \mathfrak{M}$</li>
  <li>$\mathfrak{N} \subseteq \mathfrak{M}$, $\mathfrak{N} \cong \mathfrak{M}$</li>
  <li>$\mathfrak{N} \preceq \mathfrak{M}$</li>
</ol>

<p>The reason why 2 and 3 do not imply each other is that 2 requires structural equivalence, making it no weaker than 3, whilst 3 requires equivalence for arbitrary assignments, making it no weaker than 2. For instance, for $\mathfrak{M} = (\mathbb{R}, +, \cdot)$, for $\mathfrak{N}$ to be an isomorphic submodel of $\mathfrak{M}$, it must be <em>structurally</em> identical with respect to <em>constructible</em> real numbers, whereas for $\mathfrak{N}$ to be an elementary submodel of $\mathfrak{M}$, the two models must be <em>elementarily</em> equivalent with respect to <em>all</em> real numbers.</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>2</th>
      <th>3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>2 is no weaker than 3</td>
      <td>Structural identity</td>
      <td>Elementary identity</td>
    </tr>
    <tr>
      <td>3 is no weaker than 2</td>
      <td>Constructible objects</td>
      <td>Arbitrary objects</td>
    </tr>
  </tbody>
</table>

<p>For example, as we saw earlier, $(2\mathbb{Z}, +)$ is an isomorphic submodel of $(\mathbb{Z}, +)$, but considering the assignment $x \mapsto 2$ for $\exists y \; (y + y = x)$, we can see that it is not an elementary submodel.</p>

<h2 id="the-łoś-tarski-theorem">The Łoś-Tarski Theorem</h2>

<p>Let $\mathfrak{M}$ be a model of $T$. What kind of theory must $T$ be for any submodel of $\mathfrak{M}$ to also be a model of $T$? The answer is given by the following theorem.</p>

<blockquote>
  <p><strong>The Łoś-Tarski Preservation Theorem.</strong> A necessary and sufficient condition for submodels of models of $T$ to also be models of $T$ is that $T$ is equivalent to a theory consisting of $\Pi_1$ sentences.</p>
</blockquote>

<p>What $\Pi_1$ sentences are has been covered in the <a href="https://dimenerno.github.io/2025/02/07/arithmetic-hierarchy/">arithmetic hierarchy</a> article. To explain briefly, these are theories having only $\forall$ as quantifiers. Intuitively, $\Pi_1$ sentences become easier to satisfy as the domain is restricted, so if $T$ is a $\Pi_1$ theory, then $T$ will be preserved under submodels. The necessity is somewhat more challenging to prove.</p>

<p><strong>Proof.</strong> The sufficiency is almost trivial, so we prove only the necessity. We prove the following lemma.</p>

<blockquote>
  <p><strong>Lemma.</strong> Let $T$ be a consistent theory in language $\mathcal{L}$. When a set $\Delta$ of $\mathcal{L}$-sentences satisfies the following two conditions, $\Delta$ contains an axiomatisation of $T$.</p>

  <ol>
    <li>$\Delta$ is closed under disjunction. That is, if $\phi, \psi \in \Delta$, then $\phi \lor \psi \in \Delta$.</li>
    <li>For a model $\mathfrak{A}$ of $T$, if $\mathfrak{B}$ satisfies all sentences in $\Delta$ that are satisfied in $\mathfrak{A}$, then $\mathfrak{B}$ is also a model of $T$.</li>
  </ol>
</blockquote>

<p><em>Proof of the lemma.</em> Let $\Gamma = \lbrace  \delta \in \Delta : T \vDash \delta \rbrace $. To show that $\Delta$ contains an axiomatisation of $T$, it suffices to show the following:</p>

\[\mathfrak{B} \vDash \Gamma \implies \mathfrak{B} \vDash T\]

<p>Suppose $\mathfrak{B}$ is a model of $\Gamma$. Define:</p>

\[\Sigma = \{ \lnot \delta : \delta \in \Delta, \mathfrak{B} \not\vDash \delta \}\]

<p>We show that $T \cup \Sigma$ is a consistent theory. If $T \cup \Sigma$ were inconsistent, then for some $\lnot\delta_1, \dots, \lnot\delta_n \in \Sigma$, we would have $T \vdash \lnot(\lnot\delta_1 \land \cdots \land \lnot\delta_n)$, so $T \vdash \delta_1 \lor \cdots \lor \delta_n$. Since $\Delta$ is closed under disjunction, $\delta_1 \lor \cdots \lor \delta_n \in \Delta$. By the definition of $\Gamma$, $\delta_1 \lor \cdots \lor \delta_n \in \Gamma$, so $\mathfrak{B} \vDash \delta_1 \lor \cdots \lor \delta_n$. This contradicts $\lnot\delta_1, \dots, \lnot\delta_n \in \Sigma$.</p>

<p>Since $T \cup \Sigma$ is consistent, by the completeness theorem it has a model. Let this model be $\mathfrak{A}$. Since $\mathfrak{B}$ satisfies all sentences in $\Delta$ that $\mathfrak{A}$ satisfies, by assumption $\mathfrak{B}$ is a model of $T$. □</p>

<p>Now we proceed to the proof of the main theorem. Let $\Delta$ be the set of all $\Pi_1$ sentences in $\mathcal{L}$. Our goal is to show that $\Delta$ contains an axiomatisation of $T$. Since $\Pi_1$ sentences are closed under disjunction, by the lemma it suffices to show the following:</p>

<blockquote>
  <p>Let $T$ be a theory that is preserved under submodels. For a model $\mathfrak{A}$ of $T$, if $\mathfrak{B}$ satisfies all $\Pi_1$ sentences satisfied in $\mathfrak{A}$, then $\mathfrak{B}$ is also a model of $T$.</p>
</blockquote>

<p>Following the notation from <a href="https://dimenerno.github.io/2025/05/01/elementary-embedding/">this article</a>, let us define $E(\mathfrak{B})$. That is, $\mathfrak{M}$ satisfies $E(\mathfrak{B})$ when $\mathfrak{B} \preceq \mathfrak{M}$.</p>

<p>We show that $T \cup E(\mathfrak{B})$ is consistent. If $T \cup E(\mathfrak{B})$ were inconsistent, then there would exist some sentence $\phi(b_1, \dots, b_n)$ from $E(\mathfrak{B})$ such that $T \cup \lbrace  \phi \rbrace $ has no model. Therefore, $\mathfrak{A}$, being a model of $T$, cannot be extended to an $\mathcal{L} \cup \lbrace b_1, \dots, b_n \rbrace $ model that satisfies $\phi$. That is, the following holds:</p>

\[\mathfrak{A} \vDash \forall x_1 \cdots \forall x_n \lnot \phi(x_1, \dots, x_n)\]

<p>The right-hand side is a $\Pi_1$ sentence, so by assumption $\mathfrak{B} \vDash \forall x_1 \cdots \forall x_n \lnot \phi(x_1, \dots, x_n)$. However, since $\phi(b_1, \dots, b_n) \in E(\mathfrak{B})$, this is a contradiction. Therefore, $T \cup E(\mathfrak{B})$ is consistent and by the completeness theorem has a model $\mathfrak{C}$. Since $\mathfrak{C}$ satisfies $E(\mathfrak{B})$, we have $\mathfrak{B} \preceq \mathfrak{C}$. Meanwhile, since $\mathfrak{C}$ is a model of $T$, which is preserved under submodels, $\mathfrak{B}$ is a model of $T$. ■</p>

<h2 id="applications">Applications</h2>

<p>The first-order logical axiomatisation of groups differs depending on whether the identity element and inverse are represented as separate constant $e$ and function $(-)^{-1}$.</p>

<h4 id="without-representation">Without representation</h4>

<p>Define theory $T_1$ in language $\mathcal{L}_1 = \lbrace  G, \cdot \rbrace $ as follows:</p>

<ul>
  <li>$\forall x, y, z : (x \cdot y) \cdot z = x \cdot (y \cdot z)$</li>
  <li>$\exists x \forall y : x \cdot y = y \cdot x = y$</li>
  <li>$\forall x \exists y \forall z : (x \cdot y) \cdot z = (y \cdot x) \cdot z = z$</li>
</ul>

<h4 id="with-representation">With representation</h4>

<p>Define theory $T_2$ in language $\mathcal{L}_2 = \lbrace  G, \cdot, e, (-)^{-1} \rbrace $ as follows:</p>

<ul>
  <li>$\forall x, y, z : (x \cdot y) \cdot z = x \cdot (y \cdot z)$</li>
  <li>$\forall x : x \cdot e = e \cdot x = x$</li>
  <li>$\forall x : x \cdot x^{-1} = x^{-1} \cdot x = e$</li>
</ul>

<p>$T_1$ is not a $\Pi_1$ theory, but $T_2$ is a $\Pi_1$ theory. Therefore, by the Łoś-Tarski theorem, $T_1$ is not submodel-preserving whilst $T_2$ is preserving. That $T_1$ is not submodel-preserving means that a subset of a group being closed under the operation does not always make it a subgroup<small>(for instance, the subset $\mathbb{Z}_{&gt; 0}$ of $\mathbb{Z}$ is closed under the operation but is not a group as it lacks inverses)</small>. Conversely, that $T_2$ is submodel-preserving means the following holds:</p>

<blockquote>
  <p>For a group $G$, if a subset $H$ of $G$ satisfies the following, then $H$ is a subgroup of $G$:</p>

  <ol>
    <li>Closed under the operation.</li>
    <li>Closed under inverses.</li>
    <li>Contains the identity element of $G$.</li>
  </ol>
</blockquote>

<p>However, the following stronger result generally holds:</p>

<blockquote>
  <p>For a group $G$, if a subset $H$ of $G$ satisfies the following, then $H$ is a subgroup of $G$:</p>

  <ol>
    <li>Closed under the operation.</li>
    <li>Closed under inverses.</li>
  </ol>
</blockquote>

<p>That is, even in language $\mathcal{L}_3 = \lbrace  G, \cdot, (-)^{-1} \rbrace$ lacking a constant to denote the identity element, the theory of groups is submodel-preserving, which means there exists a $\Pi_1$ theory formalising groups in $\mathcal{L}_3$. With some clever thinking, one can indeed discover that the following theory $T_3$ exists:</p>

<ul>
  <li>$\forall x, y, z : (x \cdot y) \cdot z = x \cdot (y \cdot z)$</li>
  <li>$\forall x, y : (x \cdot x^{-1}) \cdot y = y \cdot (x \cdot x^{-1}) = y$</li>
</ul>


  </div>
  <div style="margin-bottom: 6em"></div>
  
    <div class="post fade-in-section" data-lang="ko" style="display: none">
      <h1 class="post-title">
        <a href="/2025/04/10/completeness-theorem"> 완전성 정리와 뢰벤하임-스콜렘 정리 </a>
      </h1>
    <span class="post-date">10 Apr 2025</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/수학/'">
        수학
      </div>
      
      <div class="tag" onclick="location.href='/tags/논리학/'">
        논리학
      </div>
      
    </div>
     <p>괴델의 완전성 정리와 뢰벤하임-스콜렘 정리는 수리논리학의 가장 기본적인 정리들이다. 그래도 기본기를 다져보는 김에, 이 정리들의 증명을 복습해 보았다. 이 글에서 $T$는 언어 $\mathcal{L}$의 1차 논리 이론으로 간주한다.</p>

<h2 id="괴델의-완전성-정리">괴델의 완전성 정리</h2>

<blockquote>
  <p><strong>괴델의 완전성 정리.</strong> $T \vDash \phi$라면 $T \vdash \phi$이다.</p>
</blockquote>

<h3 id="증명">증명</h3>

<p>다음의 동치인 진술을 증명한다. (연습문제: 왜 동치인가?)</p>

<blockquote>
  <p>$T$가 무모순적인<sub>consistent</sub> 이론이라면, $T$는 모델을 가진다.</p>
</blockquote>

<h4 id="1-mathcall을-스콜렘-언어-mathcall_s로-확장하기">1. $\mathcal{L}$을 스콜렘 언어 $\mathcal{L}_S$로 확장하기</h4>

<p>$\kappa = \mathrm{max}(\aleph_0, |\mathcal{L}|)$라고 하자. $T$에 상수 $\lbrace  c_\alpha \rbrace _{\alpha \in \kappa}$ ($\alpha$는 서수)를 추가한 언어를 $\mathcal{L}_S$라고 하자. 여기서 첨자 $S$는 각 상수가 <strong>스콜렘 상수<sub>Skolem constant</sub></strong>의 역할을 담당할 것임을 의미한다.</p>

<h4 id="2-t를-헨킨-이론-t_h로-확장하기">2. $T$를 헨킨 이론 $T_H$로 확장하기</h4>

<p>$\mathcal{L}_S$의 명제 중 하나의 자유변수를 가지는 명제들의 집합의 크기는 $\kappa$와 같으므로, 정렬 원리로부터 $\lbrace  P_\alpha \rbrace _{\alpha \in \kappa}$와 같이 나타낼 수 있다. 이로부터 다음의 문장 집합을 정의한다.</p>

\[\Sigma = \{ Q_\alpha := \exists x P_\alpha \rightarrow P_\alpha(c_\lambda) \mid \alpha \in \kappa \}\]

<p>여기서 $c_\lambda$는 $P_\alpha$와 $Q_\beta \; (\beta &lt; \alpha)$에 등장하지 않는 상수 중 첨자가 최소인 상수이다(그러한 상수가 존재함은 서수가 정렬이라는 사실로부터 보장된다). 이제 $T_H = T \cup \Sigma$로 정의한다. $T_H$를 <strong>헨킨 이론<sub>Henkin theory</sub></strong>이라고 하고, $Q_\alpha$를 헨킨 공리라고 한다.</p>

<h4 id="3-t_h를-극대적으로-무모순적인-이론-overlinet_h로-확장하기">3. $T_H$를 극대적으로 무모순적인 이론 $\overline{T_H}$로 확장하기</h4>

<blockquote>
  <p><strong>린덴바움 보조정리.</strong> $T$가 무모순적인 이론일 때, $T$를 확장하는 극대적으로 무모순적인<sub>maximally consistent</sub> 이론 $\overline{T}$가 존재한다. 즉, $T \subseteq T’$이고 임의의 $\mathcal{L}$ 문장 $\phi$에 대해 $\phi \in \overline{T}$거나 $\lnot\phi \in \overline{T}$이다.</p>
</blockquote>

<p><strong>증명.</strong> $T$를 확장하는 무모순적인 이론들의 모임에 $\subseteq$로 순서 관계를 준 뒤, 초른의 보조정리를 적용한다.</p>

<p>$T$가 무모순적인 이론일 때 $T_H$ 또한 무모순적임을 쉽게 보일 수 있다. 따라서 린덴바움 보조정리에 의해 $T_H$를 확장하는 극대적으로 무모순적인 이론 $\overline{T_H}$가 존재한다.</p>

<h4 id="4-overlinet_h의-표준적canonical-모델-정의하기">4. $\overline{T_H}$의 표준적<sub>canonical</sub> 모델 정의하기</h4>

<p>$c_\alpha \sim c_\beta$를 $(c_\alpha = c_\beta) \in \overline{T_H}$일 때 성립하는 관계로 정의하자. $\overline{T_H}$가 무모순적인 이론이라는 사실로부터 $\sim$이 동치 관계임을 보일 수 있다. 따라서 상수들의 동치류 $[c_\alpha]$가 잘 정의된다. 이제 다음과 같이 $\mathcal{L}_S$의 구조 $\mathfrak{M}$을 정의한다.</p>

<ol>
  <li>상수: $c_\alpha^{\mathfrak{M}} = [c_\alpha]$</li>
  <li>술어: $R^{\mathfrak{M}}(c_{\alpha_1}^\mathfrak{M}, \dots, c_{\alpha_n}^{\mathfrak{M}}) \iff \overline{T_H} \vdash R(c_{\alpha_1}, \dots, c_{\alpha_n}) $</li>
  <li>함수: $f(c_\alpha^\mathfrak{M}) = c_\beta^\mathfrak{M} \iff T_H \vdash \exists x (f(c_\alpha) = x) \rightarrow f(c_\alpha) = c_\beta$</li>
</ol>

<p>$\overline{T_H}$가 극대적으로 무모순적이므로 2가 잘 정의되고, 헨킨 이론이므로 3이 잘 정의된다. 따라서 $\mathfrak{M}$이 잘 정의되며, $\mathfrak{M}$이 $\overline{T_H}$의 모델임을 쉽게 확인할 수 있다. 그리고 $\mathfrak{M}$은 $T$의 모델이기도 하므로, $T$는 모델을 가진다. ■</p>

<p><strong>Remark 1.</strong> 완전성 정리의 증명은 정렬 원리와 초른의 보조정리를 사용한다는 점에서 선택 공리에 의존적이다. 쾨니히 보조정리나 의존적 선택 공리와 같이 더 약한 유형의 선택 공리로도 증명할 수 있긴 하다.</p>

<p><strong>Remark 2.</strong> <strong>콤팩트성 정리</strong>가 완전성 정리의 따름정리로서 얻어진다. (연습문제)</p>

<p><strong>Remark 3.</strong> 완전성 정리의 증명에서 구축하는 모델의 크기는 $\kappa = \mathrm{max}(\aleph_0, |\mathcal{L}|)$를 넘지 않는다. 마지막 단계에서 동치류를 취하므로 $\kappa$와 같다는 보장은 없다.</p>

<h2 id="뢰벤하임-스콜렘-정리">뢰벤하임-스콜렘 정리</h2>

<blockquote>
  <p><strong>뢰벤하임-스콜렘 정리.</strong> $T$가 무한 모델을 가진다고 하자. 임의의 $\kappa \geq \mathrm{max}(\aleph_0, |\mathcal{L}|)$에 대해, 크기가 $\kappa$인 $T$의 모델이 존재한다.</p>
</blockquote>

<h3 id="증명-1">증명</h3>

<h4 id="하향-뢰벤하임-스콜렘-정리">하향 뢰벤하임-스콜렘 정리</h4>

<blockquote>
  <p><strong>하향 뢰벤하임-스콜렘 정리.</strong> $T$는 크기가 $\mathrm{max}(\aleph_0, |\mathcal{L}|)$을 넘지 않는 모델을 가진다.</p>
</blockquote>

<p><strong>증명.</strong> Remark 2에서 즉시 얻어진다. □</p>

<h4 id="상향-뢰벤하임-스콜렘-정리">상향 뢰벤하임-스콜렘 정리</h4>

<blockquote>
  <p><strong>상향 뢰벤하임-스콜렘 정리.</strong> $T$가 무한 모델을 가진다고 하자. 임의의 무한 기수 $\kappa$에 대해, 크기가 $\kappa$ 이상인 $T$의 모델이 존재한다.</p>
</blockquote>

<p><strong>증명.</strong> $\mathcal{L}’$을 $\mathcal{L}$에 상수 $\lbrace  c_\alpha \rbrace _{\alpha \in \kappa}$를 추가한 언어로 정의하자. 다음의 $\mathcal{L}’$-문장 집합을 정의하자.</p>

\[\Sigma = \{ c_\alpha \neq c_\beta : \alpha, \beta \in \kappa, \alpha \neq \beta \}\]

<p>$T’ = T \cup \Sigma$라고 하자. <em>$T$가 무한 모델 $\mathfrak{M}$을 가지므로,</em> 임의의 $T’$의 유한 부분이론은 $\mathfrak{M}$에 의해 만족된다. 따라서 콤팩트성 정리에 의해 $T’$은 무모순적이며, 완전성 정리에 의해 모델을 가진다. $\Sigma$는 $T’$의 모델이 적어도 $\kappa$개의 원소를 가질 것을 요구하므로, $T’$은 크기가 $\kappa$ 이상인 모델을 가지며, 이에 따라 $T$ 또한 크기가 $\kappa$ 이상인 모델을 가진다. □</p>

<h4 id="뢰벤하임-스콜렘-정리-1">뢰벤하임-스콜렘 정리</h4>

<p>$\kappa \geq \mathrm{max}(\aleph_0, |\mathcal{L}|)$라고 하자. $\mathcal{L}’$과 $T’$을 앞선 바와 같이 정의한다.</p>

<p>$\mathrm{max}(\aleph_0, |\mathcal{L}’|) = \kappa$이므로 하향 뢰벤하임-스콜렘 정리에 의해 $T’$은 크기가 $\kappa$를 넘지 않는 모델을 가진다. 그런데 상향 뢰벤하임-스콜렘 정리의 증명에서 지적했듯이 $T’$의 모든 모델은 크기가 $\kappa$ 이상이다. 따라서 $T’$은 크기가 정확히 $\kappa$인 모델을 가지며, 이에 따라 $T$ 또한 크기가 정확히 $\kappa$인 모델을 가진다. ■</p>

  </div>
  <div style="margin-bottom: 6em"></div>
  
    <div class="post fade-in-section" data-lang="en" style="display: none">
      <h1 class="post-title">
        <a href="/2025/04/10/completeness-theorem/en"> Completeness Theorem and Löwenheim-Skolem Theorem </a>
      </h1>
    <span class="post-date">10 Apr 2025</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/mathematics/'">
        Mathematics
      </div>
      
      <div class="tag" onclick="location.href='/tags/logic/'">
        Logic
      </div>
      
    </div>
     <blockquote>
  <p>This post was machine translated and has not yet been proofread. It may contain minor errors or unnatural expressions. Proofreading will be done in the near future.</p>
</blockquote>

<p>Gödel’s completeness theorem and the Löwenheim-Skolem theorem are amongst the most fundamental theorems in mathematical logic. To consolidate the fundamentals, I have revisited the proofs of these theorems. In this article, $T$ is considered as a first-order logical theory in language $\mathcal{L}$.</p>

<h2 id="gödels-completeness-theorem">Gödel’s Completeness Theorem</h2>

<blockquote>
  <p><strong>Gödel’s Completeness Theorem.</strong> If $T \vDash \phi$, then $T \vdash \phi$.</p>
</blockquote>

<h3 id="proof">Proof</h3>

<p>We prove the following equivalent statement. (Exercise: Why is this equivalent?)</p>

<blockquote>
  <p>If $T$ is a consistent theory, then $T$ has a model.</p>
</blockquote>

<h4 id="1-extending-mathcall-to-the-skolem-language-mathcall_s">1. Extending $\mathcal{L}$ to the Skolem language $\mathcal{L}_S$</h4>

<p>Let $\kappa = \mathrm{max}(\aleph_0, |\mathcal{L}|)$. Let $\mathcal{L}_S$ be the language obtained by adding constants $\lbrace  c_\alpha \rbrace _{\alpha \in \kappa}$ (where $\alpha$ is an ordinal) to $T$. Here, the subscript $S$ indicates that each constant will serve as a <strong>Skolem constant</strong>.</p>

<h4 id="2-extending-t-to-the-henkin-theory-t_h">2. Extending $T$ to the Henkin theory $T_H$</h4>

<p>Since the size of the set of formulae in $\mathcal{L}_S$ with one free variable is equal to $\kappa$, by the well-ordering principle, we can represent them as $\lbrace  P_\alpha \rbrace _{\alpha \in \kappa}$. From this, we define the following set of sentences:</p>

\[\Sigma = \{ Q_\alpha := \exists x P_\alpha \rightarrow P_\alpha(c_\lambda) \mid \alpha \in \kappa \}\]

<p>where $c_\lambda$ is the constant with the smallest index amongst the constants that do not appear in $P_\alpha$ and $Q_\beta \; (\beta &lt; \alpha)$ (the existence of such a constant is guaranteed by the fact that ordinals are well-ordered). Now we define $T_H = T \cup \Sigma$. We call $T_H$ the <strong>Henkin theory</strong> and $Q_\alpha$ the Henkin axioms.</p>

<h4 id="3-extending-t_h-to-a-maximally-consistent-theory-overlinet_h">3. Extending $T_H$ to a maximally consistent theory $\overline{T_H}$</h4>

<blockquote>
  <p><strong>Lindenbaum’s Lemma.</strong> When $T$ is a consistent theory, there exists a maximally consistent theory $\overline{T}$ that extends $T$. That is, $T \subseteq T’$ and for any $\mathcal{L}$ sentence $\phi$, either $\phi \in \overline{T}$ or $\lnot\phi \in \overline{T}$.</p>
</blockquote>

<p><strong>Proof.</strong> We order the collection of consistent theories that extend $T$ by $\subseteq$ and apply Zorn’s lemma.</p>

<p>When $T$ is a consistent theory, we can easily show that $T_H$ is also consistent. Therefore, by Lindenbaum’s lemma, there exists a maximally consistent theory $\overline{T_H}$ that extends $T_H$.</p>

<h4 id="4-defining-the-canonical-model-of-overlinet_h">4. Defining the canonical model of $\overline{T_H}$</h4>

<p>Let $c_\alpha \sim c_\beta$ be the relation that holds when $(c_\alpha = c_\beta) \in \overline{T_H}$. From the fact that $\overline{T_H}$ is a consistent theory, we can show that $\sim$ is an equivalence relation. Therefore, the equivalence classes $[c_\alpha]$ of constants are well-defined. We now define a structure $\mathfrak{M}$ for $\mathcal{L}_S$ as follows:</p>

<ol>
  <li>Constants: $c_\alpha^{\mathfrak{M}} = [c_\alpha]$</li>
  <li>Predicates: $R^{\mathfrak{M}}(c_{\alpha_1}^\mathfrak{M}, \dots, c_{\alpha_n}^{\mathfrak{M}}) \iff \overline{T_H} \vdash R(c_{\alpha_1}, \dots, c_{\alpha_n}) $</li>
  <li>Functions: $f(c_\alpha^\mathfrak{M}) = c_\beta^\mathfrak{M} \iff T_H \vdash \exists x (f(c_\alpha) = x) \rightarrow f(c_\alpha) = c_\beta$</li>
</ol>

<p>Since $\overline{T_H}$ is maximally consistent, (2) is well-defined, and since it is a Henkin theory, (3) is well-defined. Therefore, $\mathfrak{M}$ is well-defined, and we can easily verify that $\mathfrak{M}$ is a model of $\overline{T_H}$. Since $\mathfrak{M}$ is also a model of $T$, $T$ has a model. ■</p>

<p><strong>Remark 1.</strong> The proof of the completeness theorem depends on the axiom of choice in that it uses the well-ordering principle and Zorn’s lemma. It can also be proved using weaker forms of the axiom of choice such as König’s lemma or the axiom of dependent choice.</p>

<p><strong>Remark 2.</strong> The <strong>compactness theorem</strong> is obtained as a corollary of the completeness theorem. (Exercise)</p>

<p><strong>Remark 3.</strong> The size of the model constructed in the proof of the completeness theorem does not exceed $\kappa = \mathrm{max}(\aleph_0, |\mathcal{L}|)$. Since we take equivalence classes in the final step, there is no guarantee that it equals $\kappa$.</p>

<h2 id="löwenheim-skolem-theorem">Löwenheim-Skolem Theorem</h2>

<blockquote>
  <p><strong>Löwenheim-Skolem Theorem.</strong> Suppose $T$ has an infinite model. For any $\kappa \geq \mathrm{max}(\aleph_0, |\mathcal{L}|)$, there exists a model of $T$ of size $\kappa$.</p>
</blockquote>

<h3 id="proof-1">Proof</h3>

<h4 id="downward-löwenheim-skolem-theorem">Downward Löwenheim-Skolem Theorem</h4>

<blockquote>
  <p><strong>Downward Löwenheim-Skolem Theorem.</strong> $T$ has a model of size not exceeding $\mathrm{max}(\aleph_0, |\mathcal{L}|)$.</p>
</blockquote>

<p><strong>Proof.</strong> This follows immediately from Remark 2. □</p>

<h4 id="upward-löwenheim-skolem-theorem">Upward Löwenheim-Skolem Theorem</h4>

<blockquote>
  <p><strong>Upward Löwenheim-Skolem Theorem.</strong> Suppose $T$ has an infinite model. For any infinite cardinal $\kappa$, there exists a model of $T$ of size at least $\kappa$.</p>
</blockquote>

<p><strong>Proof.</strong> Let $\mathcal{L}’$ be the language obtained by adding constants $\lbrace  c_\alpha \rbrace _{\alpha \in \kappa}$ to $\mathcal{L}$. Define the following set of $\mathcal{L}’$-sentences:</p>

\[\Sigma = \{ c_\alpha \neq c_\beta : \alpha, \beta \in \kappa, \alpha \neq \beta \}\]

<p>Let $T’ = T \cup \Sigma$. <em>Since $T$ has an infinite model $\mathfrak{M}$,</em> any finite subtheory of $T’$ is satisfied by $\mathfrak{M}$. Therefore, by the compactness theorem, $T’$ is consistent, and by the completeness theorem, it has a model. Since $\Sigma$ requires that any model of $T’$ has at least $\kappa$ elements, $T’$ has a model of size at least $\kappa$, and thus $T$ also has a model of size at least $\kappa$. □</p>

<h4 id="löwenheim-skolem-theorem-1">Löwenheim-Skolem Theorem</h4>

<p>Let $\kappa \geq \mathrm{max}(\aleph_0, |\mathcal{L}|)$. Define $\mathcal{L}’$ and $T’$ as above.</p>

<p>Since $\mathrm{max}(\aleph_0, |\mathcal{L}’|) = \kappa$, by the downward Löwenheim-Skolem theorem, $T’$ has a model of size not exceeding $\kappa$. However, as pointed out in the proof of the upward Löwenheim-Skolem theorem, every model of $T’$ has size at least $\kappa$. Therefore, $T’$ has a model of size exactly $\kappa$, and thus $T$ also has a model of size exactly $\kappa$. ■</p>


  </div>
  <div style="margin-bottom: 6em"></div>
  
    <div class="post fade-in-section" data-lang="ko" style="display: none">
      <h1 class="post-title">
        <a href="/2025/04/04/van-kampen"> 자이페르트-판 캄펀 정리에 대한 노트 </a>
      </h1>
    <span class="post-date">04 Apr 2025</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/수학/'">
        수학
      </div>
      
      <div class="tag" onclick="location.href='/tags/위상수학/'">
        위상수학
      </div>
      
      <div class="tag" onclick="location.href='/tags/범주론/'">
        범주론
      </div>
      
    </div>
     <p>위상공간 $X$의 열린 덮개 $U, V$를 생각하자. 위상공간들의 범주 $\mathbf{Top}$에서 다음 푸시아웃<sub>pushout</sub> 도식의 극한은 $X$이다.</p>

<p><img src="/public/seifert-1.png" style="margin: 1.5em auto 2em auto; width: 250px" /></p>

<p>자이페르트-판 캄펀 정리는, $U, V$가 경로 연결<sub>path connected</sub>이고 $x_0 \in U \cap V$일 때, 위 극한이 함자 $\pi_1(-, x_0): \mathbf{Top} \to \mathbf{Grp}$에 대해 보존된다는 내용이다.</p>

<p><img src="/public/seifert-2.png" style="margin: 2em auto; width: 300px" /></p>

<p>그런데 푸시아웃의 극한은 왼쪽 도식의 쌍대 극한<sub>colimit</sub>이다. 만약 $I$에 대응되는 대상이 초기 대상<sub>initial object</sub>이라면, 사상 $I \to J, J \to K$는 유일하게 결정되므로 사실상 왼쪽 도식의 쌍대 극한은 오른쪽 도식의 쌍대 극한과 같으며, 이는 <a href="https://dimenerno.github.io/2025/04/02/box-v-product/">범주론적 합</a>에 해당한다.</p>

<div style="display: grid; margin: 0 auto; width: 400px; grid-template-columns: 1fr 1fr; gap: 3em; align-items: center;">
  <img src="/public/pushout-diag.png" style="width: 200px; margin: 1em 0 2em 0;" />
  <img src="/public/product-diag.png" style="width: 200px; margin: 1em 0 2em 0;" />
</div>

<p>$\mathbf{Grp}$의 초기 대상은 자명군<sub>trivial group</sub>이며, 범주론적 합은 자유곱이다. 이에 따라 $U \cap V$가 단순 연결 공간일 때, $\pi_1(X)$는 $\pi_1(U)$와 $\pi_1(V)$의 자유곱이라는 결론을 얻는다.</p>

  </div>
  <div style="margin-bottom: 6em"></div>
  
    <div class="post fade-in-section" data-lang="en" style="display: none">
      <h1 class="post-title">
        <a href="/2025/04/04/van-kampen/en"> Notes on the Seifert-van Kampen Theorem </a>
      </h1>
    <span class="post-date">04 Apr 2025</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/mathematics/'">
        Mathematics
      </div>
      
      <div class="tag" onclick="location.href='/tags/topology/'">
        Topology
      </div>
      
      <div class="tag" onclick="location.href='/tags/category-theory/'">
        Category Theory
      </div>
      
    </div>
     <blockquote>
  <p>This post was machine translated and has not yet been proofread. It may contain minor errors or unnatural expressions. Proofreading will be done in the near future.</p>
</blockquote>

<p>Consider an open cover $U, V$ of a topological space $X$. In the category of topological spaces $\mathbf{Top}$, the limit of the following pushout diagram is $X$.</p>

<p><img src="/public/seifert-1.png" style="margin: 1.5em auto 2em auto; width: 250px" /></p>

<p>The Seifert-van Kampen theorem states that when $U, V$ are path connected and $x_0 \in U \cap V$, the above limit is preserved under the functor $\pi_1(-, x_0): \mathbf{Top} \to \mathbf{Grp}$.</p>

<p><img src="/public/seifert-2.png" style="margin: 2em auto; width: 300px" /></p>

<p>However, the limit of a pushout is the colimit of the left diagram. If the object corresponding to $I$ is an initial object, then the morphisms $I \to J, J \to K$ are uniquely determined, so the colimit of the left diagram is essentially the same as the colimit of the right diagram, which corresponds to the <a href="https://dimenerno.github.io/2025/04/02/box-v-product/">categorical sum</a>.</p>

<div style="display: grid; margin: 0 auto; width: 400px; grid-template-columns: 1fr 1fr; gap: 3em; align-items: center;">
  <img src="/public/pushout-diag.png" style="width: 200px; margin: 1em 0 2em 0;" />
  <img src="/public/product-diag.png" style="width: 200px; margin: 1em 0 2em 0;" />
</div>

<p>The initial object in $\mathbf{Grp}$ is the trivial group, and the categorical sum is the free product. Accordingly, when $U \cap V$ is a simply connected space, we obtain the conclusion that $\pi_1(X)$ is the free product of $\pi_1(U)$ and $\pi_1(V)$.</p>

  </div>
  <div style="margin-bottom: 6em"></div>
  
    <div class="post fade-in-section" data-lang="ko" style="display: none">
      <h1 class="post-title">
        <a href="/2025/04/02/box-v-product"> 범주론적 관점에서의 곱 위상·상자 위상과 직곱·직합의 차이 </a>
      </h1>
    <span class="post-date">02 Apr 2025</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/수학/'">
        수학
      </div>
      
      <div class="tag" onclick="location.href='/tags/범주론/'">
        범주론
      </div>
      
      <div class="tag" onclick="location.href='/tags/위상수학/'">
        위상수학
      </div>
      
    </div>
     <h2 id="곱-위상과-상자-위상">곱 위상과 상자 위상</h2>

<p>학부 위상에서 곱 위상<sub>product topology</sub>과 상자 위상<sub>box topology</sub>을 다루는 부분은 많은 학생에게 난관으로 다가오는 대목이다. 겉보기에는 상자 위상이 훨씬 직관적인데, 교재에서는 상자 위상보다 곱 위상이 다루기에 자연스러운 개념이라고 가르치기 때문이다.</p>

<blockquote>
  <p><strong>정의.</strong> 위상공간의 모임 $\lbrace  X_i \rbrace _{i \in I}$에 대해, <strong>상자 위상공간</strong> $\prod X_i$는 다음의 기저로 생성되는 위상공간이다.</p>

\[\left\{ \prod U_i : U_i \text{ is open in } X_i \right\}\]
</blockquote>

<blockquote>
  <p><strong>정의.</strong> 위상공간의 모임 $\lbrace  X_i \rbrace _{i \in I}$에 대해, <strong>곱 위상공간</strong> $\prod X_i$는 다음의 기저로 생성되는 위상공간이다.</p>

\[\left\{ \prod U_i : U_i \text{ is open in } X_i,\;  U_i \neq X_i \text{ for only finitely many } i\right\}\]
</blockquote>

<p>일례로 $\mathbb{R}^\omega$에서 $(1, 1, 1, \dots)$의 근방은 각각 다음과 같다.</p>

<p><img src="/public/box-product.png" style="width: 550px; margin: 2em auto;" /></p>

<p>왜 곱 위상은 상자 위상보다 자연스러운 위상으로 간주될까? 그 이유는 범주론에서 대상의 곱을 정의하는 방법과 관련이 있다.</p>

<blockquote>
  <p><strong>정의.</strong> $X, Y$가 범주 $\mathcal{A}$의 대상이라고 하자. $P \in \mathcal{A}$와 사상 $\pi_X : P \to X$, $\pi_Y : P \to Y$에 대해, 다음 조건이 만족될 때 $P$를 $X, Y$의 <strong>곱</strong><sub>product</sub>이라고 하며, $P = X \times Y$와 같이 적는다.</p>

  <ul>
    <li>임의의 $A \in \mathcal{A}$와 $f: A \to X$, $g: A \to Y$에 대해 다음 도식이 가환이 되도록 하는 사상 $i: A \to P$가 언제나 유일하게 존재한다.</li>
  </ul>

  <p><img src="/public/categorical-product.png" style="width: 320px; margin: 2em auto; mix-blend-mode: multiply;" /></p>
</blockquote>

<p>위의 정의는 자연스러운 방식으로 3개 이상, 또는 무한한 대상들의 곱으로 일반화된다. 극한<sub>limit</sub>의 개념이 익숙한 독자라면, 곱은 이산 범주의 극한으로 이해할 수 있다. 또는, 곱은 주어진 대상들의 정보를 온전히 인코딩하는 <em>가장 작은</em> 범주로 이해할 수 있다.</p>

<p>집합들의 범주에서 곱은 곱집합과 같다. 특히 $\pi_X, \pi_Y$는 각각 $(x, y) \mapsto x$, $(x, y) \mapsto y$로 주어진다.</p>

<p><strong>위상공간들의 범주에서 곱은 상자 위상이 아닌 곱 위상이다.</strong> 이는 다음의 정리로 보증된다.</p>

<blockquote>
  <p><strong>정리.</strong> 사영함수 $\pi_k : \prod_{i \in I}X_i \to X_k$가 각 $k \in I$에 대해 연속이 되도록 하는 가장 작은 $\prod_{i \in I}X_i$의 위상은 곱 위상이다.</p>
</blockquote>

<p>상자 위상도 각 사영함수가 연속이라는 특징을 가지지만, 상자 위상은 곱 위상보다 <em>큰</em> 토폴로지이다. 따라서 상자 위상은 범주론적 곱이 아니다.</p>

<p>상자 위상이 곱이 아님을 보이는 반례를 살펴보자. $\mathbb{R}^\omega$에 상자 위상을 부여하자. 만약 상자 위상이 범주론적 곱이라면, 임의의 연속인 $f_k: \mathbb{R} \to \mathbb{R}$에 대해 $\pi_k \circ i = f_k$가 되도록 하는 연속함수 $i : \mathbb{R} \to \mathbb{R}^\omega$가 존재해야 한다. $f_k: x \mapsto kx$라면 $i$는 $x \mapsto (x, 2x, 3x, \dots)$이다. 상자 위상에서는 $U = (0, 1)^\omega$가 열린 집합이므로, $i$가 연속이면 $i^{-1}(U)$가 열린집합이다. 그런데 $i^{-1}(U) = \lbrace 0 \rbrace $이므로, 상자 위상은 곱의 성질을 만족하지 않는다.</p>

<h2 id="직곱과-직합">직곱과 직합</h2>

<p>상자 위상과 곱 위상의 차이는 전체 공간이 아닌 인덱스가 유한한지의 여부에 있다. 이와 유사한 차이를 대수학에서도 발견할 수 있다.</p>

<blockquote>
  <p><strong>정의.</strong> 벡터 공간들의 모임 $\lbrace  V_i \rbrace _{i \in I}$에 대해, <strong>직곱<sub>direct product</sub></strong> $\prod V_i$를 다음과 같이 정의한다.</p>

\[\prod V_i = \left\{ (v_i)_{i \in I} : v_i \in V_i \right\}\]
</blockquote>

<blockquote>
  <p><strong>정의.</strong> 벡터 공간들의 모임 $\lbrace  V_i \rbrace _{i \in I}$에 대해, <strong>직합<sub>direct sum</sub></strong> $\bigoplus V_i$를 다음과 같이 정의한다.</p>

\[\bigoplus V_i = \left\{ (v_i)_{i \in I} : v_i \in V_i,\; v_i \neq 0 \text{ for only finitely many }i \right\}\]
</blockquote>

<p>벡터의 연산은 항별<sub>term-wise</sub>로 정의한다. 또한 벡터 공간이 아닌 군에 대해서도 같은 방식으로 직곱과 직합을 정의할 수 있다.</p>

<p>직곱과 상자 위상, 직합과 곱 위상의 정의가 비슷하다는 점으로부터 직합이 범주론적 곱에 대응된다고 생각할 수 있지만 <strong>그렇지 않다.</strong> 대수의 경우 <strong>범주론적 곱에 대응되는 것은 직곱이다.</strong> 직합은 범주론적 곱의 조건을 일반적으로 만족하지 않는다.</p>

<p>일례로 다음의 경우를 보자. 일차원 실수 공간 $\mathbb{R}$의 직합 $\mathbb{R}^\omega$를 고려하자. 만약 직합이 범주론적 곱이라면, 임의의 선형인 $f_k: \mathbb{R} \to \mathbb{R}$에 대해 $\pi_k \circ i = f_k$가 되도록 하는 연속함수 $i : \mathbb{R} \to \mathbb{R}^\omega$가 존재해야 한다. $f_k: x \mapsto x$라면 $i$는 $x \mapsto (x, x, x, \dots)$이다. 그런데 $i(1) = (1, 1, 1, \dots) \notin \mathbb{R}^\omega$이므로, 직합은 곱의 성질을 만족하지 않는다.</p>

<p>대신 직합은 <strong>범주론적 합<sub>sum</sub></strong>에 대응된다. 범주론적 합은 곱의 켤레<sub>dual</sub>이기 때문에 쌍곱<sub>coproduct</sub>이라고도 한다.</p>

<blockquote>
  <p><strong>정의.</strong> $X, Y$가 범주 $\mathcal{A}$의 대상이라고 하자. $S \in \mathcal{A}$와 사상 $\sigma_X : X \to S$, $\sigma_Y : Y \to S$에 대해, 다음 조건이 만족될 때 $S$를 $X, Y$의 <strong>합</strong><sub>sum</sub>이라고 하며, $S = X + Y$와 같이 적는다.</p>

  <ul>
    <li>임의의 $A \in \mathcal{A}$와 $f: X \to A$, $g: Y \to X$에 대해 다음 도식이 가환이 되도록 하는 사상 $i: S \to A$가 언제나 유일하게 존재한다.</li>
  </ul>

  <p><img src="/public/categorical-sum.png" style="width: 320px; margin: 2em auto; mix-blend-mode: multiply;" /></p>
</blockquote>

<p>앞서 들었던 예시를 다시 보자. 직합 $\bigoplus_\omega \mathbb{R}$를 고려하자. $\sigma_k: \mathbb{R} \to \bigoplus_\omega \mathbb{R}$은 다음과 같이 주어진다.</p>

\[x \mapsto (0, \dots, 0, x, 0, \dots) \quad \text{($x$ is at the $k$th index)}\]

<p>$A = \mathbb{R}$이라고 하고, 항등사상 $f_k : \mathbb{R} \to \mathbb{R}$을 고려하자. $\bigoplus_\omega \mathbb{R}$가 범주론적 합이라면 $i \circ \sigma_k = f_k$가 되도록 하는 연속함수 $i : \bigoplus_\omega \mathbb{R} \to \mathbb{R}$가 존재해야 한다. 실제로 이는 다음과 같이 존재한다.</p>

\[i: (x_i)_{i \in \omega} \mapsto \sum_{i \in \omega} x_i\]

<p>$\bigoplus_\omega \mathbb{R}$의 원소는 오직 유한한 비자명 항을 가지므로 $i$는 잘 정의됨에 주목하라. 반면, 이 예시는 직곱 $\mathbb{R}^\omega$가 범주론적 합이 아님을 보여준다. 직곱의 경우 $i$가 잘 정의되지 않기 때문이다. 이는 $i$에 $(1, 1, 1, \dots)$를 대입해 보면 알 수 있다.</p>

<p>군의 경우 범주론적 곱과 범주론적 합에 대응되는 연산은 일반적인 군의 범주를 따지냐, 아벨군의 범주를 따지냐에 따라 조금 다르다. 이 부분은 간단한 노트 정도로 남겨둔다.</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>대수적 정의</th>
      <th>범주론적 정의</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>자유곱</td>
      <td>형식적 단어의 집합 + 병치 연산</td>
      <td>$\mathbf{Grp}$의 합</td>
    </tr>
    <tr>
      <td>직합</td>
      <td>유한한 비자명 항을 가지는 튜플의 집합 + 항별 연산</td>
      <td>$\mathbf{Ab}$의 합</td>
    </tr>
    <tr>
      <td>직곱</td>
      <td>튜플의 집합 + 항별 연산</td>
      <td>$\mathbf{Grp}$의 곱</td>
    </tr>
  </tbody>
</table>

  </div>
  <div style="margin-bottom: 6em"></div>
  
    <div class="post fade-in-section" data-lang="en" style="display: none">
      <h1 class="post-title">
        <a href="/2025/04/02/box-v-product/en"> The Difference Between Product and Box Topologies, and Direct Product and Direct Sum from a Categorical Perspective </a>
      </h1>
    <span class="post-date">02 Apr 2025</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/mathematics/'">
        Mathematics
      </div>
      
      <div class="tag" onclick="location.href='/tags/category-theory/'">
        Category Theory
      </div>
      
      <div class="tag" onclick="location.href='/tags/topology/'">
        Topology
      </div>
      
    </div>
     <h2 id="product-topology-and-box-topology">Product Topology and Box Topology</h2>

<p>Product topology and box topology often stir confusion among many undergraduate students. For, although the box topology appears more intuitive at first glance, textbooks teach that the product topology is the more “natural” concept to work with.</p>

<blockquote>
  <p><strong>Definition.</strong> For a collection of topological spaces $\lbrace  X_i \rbrace _{i \in I}$, the <strong>box topological space</strong> $\prod X_i$ is the topological space generated by the following basis:</p>

\[\left\{ \prod U_i : U_i \text{ is open in } X_i \right\}\]
</blockquote>

<blockquote>
  <p><strong>Definition.</strong> For a collection of topological spaces $\lbrace  X_i \rbrace _{i \in I}$, the <strong>product topological space</strong> $\prod X_i$ is the topological space generated by the following basis:</p>

\[\left\{ \prod U_i : U_i \text{ is open in } X_i,\;  U_i \neq X_i \text{ for only finitely many } i\right\}\]
</blockquote>

<p>For instance, the neighbourhoods of $(1, 1, 1, \dots)$ in $\mathbb{R}^\omega$ are as follows:</p>

<p><img src="/public/box-product.png" style="width: 550px; margin: 2em auto;" /></p>

<p>Why is the product topology considered more natural than the box topology? The reason is related to how products of objects are defined in category theory.</p>

<blockquote>
  <p><strong>Definition.</strong> Let $X, Y$ be objects in category $\mathcal{A}$. For $P \in \mathcal{A}$ and morphisms $\pi_X : P \to X$, $\pi_Y : P \to Y$, we call $P$ the <strong>product</strong> of $X, Y$ and write $P = X \times Y$ when the following condition is satisfied:</p>

  <ul>
    <li>For any $A \in \mathcal{A}$ and morphisms $f: A \to X$, $g: A \to Y$, there exists a unique morphism $i: A \to P$ such that the following diagram commutes:</li>
  </ul>

  <p><img src="/public/categorical-product.png" style="width: 320px; margin: 2em auto; mix-blend-mode: multiply;" /></p>
</blockquote>

<p>The above definition naturally generalises to products of three or more, or infinitely many objects. Readers familiar with the concept of limits will recognise that the product can be understood as the limit of a discrete category. Alternatively, the product can be understood as the <em>smallest</em> category that fully encodes the information of the given objects.</p>

<p>In the category of sets, the product coincides with the Cartesian product. In particular, $\pi_X, \pi_Y$ are given by $(x, y) \mapsto x$ and $(x, y) \mapsto y$ respectively.</p>

<p><strong>In the category of topological spaces, the product is the product topology, not the box topology.</strong> This is seen by the following theorem:</p>

<blockquote>
  <p><strong>Theorem.</strong> The smallest topology on $\prod_{i \in I}X_i$ such that the projection functions $\pi_k : \prod_{i \in I}X_i \to X_k$ are continuous for each $k \in I$ is the product topology.</p>
</blockquote>

<p>Whilst the box topology also has the property that each projection function is continuous, the box topology is a <em>larger</em> topology than the product topology. Therefore, the box topology is not the categorical product.</p>

<p>Let us examine a counterexample showing that the box topology is not the categorical product. Consider $\mathbb{R}^\omega$ with the box topology. If the box topology were the categorical product, then for any continuous functions $f_k: \mathbb{R} \to \mathbb{R}$, there would exist a continuous function $i : \mathbb{R} \to \mathbb{R}^\omega$ such that $\pi_k \circ i = f_k$. If $f_k: x \mapsto kx$, then $i$ would be $x \mapsto (x, 2x, 3x, \dots)$. In the box topology, $U = (0, 1)^\omega$ is an open set, so if $i$ were continuous, then $i^{-1}(U)$ would be an open set. However, $i^{-1}(U) = \lbrace 0 \rbrace $, so the box topology does not satisfy the property of a product. (Note that in the case of product topology, $U$ is not an open set.)</p>

<h2 id="direct-product-and-direct-sum">Direct Product and Direct Sum</h2>

<p>The difference between the box topology and product topology lies in whether only finitely many indices are allowed to be non-trivial. A similar difference can be found in algebra.</p>

<blockquote>
  <p><strong>Definition.</strong> For a collection of vector spaces $\lbrace  V_i \rbrace _{i \in I}$, the <strong>direct product</strong> $\prod V_i$ is defined as follows:</p>

\[\prod V_i = \left\{ (v_i)_{i \in I} : v_i \in V_i \right\}\]
</blockquote>

<blockquote>
  <p><strong>Definition.</strong> For a collection of vector spaces $\lbrace  V_i \rbrace _{i \in I}$, the <strong>direct sum</strong> $\bigoplus V_i$ is defined as follows:</p>

\[\bigoplus V_i = \left\{ (v_i)_{i \in I} : v_i \in V_i,\; v_i \neq 0 \text{ for only finitely many }i \right\}\]
</blockquote>

<p>Vector operations are defined term-wise. The same definitions of direct product and direct sum can be applied to groups as well.</p>

<p>From the similarity between the definitions of direct product and box topology, and direct sum and product topology, one might think that the direct sum corresponds to the categorical product, but this is not the case. In algebra, <strong>the direct product corresponds to the categorical product.</strong> The direct sum does not generally satisfy the conditions of a categorical product.</p>

<p>Consider the following example: Let us examine the direct sum $\mathbb{R}^\omega$ of one-dimensional real spaces $\mathbb{R}$. If the direct sum were the categorical product, then for any linear maps $f_k: \mathbb{R} \to \mathbb{R}$, there would exist a continuous function $i : \mathbb{R} \to \mathbb{R}^\omega$ such that $\pi_k \circ i = f_k$. If $f_k: x \mapsto x$, then $i$ would be $x \mapsto (x, x, x, \dots)$. However, $i(1) = (1, 1, 1, \dots) \notin \mathbb{R}^\omega$, so the direct sum does not satisfy the property of a product.</p>

<p>Instead, the direct sum corresponds to the <strong>categorical sum</strong>. The categorical sum is also called a <strong>coproduct</strong> because it is the dual of the categorical product.</p>

<blockquote>
  <p><strong>Definition.</strong> Let $X, Y$ be objects in category $\mathcal{A}$. For $S \in \mathcal{A}$ and morphisms $\sigma_X : X \to S$, $\sigma_Y : Y \to S$, we call $S$ the <strong>sum</strong> of $X, Y$ and write $S = X + Y$ when the following condition is satisfied:</p>

  <ul>
    <li>For any $A \in \mathcal{A}$ and morphisms $f: X \to A$, $g: Y \to A$, there exists a unique morphism $i: S \to A$ such that the following diagram commutes:</li>
  </ul>

  <p><img src="/public/categorical-sum.png" style="width: 320px; margin: 2em auto; mix-blend-mode: multiply;" /></p>
</blockquote>

<p>Let us revisit the earlier example. Consider the direct sum $\bigoplus_\omega \mathbb{R}$. The morphism $\sigma_k: \mathbb{R} \to \bigoplus_\omega \mathbb{R}$ is given by:</p>

\[x \mapsto (0, \dots, 0, x, 0, \dots) \quad \text{($x$ is at the $k$th index)}\]

<p>Let $A = \mathbb{R}$ and consider the identity morphism $f_k : \mathbb{R} \to \mathbb{R}$. If $\bigoplus_\omega \mathbb{R}$ is the categorical sum, then there must exist a continuous function $i : \bigoplus_\omega \mathbb{R} \to \mathbb{R}$ such that $i \circ \sigma_k = f_k$. Indeed, this exists as follows:</p>

\[i: (x_i)_{i \in \omega} \mapsto \sum_{i \in \omega} x_i\]

<p>Note that $i$ is well-defined because elements of $\bigoplus_\omega \mathbb{R}$ have only finitely many non-trivial terms. Conversely, this example shows that the direct product $\mathbb{R}^\omega$ is not the categorical sum. In the case of the direct product, $i$ is not well-defined. This can be seen by substituting $(1, 1, 1, \dots)$ into $i$.</p>

<p>For groups, the operations corresponding to categorical products and categorical sums differ slightly depending on whether we consider the general category of groups or the category of abelian groups. I shall leave this as a brief note.</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>Algebraic Definition</th>
      <th>Categorical Definition</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Free Product</td>
      <td>Set of formal words + concatenation operation</td>
      <td>Sum in $\mathbf{Grp}$</td>
    </tr>
    <tr>
      <td>Direct Sum</td>
      <td>Set of tuples with finitely many non-trivial terms + term-wise operation</td>
      <td>Sum in $\mathbf{Ab}$</td>
    </tr>
    <tr>
      <td>Direct Product</td>
      <td>Set of tuples + term-wise operation</td>
      <td>Product in $\mathbf{Grp}$</td>
    </tr>
  </tbody>
</table>

  </div>
  <div style="margin-bottom: 6em"></div>
  
    <div class="post fade-in-section" data-lang="ko" style="display: none">
      <h1 class="post-title">
        <a href="/2025/04/01/modal-logic"> 양상 논리 </a>
      </h1>
    <span class="post-date">01 Apr 2025</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/수학/'">
        수학
      </div>
      
      <div class="tag" onclick="location.href='/tags/논리학/'">
        논리학
      </div>
      
    </div>
     <h3 id="종류">종류</h3>

<table>
  <thead>
    <tr>
      <th>이름</th>
      <th>함의</th>
      <th>공리</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>K</strong></td>
      <td>가능세계에 대한 크립키 모델</td>
      <td>$\Box(p \to q) \to (\Box p \to \Box q)$</td>
    </tr>
    <tr>
      <td><strong>T</strong></td>
      <td>반사성</td>
      <td><strong>K</strong> + $\Box p \to p$</td>
    </tr>
    <tr>
      <td><strong>S4</strong></td>
      <td>반사성 + 추이성</td>
      <td><strong>T</strong> + $\Box p \to \Box \Box p$</td>
    </tr>
    <tr>
      <td><strong>S4.2</strong></td>
      <td>반사성 + 추이성 + R-수렴성</td>
      <td><strong>S4</strong> + $\Diamond \Box p \to \Box \Diamond p$</td>
    </tr>
    <tr>
      <td><strong>S4.3</strong></td>
      <td>반사성 + 추이성 + R-선형성</td>
      <td><strong>S4</strong> + $(\Diamond p \land \Diamond q) \to$ <br /> $(\Diamond (p \land \Diamond q) \lor \Diamond(\Diamond p \land q))$</td>
    </tr>
    <tr>
      <td><strong>S5</strong></td>
      <td>반사성 + 추이성 + 대칭성</td>
      <td><strong>S4</strong> + $(p \to \Box \Diamond p)$</td>
    </tr>
  </tbody>
</table>

<p>표의 밑으로 갈수록 논리는 엄격히 강해진다.</p>

<h3 id="양상의-축약">양상의 축약</h3>

<blockquote>
  <p><strong>정리.</strong> <strong>S4</strong>에서 양상 연산자의 나열은 6개의 조합 중 하나와 동등하며, 각 조합의 함의 관계는 다음과 같다.</p>

  <p><img src="/public/modal-operators.jpeg" width="550px" style="margin: 0 auto; mix-blend-mode: multiply;" /></p>
</blockquote>

<blockquote>
  <p><strong>정리.</strong> <strong>S5</strong>에서 양상 연산자의 나열은 $\Box$ 또는 $\Diamond$와 동등하다. 나아가 모든 논리식은 <strong>평평한<sub>flat</sub></strong> 논리식 — 즉, 양상 연산자 안에 양상 연산자가 있는 경우가 없는 논리식과 동치이다.</p>
</blockquote>

<h3 id="완전성-정리">완전성 정리</h3>

<blockquote>
  <p><strong>정리.</strong> <strong>K</strong>는 완전하다.</p>
</blockquote>

<p><strong>증명.</strong></p>

<blockquote>
  <p><strong>린덴바움 보조정리.</strong> 임의의 무모순적인 이론은 극대적으로 무모순적인<sub>maximally consistent</sub> 이론으로 확장될 수 있다.</p>
</blockquote>

<p>완전성 진술은 “무모순적인 이론은 만족 가능하다”와 동치이며, 여기에 린덴바움 보조정리를 적용하면 이는 “극대적으로 무모순적인 이론은 만족 가능하다”와 동치이다.</p>

<p>$u, v$가 극대적으로 무모순적인 이론이라고 하자. $\Box p \in u \implies p \in v$일 때 $u \lhd v$라고 적자. 다음을 어렵지 않게 보일 수 있다.</p>

<ul>
  <li>$u \lhd v$일 때, $p \in v \implies \Diamond p \in u$</li>
  <li>임의의 극대적으로 무모순적인 이론 $u$에 대해, $p \in u$이고 $\Box p \notin u$라면, 어떤 극대적으로 무모순적인 이론 $v, v’$가 존재하여 $p \in v, \lnot p \in v’$이고 $u \lhd v, v’$이다.</li>
</ul>

<p>이로부터 극대적으로 무모순적인 이론 $u$에 대해, <strong>표준적<sub>canonical</sub> 크립키 모델</strong> $\mathfrak{K} = (U, \prec, V)$를 다음과 같이 정의할 수 있다.</p>

<ul>
  <li>가능세계들의 모임 $U$는 $u \lhd v$를 만족하는 $v$의 모임이다.</li>
  <li>접근 관계 $\prec$은 $\lhd$이다.</li>
  <li>평가 함수<sub>valuation function</sub> $V(p, v)$는 $p \in v$일 때, 그리고 오직 그 경우에만 참이다.</li>
</ul>

<p>$\mathfrak{K}$가 $u$를 만족함을 어렵지 않게 보일 수 있다. ■</p>

  </div>
  <div style="margin-bottom: 6em"></div>
  
    <div class="post fade-in-section" data-lang="en" style="display: none">
      <h1 class="post-title">
        <a href="/2025/04/01/modal-logic/en"> Modal Logic </a>
      </h1>
    <span class="post-date">01 Apr 2025</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/mathematics/'">
        Mathematics
      </div>
      
      <div class="tag" onclick="location.href='/tags/logic/'">
        Logic
      </div>
      
    </div>
     <blockquote>
  <p>This post was machine translated and has not yet been proofread. It may contain minor errors or unnatural expressions. Proofreading will be done in the near future.</p>
</blockquote>

<h3 id="types">Types</h3>

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Entailment</th>
      <th>Axioms</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>K</strong></td>
      <td>Kripke model for possible worlds</td>
      <td>$\Box(p \to q) \to (\Box p \to \Box q)$</td>
    </tr>
    <tr>
      <td><strong>T</strong></td>
      <td>Reflexivity</td>
      <td><strong>K</strong> + $\Box p \to p$</td>
    </tr>
    <tr>
      <td><strong>S4</strong></td>
      <td>Reflexivity + Transitivity</td>
      <td><strong>T</strong> + $\Box p \to \Box \Box p$</td>
    </tr>
    <tr>
      <td><strong>S4.2</strong></td>
      <td>Reflexivity + Transitivity + R-convergence</td>
      <td><strong>S4</strong> + $\Diamond \Box p \to \Box \Diamond p$</td>
    </tr>
    <tr>
      <td><strong>S4.3</strong></td>
      <td>Reflexivity + Transitivity + R-linearity</td>
      <td><strong>S4</strong> + $(\Diamond p \land \Diamond q) \to$ <br /> $(\Diamond (p \land \Diamond q) \lor \Diamond(\Diamond p \land q))$</td>
    </tr>
    <tr>
      <td><strong>S5</strong></td>
      <td>Reflexivity + Transitivity + Symmetry</td>
      <td><strong>S4</strong> + $(p \to \Box \Diamond p)$</td>
    </tr>
  </tbody>
</table>

<p>The logics become strictly stronger as one moves down the table.</p>

<h3 id="modal-reduction">Modal Reduction</h3>

<blockquote>
  <p><strong>Theorem.</strong> In <strong>S4</strong>, any sequence of modal operators is equivalent to one of six combinations, and the entailment relations amongst these combinations are as follows:</p>

  <p><img src="/public/modal-operators.jpeg" width="550px" style="margin: 0 auto; mix-blend-mode: multiply;" /></p>
</blockquote>

<blockquote>
  <p><strong>Theorem.</strong> In <strong>S5</strong>, any sequence of modal operators is equivalent to either $\Box$ or $\Diamond$. Furthermore, every formula is equivalent to a <strong>flat</strong> formula—that is, a formula containing no modal operators within the scope of other modal operators.</p>
</blockquote>

<h3 id="completeness-theorem">Completeness Theorem</h3>

<blockquote>
  <p><strong>Theorem.</strong> <strong>K</strong> is complete.</p>
</blockquote>

<p><strong>Proof.</strong></p>

<blockquote>
  <p><strong>Lindenbaum’s Lemma.</strong> Any consistent theory can be extended to a maximally consistent theory.</p>
</blockquote>

<p>The completeness statement is equivalent to “every consistent theory is satisfiable”, and applying Lindenbaum’s lemma, this is equivalent to “every maximally consistent theory is satisfiable”.</p>

<p>Let $u, v$ be maximally consistent theories. We write $u \lhd v$ when $\Box p \in u \implies p \in v$. The following can be shown without difficulty:</p>

<ul>
  <li>When $u \lhd v$, we have $p \in v \implies \Diamond p \in u$</li>
  <li>For any maximally consistent theory $u$, if $p \in u$ and $\Box p \notin u$, then there exist maximally consistent theories $v, v’$ such that $p \in v, \lnot p \in v’$ and $u \lhd v, v’$.</li>
</ul>

<p>From this, for a maximally consistent theory $u$, we can define the <strong>canonical Kripke model</strong> $\mathfrak{K} = (U, \prec, V)$ as follows:</p>

<ul>
  <li>The collection of possible worlds $U$ is the collection of $v$ satisfying $u \lhd v$.</li>
  <li>The accessibility relation $\prec$ is $\lhd$.</li>
  <li>The valuation function $V(p, v)$ is true if and only if $p \in v$.</li>
</ul>

<p>It can be shown without difficulty that $\mathfrak{K}$ satisfies $u$. ■</p>


  </div>
  <div style="margin-bottom: 6em"></div>
  
</div>

<div class="pagination">
  
  <a
    class="pagination-item older lang-ko"
    href="/page6"
    >이전 글</a
  >
  <a
  class="pagination-item older lang-en"
  href="/page6"
  >Previous</a
>
    
  <a
    class="pagination-item newer lang-ko"
    href="/page4"
    >다음 글</a
  >
  <a
  class="pagination-item newer lang-en"
  href="/page4"
  >Next</a
>
   
</div>

<script>
  const faders = document.querySelectorAll(".fade-in-section");

  const appearOptions = {
    // threshold: 0.05,
    // rootMargin: "0px 0px 50px 0px",
  };

  const appearOnScroll = new IntersectionObserver((entries, observer) => {
    entries.forEach((entry) => {
      if (entry.isIntersecting) {
        entry.target.classList.add("is-visible");
        observer.unobserve(entry.target);
      }
    });
  }, appearOptions);

  faders.forEach((fader) => {
    appearOnScroll.observe(fader);
  });

  // 배너 이미지 로드 후 애니메이션 트리거 스크립트
  document.addEventListener("DOMContentLoaded", () => {

    const lang = localStorage.getItem("lang") || "ko";
  document.querySelectorAll('.post[data-lang]').forEach(post => {
    if (post.dataset.lang === lang) {
      post.style.display = '';
    }
  });

    const bannerImages = document.querySelectorAll(
      '.fade-rise-1[src="/public/banner.png"], .fade-rise-2[src="/public/banner-2.png"]'
    ); // 애니메이션 시작을 기다릴 이미지들
    const elementsToAnimate = document.querySelectorAll(
      ".fade-rise-1, .fade-rise-2, .fade-rise-3"
    ); // 애니메이션 될 요소들
    let loadedImagesCount = 0;
    const totalImagesToWait = bannerImages.length;

    // 기다릴 이미지가 없으면 즉시 애니메이션 시작
    if (totalImagesToWait === 0) {
      elementsToAnimate.forEach((el) => el.classList.add("is-loaded"));
      return;
    }

    const checkAllImagesLoaded = () => {
      if (loadedImagesCount === totalImagesToWait) {
        // 모든 이미지가 로드되면 애니메이션 클래스 추가
        elementsToAnimate.forEach((el) => el.classList.add("is-loaded"));
      }
    };

    bannerImages.forEach((img) => {
      // 이미지가 캐시되어 이미 로드 완료된 경우
      if (img.complete) {
        loadedImagesCount++;
      } else {
        // 이미지 로드 완료 이벤트 리스너 추가
        img.addEventListener("load", () => {
          loadedImagesCount++;
          checkAllImagesLoaded(); // 이미지 로드될 때마다 체크
        });
        // 에러 발생 시 처리 (선택 사항)
        img.addEventListener("error", () => {
          console.error("Failed to load image:", img.src);
          // 에러 발생 시에도 애니메이션을 시작하려면 여기서 loadedImagesCount를 증가시키거나 다른 로직 추가
          // 현재 로직에서는 에러 시 카운트가 증가하지 않아 모든 이미지 로드되지 않으면 애니메이션 안 시작
          loadedImagesCount++; // 에러 발생 시에도 카운트 증가 (모든 이미지를 처리했음을 알림)
          checkAllImagesLoaded();
        });
      }
    });

    // 모든 이미지에 대해 complete 상태를 확인하거나 리스너를 설정한 후,
    // 이미 모든 이미지가 로드 완료 상태였을 경우를 대비해 마지막으로 체크
    checkAllImagesLoaded();


    // Listen for language toggle changes and update post visibility dynamically
    const langToggle = document.getElementById("lang-toggle");
    if (langToggle) {
      langToggle.addEventListener("change", () => {
        const newLang = langToggle.checked ? "en" : "ko";
        localStorage.setItem("lang", newLang);
        document.querySelectorAll('.post[data-lang]').forEach(post => {
          post.style.display = post.dataset.lang === newLang ? '' : 'none';
        });
      });
    }
  });
</script>
</div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script src="/public/js/script.js"></script>
    <script src="/public/js/lang.js"></script>
  </body>
</html>
