<!DOCTYPE html>
<html lang="en-us">
  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile" />
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />

  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=1"
  />

  <title>
     디멘의 블로그 &middot; 이데아를 여행하는 히치하이커
    
  </title>

  <script>
    MathJax = {
      tex: {
        inlineMath: [
          ["$", "$"],
          ["\\(", "\\)"],
        ],
      },
      svg: {
        fontCache: "global",
      },
    };
  </script>
  <script
    type="text/javascript"
    id="MathJax-script"
    async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
  ></script>

  
  <link rel="canonical" href="/page7/" />
  

  <link rel="stylesheet" href="/public/css/poole.css" />
  <link rel="stylesheet" href="/public/css/syntax.css" />
  <link rel="stylesheet" href="/public/css/lanyon.css" />
  <link
    rel="stylesheet"
    href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400"
  />

  <!-- <link rel="apple-touch-icon-precomposed" sizes="144x144" href="">
  <link rel="shortcut icon" href="">
   -->
  <link
    rel="apple-touch-icon-precomposed"
    sizes="144x144"
    href="/public/apple-touch-icon.png"
  />
  <link rel="shortcut icon" href="/public/favicon.ico" />
  <!-- <link rel="alternate" type="application/rss+xml" title="RSS" href="http://localhost:4000/atom.xml"> -->
  <link
    rel="alternate"
    type="application/rss+xml"
    title="RSS"
    href=""
  />

  <script
    async
    src="https://www.googletagmanager.com/gtag/js?id=G-PVGYLWF7GR"
  ></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
      dataLayer.push(arguments);
    }
    gtag("js", new Date());

    gtag("config", "G-PVGYLWF7GR");
  </script>
</head>


  <body>
    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox" />

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p>이데아를 여행하는 히치하이커</p>
  </div>

  <nav class="sidebar-nav">
    <a
      class="sidebar-nav-item"
      href="/"
      >메인</a
    >

                
    <a
      class="sidebar-nav-item"
      href="/about/"
      >저에 대하여</a
    >
        
    <a
      class="sidebar-nav-item"
      href="/archive-date/"
      >날짜별로 보기</a
    >
        
    <a
      class="sidebar-nav-item"
      href="/archive-tag/"
      >주제별로 보기</a
    >
          
    <a
      class="sidebar-nav-item"
      href="/book/"
      >새벽의 자연학 수업</a
    >
        
    <a
      class="sidebar-nav-item"
      href="/guestbook/"
      >방명록</a
    >
                                                                                                          
  </nav>

  <div class="sidebar-item">
    <p>&copy; 2025. All rights reserved.</p>
    <p style="color: #202020">
      &copy; 2025. 디멘 reserved by 곰댕.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/" title="Home">디멘의 블로그</a>
            <small>이데아를 여행하는 히치하이커</small>
          </h3>
        </div>
      </div>

      <div class="container content"><head>
  <style>
    .fade-rise-1 {
      opacity: 0;
      transform: translateY(20px);
      animation: fadeRise 0.8s ease-out forwards;
      animation-delay: 0.2s;
    }

    .fade-rise-2 {
      opacity: 0;
      transform: translateY(20px);
      animation: fadeRise 0.8s ease-out forwards;
      animation-delay: 0.4s;
    }

    .fade-rise-3 {
      opacity: 0;
      transform: translateY(20px);
      animation: fadeRise 0.8s ease-out forwards;
      animation-delay: 0.6s;
    }

    @keyframes fadeRise {
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .fade-in-section {
      opacity: 0;
      transform: translateY(20px);
      transition: opacity 1s ease-out, transform 1s ease-out;
    }

    .fade-in-section.is-visible {
      opacity: 1;
      transform: none;
    }

    .spacer {
      height: 100vh;
    }
  </style>
</head>



<div class="posts">
  
  <div class="post fade-in-section">
    <h1 class="post-title">
      <a href="/2024/12/25/Cantor-Bendixson/"> 칸토어-벤딕슨 정리 </a>
    </h1>

    <span class="post-date">25 Dec 2024</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/수학/'">
        수학
      </div>
      
      <div class="tag" onclick="location.href='/tags/위상수학/'">
        위상수학
      </div>
      
    </div>
     <blockquote>
  <p><strong>정의.</strong> 위상공간 $X$의 집합 $P$에 대해 $P’ = P$일 때 $P$를 <strong>완벽한 집합(perfect set)</strong>이라고 한다. ($P’$은 $P$의 집적점들의 집합)</p>
</blockquote>

<p><em>Remark.</em> 모든 완벽한 집합은 닫힌 집합이지만, 역은 성립하지 않는다. 일반적으로 $S \not\subset S’$ ($S$가 고립점을 가짐), $S’ \not\subset S$ ($S$가 닫힌 집합이 아님) 임에 유의하라.</p>

<blockquote>
  <p><strong>정의.</strong> $X$의 임의의 부분공간이 린델뢰프일 때 $X$를 <strong>세습적 린델뢰프(hereditarily Lindelöf)</strong>라고 한다.</p>
</blockquote>

<blockquote>
  <p><strong>약한 칸토어-벤딕슨 정리.</strong> $X$가 세습적 린델뢰프 공간이라고 하자. $F \subset X$가 닫힌 집합일 때 어떤 완벽한 집합 $P$와 가산집합 $C$가 존재하여 $F = P \sqcup C$이다.</p>
</blockquote>

<p><img src="https://velog.velcdn.com/images/dimenerno/post/d1f81be8-2878-4158-844b-96ce3d8cc418/image.png" alt="" /></p>

<p><strong>증명.</strong> 다음과 같이 $P, C$를 정의한다.</p>

\[P = \lbrace  x \in F : \text{For all nbd $U$ of $x$, $U \cap F$ is uncountable} \rbrace\]

\[C = \lbrace  x \in F : \text{There exists a nbd $U$ of $x$ s.t. $U \cap F$ is countable} \rbrace\]

<p>$F = P \sqcup C$임에 주목하라.</p>

<p><em>Claim 1.</em> $C$는 $F$에서 열린 집합이다.</p>

<p><em>Proof of Claim.</em> $x \in C$일 때 어떤 $x$의 근방 $U$가 존재하여 $U \cap F$가 가산이다. 즉, 임의의 $y \in U \cap F$에 대해 $U$는 $y$의 근방이고 $U \cap F$가 가산이므로 $y \in C$이다. 따라서 $U \cap F \subset C$이다. □</p>

<p><em>Claim 2.</em> $C$는 가산이다.</p>

<p><em>Proof of Claim.</em> $F$의 부분공간 토폴로지를 생각하자. 가정에 의해 이 토폴로지는 린델뢰프이다. 임의의 $x \in C$에 대해 $U_x \cap F$가 가산인 $x$의 근방 $U_x$를 찾을 수 있다. 그러면 $\lbrace  U_x \rbrace_{x \in C}$는 $C$의 $F$-열린 덮개이며, 린델뢰프 가정에 의해 $C = \bigcup_{\alpha \in J} U_\alpha$ ($J$는 가산)이다. $U_\alpha$가 가산이므로 $C$는 가산이다. □</p>

<p><em>Claim 3.</em> $P$는 완벽하다.</p>

<p><em>Proof of Claim.</em> Claim 1에 의해 $P$는 $F$에서 닫힌 집합이며, $F$가 닫힌 집합이므로 $P$는 $X$에서 닫힌 집합이다. 따라서 $P’ \subset P$이다. 역을 보이기 위해 $x \in P$라고 하자. 임의의 $x$의 근방 $U$에 대해 $U \cap F = (U \cap C) \sqcup (U \cap P)$가 비가산이다. $C$가 가산이므로, $U \cap P$가 비가산이어야 한다. 따라서 $U$는 $P$와 $\lbrace x \rbrace$보다 큰 교집합을 가지며, $x \in P’$이다. ■</p>

<hr />

<blockquote>
  <p><strong>정의.</strong> 분리 가능한(separable) 완비 거리화 가능 공간을 <strong>폴란드 공간(Polish space)</strong>이라고 한다.</p>
</blockquote>

<p>거리화 가능 공간에서 분리 가능성, 2차 가산, 그리고 린델뢰프는 동치이므로 해당 세 가지 조건 중 하나로 정의를 대체할 수 있다. ‘폴란드 공간’이라는 이름은 해당 공간을 처음으로 연구한 학자들인 시에르핀스키, 쿠라토프스키, 타르스키 등이 폴란드인들이었기 때문에 기인했다.</p>

<p>$X$가 폴란드 공간이라는 더 강한 조건이 주어지면 칸토어-벤딕슨 분해가 유일함을 증명할 수 있다.</p>

<blockquote>
  <p><strong>강한 칸토어-벤딕슨 정리.</strong> $X$가 폴란드 공간이라고 하자. $F \subset X$가 닫힌 집합일 때 어떤 완벽한 집합 $P$와 가산집합 $C$가 존재하여 $F = P \sqcup C$이다. 또한, 해당 분해는 유일하다.</p>
</blockquote>

<p>또한 다음이 성립한다.</p>

<blockquote>
  <p><strong>정리.</strong> 폴란드 공간의 완벽한 집합은 $2^{\aleph_0}$의 크기를 가진다.</p>
</blockquote>

<p><strong>증명.</strong> 추후 기술적 집합론에 대한 글에서 따로 다룰 예정.</p>

<p>이로부터 다음의 결론이 따라 나온다.</p>

<blockquote>
  <p><strong>따름정리: 실수의 닫힌집합에서의 연속체 가설.</strong> 실수의 닫힌집합은 가산이거나 $2^{\aleph_0}$의 크기를 가진다.</p>
</blockquote>

<p><strong>증명.</strong> 실수는 폴란드 공간이므로 칸토어-벤딕슨 정리에 의해 모든 닫힌집합이 가산집합과 완벽한 집합의 서로소 합으로 분해된다. 후자가 공집합일 경우 해당 닫힌집합은 가산이며, 그렇지 않을 경우 $2^{\aleph_0}$이다. ■</p>

<p>칸토어는 위 정리의 증명으로부터 일반적인 연속체 가설을 증명할 수 있으리라는 희망을 품었지만 잘 알려져 있다시피 그 희망은 실현되지 못했다.</p>

  </div>
  <!-- <div
    style="border-bottom: 1px solid var(--lighter-slate); margin-bottom: 4em"
  ></div> -->
  <div style="margin-bottom: 6em"></div>
  
  <div class="post fade-in-section">
    <h1 class="post-title">
      <a href="/2024/12/16/adjoints/"> 어드조인트에 대한 직관적 이해 </a>
    </h1>

    <span class="post-date">16 Dec 2024</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/수학/'">
        수학
      </div>
      
      <div class="tag" onclick="location.href='/tags/범주론/'">
        범주론
      </div>
      
    </div>
     <p>카테고리 이론의 핵심 개념 중 하나는 어드조인트(adjoint)이다.</p>

<blockquote>
  <p><strong>정의.</strong> $\mathcal{A}, \mathcal{B}$가 카테고리이고, $F: \mathcal{A} \to \mathcal{B}, G: \mathcal{B} \to \mathcal{A}$가 함자(functor)라고 하자. $F$가 $G$의 <strong>좌 어드조인트(left adjoint)</strong>라는 것은 임의의 $A \in \mathcal{A}, B \in \mathcal{B}$에 대해 $\mathcal{B}(F(A), B)$와 $\mathcal{A}(A, G(B))$가 자연스럽게 일대일 대응될 수 있다는 것이다. 즉,</p>

\[\begin{gather}
(F(A) \xrightarrow{g} B) \quad \mapsto \quad (A \xrightarrow{\bar{g}} G(B))\\
(A \xrightarrow{f} G(B)) \quad \mapsto \quad (F(A) \xrightarrow{\bar{f}} B)
\end{gather}\]

  <p>또한 $G$를 $F$의 <strong>우 어드조인트(right adjoint)</strong>라고 한다. 기호로 $F \dashv G$로 표기한다.</p>
</blockquote>

<p>필자는 이 정의를 형식적인 수준에서만 이해하고 있었는데, 최근 어드조인트를 직관적으로 이해하는 몇 가지 방식을 발견했다.</p>

<h3 id="1-형-변환으로서의-어드조인트">1. 형 변환으로서의 어드조인트</h3>

<p>좌 어드조인트는 프로그래밍에서 다운캐스팅 형 변환에, 우 어드조인트는 업캐스팅 형 변환에 비견할 수 있다.</p>

<p>예를 들어 $\mathbf{Z}$가 정수를 원소로 가지고, $x \leq y$일 때 그리고 오직 그 경우에만 $x \to y$ 사상이 유일하게 존재하는 카테고리라고 하자. 또한 $\mathbf{Z}^2$가 정수쌍을 원소로 가지고, $\mathbf{x} \preceq \mathbf{y}$일 때 그리고 오직 그 경우에만 $\mathbf{x} \to \mathbf{y}$ 사상이 유일하게 존재하는 카테고리라고 하자(여기서 $\preceq$는 사전식 순서이다).</p>

<p>$F: \mathbf{Z} \to \mathbf{Z}^2, G: \mathbf{Z}^2 \to \mathbf{Z}$가 각각 $F(x) = (x, 0), G(x, y) = x$라면 자연스러운 방식으로 함자가 된다. 또한 $F \dashv G$이다. $x \in \mathbf{Z}, y \in \mathbf{Z}^2$에 대해 $F(x) \leq y$라면 $x \leq G(y)$이고, 그 역도 성립하기 때문이다.</p>

<p><img src="https://velog.velcdn.com/images/dimenerno/post/8040c20d-c1bc-4d92-bd45-256f48b79d75/image.png" alt="" /></p>

<p>위의 논의를 코드로 표현하면 다음과 같다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Z</span> <span class="o">{</span>
	<span class="kt">int</span> <span class="n">x</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Z2</span> <span class="kd">extends</span> <span class="no">Z</span> <span class="o">{</span>
	<span class="c1">// int x;</span>
	<span class="kt">int</span> <span class="n">y</span><span class="o">;</span>
<span class="o">}</span>

<span class="no">Z2</span> <span class="nf">F</span><span class="o">(</span><span class="no">Z</span> <span class="n">z</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">return</span> <span class="k">new</span> <span class="nf">Z2</span><span class="o">(</span><span class="n">z</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
<span class="o">}</span>

<span class="no">Z</span> <span class="nf">G</span><span class="o">(</span><span class="no">Z2</span> <span class="n">z2</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">return</span> <span class="k">new</span> <span class="nf">Z</span><span class="o">(</span><span class="n">z2</span><span class="o">.</span><span class="na">x</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이 코드에서 $F$는 실질적으로 다운캐스팅, $G$는 업캐스팅에 해당함에 주목하라.</p>

<h3 id="2-근사로서의-어드조인트">2. 근사로서의 어드조인트</h3>

<p>$F \dashv G$일 때 $F, G$는 $\mathcal{A}$과 $\mathcal{B}$의 원소들을 서로 근사하는 방법으로 생각할 수 있다. 특히 좌 어드조인트는 ‘좌측에서 우측으로‘의 근사이고, 우 어드조인트는 ‘우측에서 좌측으로’의 근사이다.</p>

<p>예를 들어 $\mathbf{Z}$가 정수를 원소로 가지고, $x \leq y$일 때 그리고 오직 그 경우에만 $x \to y$ 사상이 유일하게 존재하는 카테고리라고 하자. 또한 $\mathbf{R}$이 실수를 원소로 가지고, $x \leq y$일 때 그리고 오직 그 경우에만 $x \to y$ 사상이 유일하게 존재하는 카테고리라고 하자. 이때 $\lceil \cdot \rceil, \lfloor \cdot \rfloor$는 표준적인 방식으로 함자 $\mathbf{R} → \mathbf{Z}$가 되고, 포함 사상 $\iota$는 함자 $\mathbf{Z} → \mathbf{R}$이 된다. 또한 $\lceil \cdot \rceil \dashv \iota \dashv \lfloor \cdot \rfloor$임을 확인할 수 있다.</p>

<p><img src="https://velog.velcdn.com/images/dimenerno/post/e26ee728-09b0-4280-ac4c-511f89cef615/image.png" alt="" /></p>

<p>즉 $\lceil \cdot \rceil$는 $r$을 $r \leq \lceil r \rceil$로 ‘좌측에서 우측으로 끌어올리는’ 변환이고, $\lfloor \cdot \rfloor$은 $r$을 $\lfloor r \rfloor \leq r$로 ‘우측에서 좌측으로 잡아당기는’ 변환이다.</p>

<p>또한 $I, T$가 각각 $\mathcal{A}$의 초기 대상(initial object) 및 종단 대상(terminal object)라고 하자. 즉, 임의의 $A \in \mathcal{A}$에 대해</p>

<ul>
  <li>사상 $I \to A$가 유일하게 존재한다.</li>
  <li>사상 $A \to T$가 유일하게 존재한다.</li>
</ul>

<p>일례로 $\mathbf{Set}$에서 공집합은 초기 대상이고 홑원소 집합은 종단 대상이다.</p>

<p>홑원소 카테고리 $\mathcal{U}$에 대해 함자 $F: \mathcal{A} \to \mathcal{U}$가 유일하게 존재한다. $G_I, G_T: \mathcal{U} \to \mathcal{A}$가 각각 상이 $I, T$인 함자라고 하자. 이때 앞선 경우와 비슷한 원리로 $G_T \dashv F \dashv G_I$가 됨을 확인하라. (종단 대상은 가장 “오른쪽”에 있는 대상이므로 $G_T$는 “왼쪽에서 오른쪽으로”의 근사이며, 초기 대상은 가장 “왼쪽”에 있는 대상이므로 $G_I$는 “오른쪽에서 왼쪽으로”의 근사이다.)</p>

<h3 id="3-구축과-파괴로서의-어드조인트">3. 구축과 파괴로서의 어드조인트</h3>

<p>좌 어드조인트는 구축을, 우 어드조인트는 파괴를 의미한다. 따라서 일반적으로 자유함자(free functor)는 좌 어드조인트, 망각함자(forgetful functor)는 우 어드조인트이다.</p>

<p>일례로 군의 카테고리를 $\mathbf{Grp}$, 모노이드의 카테고리를 $\mathbf{Mon}$이라 하자. $F$를 자유함자, $U$를 망각함자라고 하자. 그리고 $R: \mathbf{Mon} → \mathbf{Grp}$를 다음과 같이 정의한다.</p>

<ul>
  <li>$R(M) = \lbrace  m \in M : \exists m^{-1} \in M \rbrace$</li>
  <li>$R(f): m \mapsto f(m)$</li>
</ul>

<p>이 때, 다음 다이어그램이 성립하여 $F \dashv U \dashv R$이다.</p>

<p><img src="https://velog.velcdn.com/images/dimenerno/post/1640d6b4-bd6a-4098-9fe8-e9a7ab164041/image.png" alt="" /></p>

<p>$R$이 $U$보다 더 파괴적이기 때문에 $U \dashv R$인 것으로 이해할 수 있다.</p>


  </div>
  <!-- <div
    style="border-bottom: 1px solid var(--lighter-slate); margin-bottom: 4em"
  ></div> -->
  <div style="margin-bottom: 6em"></div>
  
  <div class="post fade-in-section">
    <h1 class="post-title">
      <a href="/2024/12/11/VL-axiom/"> V = L 공리의 무모순성 </a>
    </h1>

    <span class="post-date">11 Dec 2024</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/수학/'">
        수학
      </div>
      
      <div class="tag" onclick="location.href='/tags/집합론/'">
        집합론
      </div>
      
    </div>
     <h2 id="1-전체">1. 전체</h2>

<h3 id="11-폰-노이만-전체">1.1. 폰 노이만 전체</h3>

<p><a href="https://dimenerno.github.io/2024/12/05/transfinite-recursion/">초한귀납적으로</a> $\lbrace  V_\alpha \rbrace$를 정의하자.</p>

<ul>
  <li>$V_0 = \varnothing$</li>
  <li>$V_{\alpha + 1} = V_\alpha \cup \mathcal{P}(V_\alpha)$</li>
  <li>$\lambda$가 극한 서수일 때, $V_\lambda = \bigcup_{\alpha &lt; \lambda} V_\alpha$</li>
</ul>

<p>처음 몇 개의 $V_\alpha$는 다음과 같다.</p>

<ul>
  <li>$V_1 = \lbrace  \varnothing \rbrace$</li>
  <li>$V_2 = \lbrace  \varnothing, \lbrace  \varnothing \rbrace \rbrace$</li>
  <li>$V_3 = \lbrace  \varnothing, \lbrace  \varnothing \rbrace, \lbrace  \lbrace  \varnothing \rbrace \rbrace, \lbrace  \varnothing, \lbrace  \lbrace  \varnothing\rbrace \rbrace  \rbrace$</li>
  <li>$V_\omega = \mathsf{HF}$</li>
</ul>

<p>모든 서수 $\alpha$에 대해 $V_\alpha$를 모아둔 모임을 <strong>폰 노이만 전체</strong>라고 한다.</p>

\[V = \bigcup_{\alpha \in \mathrm{Ord}} V_\alpha\]

<p>$x \in y \in z$가 $x \in z$를 시사할 때 $z$를 <strong>추이적 집합(transitive set)</strong>이라고 한다. 이것은 $V$의 중요한 특징이다.</p>

<blockquote>
  <p><strong>정리.</strong></p>

  <ol>
    <li>$\alpha \in \mathrm{Ord}$에 대해 $V_\alpha$는 추이적이다.</li>
    <li>$V$는 추이적이다.</li>
  </ol>
</blockquote>

<p>증명은 초한귀납법을 이용한다. 이에 따라 $V$를 다음과 같이 정의해도 무방하다.</p>

<ul>
  <li>$V_0 = \varnothing$</li>
  <li>$V_{\alpha + 1} = \mathcal{P}(V_\alpha)$</li>
  <li>$\lambda$가 극한 서수일 때, $V_\lambda = \bigcup_{\alpha &lt; \lambda}V_\alpha$</li>
</ul>

<p>직관적으로 생각했을 때 $V$는 모든 집합을 포함하는 듯하다. 실제로 다음을 증명할 수 있다.</p>

<blockquote>
  <p><strong>정리.</strong> $x$가 집합이라면 $x \in V$이다.</p>
</blockquote>

<p><strong>증명.</strong> 집합 $x$에 대해 $x$의 <strong>추이적 폐포</strong> $\bar{x}$를, $x$를 원소로 가지는 가장 작은 추이적 집합으로 정의한다(추이적 집합들의 교집합은 추이적이기 때문에 이 정의는 정당하다).</p>

<p>$x \notin V$라고 가정하자. 분류 공리에 의해 $y = \lbrace  u \in \bar{x} : u \notin V \rbrace$가 집합이며, 정초 공리에 의해 $y$의 $\in$-극소 원소 $z$가 존재한다. 만약 $w \notin V$인 $w \in z$가 존재한다면,  추이성에 의해 $w \in y$가 되어 $z$의 $\in$-극소성과 모순된다. 따라서 $z$의 모든 원소는 $V$에 있으며, 치환 공리로부터 $\Omega = \lbrace  \alpha \in \mathrm{Ord} \mid \exists w \in z : w \in V_\alpha\rbrace$가 집합이다. 부랄리포르티 정리에 의해 $\beta = \bigcup_{\alpha \in \Omega}\alpha$가 서수이며, <strong>$z \in V_{\beta + 1}$이다.</strong> (이 부분에서 $V_{\beta + 1} = \mathcal{P}(V_\beta)$임이 필요하다) 따라서 모순이다. ■</p>

<p>이에 따라 $V$는 집합이 아니다. 따라서 $V$는 모든 집합을 포함한다는 점에서 ZFC의 모델이지만, <a href="https://math.stackexchange.com/questions/56726/how-can-there-be-genuine-models-of-set-theory">많은 수학자들은 모델이 집합일 것을 요구하기 때문에</a> 엄격한 의미에서의 모델은 아니다. 하지만 이 글에서는 편의를 위해 $V$를 집합론의 모델이라고 부르도록 한다. 또한 $x \in V$를 “$x$는 집합이다“의 형식적 표현으로 이해하도록 한다.</p>

<h3 id="12-괴델-구성-가능-전체">1.2. 괴델 구성 가능 전체</h3>

<p>먼저 다음과 같이 구성 가능성을 정의한다.</p>

<blockquote>
  <p><strong>정의.</strong> $u$가 집합 $S$로부터 <strong>구성 가능</strong>하다는 것은, 어떤 1차 논리 명제 $\phi(y, x_1, \dots, x_n)$와 $c_1, \dots, c_n \in S$가 존재하여 다음이 성립하는 것이다.</p>

\[y \in u \iff y \in S \land \phi(y, c_1, \dots, c_n)\]

  <p>단, $\phi$의 양화사의 정의역은 $S$이다.</p>
</blockquote>

<p>예를 들어 $S = \lbrace 0, 1, 2\rbrace$일 때 다음은 $u = \lbrace  1, 2 \rbrace$를 구성한다.</p>

<ul>
  <li>$\phi(y, x_1, x_2) := (y = x_1) \lor (y = x_2)$</li>
  <li>$c_1 = 1, c_2 = 2$</li>
</ul>

<p>또한 $S = \mathbb{N}$일 때 다음은 $u = \lbrace 0, 3, 6, 9, \dots \rbrace$를 구성한다.</p>

<ul>
  <li>$\phi(y, x_1) := x_1 \mid y$</li>
  <li>$c_1 = 3$</li>
</ul>

<p>괴델의 구성가능성은 일반적인 의미에서의 구성가능성, 즉 언어로서의 표현가능성과 다르다. 일례로 언어로 표현가능한 실수의 집합은 가산이므로, 어떤 실수는 언어로 표현이 불가능하다. 그러한 실수를 $r$이라고 하자. 이제 $S = \mathbb{R}$일 때, 다음은 $u = \lbrace  r \rbrace$을 구성한다.</p>

<ul>
  <li>$\phi(y, x_1) := x_1 = y$</li>
  <li>$c_1 = r$</li>
</ul>

<p>즉, 괴델의 구성가능성은 자유변수의 초기화를 임의의 원소에 대해 허용한다는 점에서 강력하다. 그러나 자유변수의 수가 유한하다는 점에서 한계를 가진다. 이제 초한귀납적으로 $\lbrace  L_\alpha \rbrace$를 정의하자.</p>

<ul>
  <li>$L_0 = \varnothing$</li>
  <li>$L_{\alpha + 1} = \lbrace  x : x \text{ is constructible from } L_\alpha  \rbrace$</li>
  <li>$\lambda$가 극한 서수일 때, $L_\lambda = \bigcup_{\alpha &lt; \lambda} L_\alpha$</li>
  <li>$L = \bigcup_{\alpha &lt; \lambda} L_\alpha$</li>
</ul>

<p>$\alpha &lt; \omega$일 때 $L_\alpha = V_\alpha$임을 쉽게 보일 수 있다. $\alpha = n$일 때, 최대 $n$개의 $\lor$ 연언으로 $x \in V_\alpha$를 구성할 수 있기 때문이다. 따라서,</p>

<ul>
  <li>$L_1 = \lbrace  \varnothing \rbrace$</li>
  <li>$L_2 = \lbrace  \varnothing, \lbrace  \varnothing \rbrace \rbrace$</li>
  <li>$L_3 = \lbrace  \varnothing, \lbrace  \varnothing \rbrace, \lbrace  \lbrace  \varnothing \rbrace \rbrace, \lbrace  \varnothing, \lbrace  \lbrace  \varnothing\rbrace \rbrace  \rbrace$</li>
  <li>$L_\omega = \mathsf{HF}$</li>
</ul>

<p>하지만 $L_{\omega + 1} \subsetneq V_{\omega + 1}$이다. $\mathcal{P}(\mathbb{N}) \subset V_{\omega + 1}$이므로 $V_{\omega + 1}$은 비가산인 반면, 1차 논리 문장들의 집합과  $L_\omega$는 모두 가산이므로 $L_{\omega + 1}$ 또한 가산이기 때문이다. 일반적으로 $\alpha$가 가산일 때 $L_\alpha$는 가산이다.</p>

<p>그럼에도 $L$은 $V$와 많은 특징을 공유한다. 일례로,</p>

<blockquote>
  <p><strong>정리.</strong> $\alpha \in \mathrm{Ord}$에 대해 다음이 성립한다.</p>

  <ol>
    <li>$L_\alpha$는 추이적이다. (따라서 $L$이 추이적이다)</li>
    <li>$\alpha \in L_{\alpha + 1} \setminus L_{\alpha}$</li>
  </ol>
</blockquote>

<p>증명은 초한귀납법을 사용한다.</p>

<p>$L$은 모든 서수를 포함하므로 부랄리포르티 정리에 의해 집합이 아님에 유의하라. 대신 $x \in L_\alpha$에 대응되는 1차 논리식 $\mathsf{IsInL}_\alpha(x)$가 존재한다. 증명은 조금 까다로운데, 괴델 수를 이용하여 명제를 산술화하면 된다. (<a href="https://math.stackexchange.com/questions/198437/a-formula-that-defines-constructible-universe">링크</a> 참조) 따라서 $x \in L$을 $\exists \alpha \in \mathrm{Ord} :\mathsf{IsInL}_\alpha(x)$를 대체하는 형식적 표현으로 이해하여 사용하도록 한다. (물론 $\alpha \in \mathrm{Ord}$ 또한 1차 논리식을 대체하는 형식적 표현으로 이해되어야 한다)</p>

<h2 id="2-상대화">2. 상대화</h2>

<h3 id="21-명제의-상대화">2.1. 명제의 상대화</h3>

<p>1차 논리 명제는 양화사를 포함할 수 있다. 때문에 양화사의 정의역을 어떻게 설정하느냐의 따라 명제의 의미가 달라진다.</p>

<p>명제 $\phi$와 집합 (또는 모임) $A$에 대해, $\phi$의 상대화 $\phi^A$를 $\phi$의 모든 양화사를 $A$로 제한한 명제로 정의한다. 약간의 서사적 표현을 곁들이자면, $\phi^A$는 $A$의 “내부”에서 이해한 $\phi$라고 할 수 있겠다. 예를 들어, $\phi : \forall x \; \exists y : y &lt; x$일 때</p>

<ul>
  <li>$\phi^\mathbb{N} : \forall x \in \mathbb{N} \; \exists y \in \mathbb{N} : y &lt; x$</li>
  <li>$\phi^\mathbb{Z} : \forall x \in \mathbb{Z} \; \exists y \in \mathbb{Z} : y &lt; x$</li>
</ul>

<p>$T_\mathbb{Q}$가 자연수 및 정수를 특정할 수 있는 정도의 표현력을 지니는 유리수 이론이라고 하면,</p>

<ul>
  <li>$T_\mathbb{Q} \vdash \phi$</li>
  <li>$T_\mathbb{Q} \not\vdash \phi^\mathbb{N}$</li>
  <li>$T_\mathbb{Q} \vdash \phi^{\mathbb{Z}}$</li>
</ul>

<p>이다. 따라서 $\phi$는 자연수와 유리수를 성공적으로 구분해 내지만, 정수와 유리수는 구분해 내지 못한다. 이 관찰을 일반화하면, 이론 $T$와 집합 $A$에 대해 $T \vdash \phi \leftrightarrow \phi^A$인 $\phi$가 많으면 많을수록 $A$는 $T$의 기술에 잘 “부합한다“고 말할 수 있다.</p>

<p>위 논의를 조금 일반화하여, 다음과 같이 정의한다.</p>

<blockquote>
  <p><strong>정의.</strong> 이론 $T$와 집합 $A$에 대해서</p>

\[T \vdash \forall x_1, \dots, x_n \in A (\phi(x_1, \dots, x_n) \leftrightarrow \phi^A(x_1, \dots, x_n))\]

  <p>일 때, $\phi$는 $A$에 대해 <strong>절대적(absolute)</strong>이라고 한다.</p>
</blockquote>

<p>일례로 $T_\mathbb{Q}$에 대해 $\phi(x) : \exists y (y &lt; x)$는 정수에 대해 절대적이지만 자연수에 대해 절대적이지는 않다.</p>

<h3 id="22-l-상대화">2.2. $L$-상대화</h3>

<p>이제 우리의 목표는 $L$이 $\mathsf{ZF}$와 극대적으로 부합함을 보이는 것이다. 즉,</p>

<blockquote>
  <p><strong>정리 1.</strong> $\phi$가 ZF의 공리라면 $\mathsf{ZF} \vdash \phi^L$이다.</p>
</blockquote>

<p>정리 1의 의미를 말로 풀어 보자면,</p>

<blockquote>
  <p>“$L$의 내부에서 보았을 때 $L$은 ZF의 모델이다”를 ZF로 증명할 수 있다.</p>
</blockquote>

<p>물론 우리는 $L \subset V$만 알고 $V = L$인지는 알지 못하기 때문에, 어떤 집합 $x$는 $L$에 속하지 않을 수도 있다. 그러나 설령 $x \in V \setminus L$인 집합 $x$가 있더라도, 그러한 $x$의 결여는 $L$의 <em>내적 정합성</em>을 깨뜨리지 않는다는 것이 정리 1의 내용이다.</p>

<p>예를 들어 어떤 집합 $y, z$에 대해 $x = \lbrace  y, z \rbrace$가 $L$에 결여되어 있다고 하자. 일면 $x$의 결여는 $L$이 짝 공리 $\mathsf{Pair}$을 만족하지 않음을 시사하는 듯하다.</p>

\[\mathsf{Pair} := \forall y, z \; \exists x \; \forall w: w \in x \leftrightarrow (w = y \lor w = z)\]

<p>하지만 $L$의 내부에서 본 짝 공리는 다음과 같다.</p>

\[\mathsf{Pair}^L := \forall y, z \in L \; \exists x \in L \; \forall w \in L: w \in x \leftrightarrow (w = y \lor w = z)\]

<p>$\forall y, z$의 양화 또한 $L$로 한정됨에 주목하라. 즉, $x = \lbrace  y, z \rbrace$의 결여가 $L$에게 문제를 일으키는 경우는 $y, z \in L$일 때이다. 거꾸로 말해, $x = \lbrace  y, z \rbrace \notin L$이 $y, z \notin L$을 시사한다면 $L$은 $\mathsf{Pair}^L$을 만족한다. 이것이 “$L$이 내적 정합성을 유지하는 방식으로 집합을 결여한다”의 의미이다.</p>

<p>정리 1이 성립하는 핵심 이유는 $L$과 $V$가 <strong>추이성이라는 성질을 공유</strong>하기 때문이다.</p>

<blockquote>
  <p><strong>보조정리.</strong> 다음 술어는 ZF에서 $L$에 대해 절대적이다.</p>

  <ol>
    <li>$x \in y$</li>
    <li>$x \subset y$</li>
    <li>$x = \bigcup y$</li>
    <li>$x = \lbrace  y, z \rbrace$</li>
    <li>$\alpha \in \mathrm{Ord}$</li>
    <li>$x$는 추이적이다.</li>
    <li><a href="https://math.stackexchange.com/questions/404699/delta-0-formulas">$\Delta_0$ 논리식</a></li>
  </ol>
</blockquote>

<p>또한 다음을 증명할 수 있다.</p>

<blockquote>
  <p><strong>정리 2.</strong> $\mathsf{ZF} \vdash (V = L)^L$</p>
</blockquote>

<p>여기서 $V = L$은, “모든 집합이 $L$에 속한다”를 의미한다. 따라서 일면 보기에 $(V = L)^L$은 “$L$에 속하는 모든 집합이 $L$에 속한다”라는 자명한 명제인 듯하다. 하지만 실제로 $V = L$을 논리식으로 적으면</p>

\[\forall x \; \exists \alpha  : \alpha \in \mathrm{Ord} \land x \in L_\alpha\]

<p>이므로 $(V = L)^L$은</p>

\[\forall x \in L \; \exists \alpha \in L : (\alpha \in \mathrm{Ord})^L \land (x \in L_\alpha)^L\]

<p>이다. 특히, $\alpha \in \mathrm{Ord}$와 $x \in L_\alpha$가 진정한 의미에서의 $\in$-술어가 아닌 1차 논리식의 형식적 표현이기 때문에 마찬가지로 $L$로 상대화해야 함에 유의하라. 이에 따라 $(V = L)^L$을 ZF에서 증명하기 위해서는 $\alpha \in \mathsf{Ord}$와 $x \in L_\alpha$가 절대적임을 증명해야 한다. 두 증명 모두 초한귀납법을 사용하면 가능하다.</p>

<p>정리 1과 정리 2로부터 다음을 증명할 수 있다.</p>

<blockquote>
  <p><strong>정리 3.</strong> $\mathsf{ZFL} \vdash \phi \implies \mathsf{ZF} \vdash \phi^L$</p>
</blockquote>

<p><strong>증명.</strong> $\mathsf{ZFL} \vdash \phi$의 증명 길이에 대한 귀납법으로 증명한다. 증명 길이가 0일 때 $\phi$는 ZFL의 공리이다. $\phi$가 ZF의 공리일 때 정리 1로부터 증명되고, $\phi$가 $V = L$일 때 정리 2로부터 증명된다.</p>

<p>이제 $\phi$가 $\lbrace  \psi_1, \dots, \psi_n \rbrace$에 추론 규칙을 적용하는 것으로 증명된다고 가정하자. $\psi_k$의 증명 길이는 $\phi$보다 작으므로 귀납 가정에 의해 $\mathsf{ZF} \vdash \psi_k^L$이며,  논리 공리와 추론 규칙은 $L$에 대해 절대적임을 쉽게 보일 수 있다. 따라서 $(\psi_1 \land \dots \land \psi_n) \rightarrow \phi$가 논리적 참이라면 $(\psi_1^L \land \dots \land \psi_n^L) → \phi^L$ 또한 논리적 참이며, 이에 따라 $\mathsf{ZF} \vdash \phi^L$이다. ■</p>

<p>정리 3의 따름정리로서 정리 4를 얻는다.</p>

<blockquote>
  <p><strong>정리 4.</strong> ZF가 무모순적이라면 ZFL 또한 무모순적이다.</p>
</blockquote>

<p><strong>증명.</strong> ZFL이 모순적이라면 $\mathsf{ZFL} \vdash \varnothing \neq \varnothing$이며, 정리 3에 의해 $\mathsf{ZF} \vdash (\varnothing \neq \varnothing)^L \iff \mathsf{ZF} \vdash \varnothing \neq \varnothing$이다.</p>

<p>따라서 <strong>V = L은 ZF와 일관적이다</strong>.</p>

  </div>
  <!-- <div
    style="border-bottom: 1px solid var(--lighter-slate); margin-bottom: 4em"
  ></div> -->
  <div style="margin-bottom: 6em"></div>
  
  <div class="post fade-in-section">
    <h1 class="post-title">
      <a href="/2024/12/05/transfinite-recursion/"> 초한귀납과 초한재귀 </a>
    </h1>

    <span class="post-date">05 Dec 2024</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/수학/'">
        수학
      </div>
      
      <div class="tag" onclick="location.href='/tags/집합론/'">
        집합론
      </div>
      
    </div>
     <h3 id="1-초한귀납법">1. 초한귀납법</h3>

<blockquote>
  <p><strong>정리.</strong> $P$가 서수 위에서 정의된 속성이고 임의의 $\alpha \in \mathrm{Ord}$에 대해</p>

\[[ \forall \beta &lt; \alpha : P(\beta)] → P(\alpha)\]

  <p>가 성립할 때, $P$는 모든 서수에 대해 참이다.</p>
</blockquote>

<p><em>Remark.</em> $P$의 정의역인 $\mathrm{Ord}$는 집합이 아닌 진모임(proper class)이므로 “술어” 대신 “속성”이란 표현을 사용한다.</p>

<p><strong>증명.</strong> 서수가 정렬 순서라는 사실과 귀류법을 사용한다.</p>

<p>$\lnot P(\lambda)$인 $\lambda$가 존재한다고 하자. $\Omega = \lbrace  \alpha \in \lambda : \lnot P(\alpha) \rbrace$는 공집합이 아닌 정렬 집합이므로 최소 원소 $\alpha_0$가 존재한다. 이때 $\forall \beta &lt; \alpha_0 : P(\beta)$이므로 가정에 의해 $P(\alpha_0)$가 되어 모순이다. ■</p>

<p><strong>응용.</strong> 폰 노인만 계층에서 $V_\alpha$는 추이적이다. 따라서 $V_{\alpha + 1} = V_\alpha \cup \mathcal{P}(V_\alpha)$ 대신 $V_{\alpha + 1} = \mathcal{P}(V_\alpha)$로 정의할 수 있다.</p>

<h3 id="2-초한재귀적-정의">2. 초한재귀적 정의</h3>

<p><em>Motivation.</em> 자연수의 재귀적 정의를 생각해 보자. $n$개의 집합 $x_1, \dots , x_n$이 주어졌을 때 집합을 출력하는 함수 $g$가 존재한다면 다음과 같이 $f: \mathbb{N} → V$을 정의할 수 있을 것이다.</p>

\[f(n) = g(f(0), \dots, f(n - 1))\]

<p>문제는 $g$가 고정된 수의 매개변수만을 가질 수 있다는 것이다. 따라서 다음과 같이 $g$의 매개변수를 순서쌍으로 묶는다.</p>

\[f(n) = g(\langle f(0), \dots, f(n - 1) \rangle)\]

<p>이 순서쌍은 $\lbrace  (0, f(0)), \dots, (n - 1, f(n - 1)) \rbrace = f \upharpoonright n$과 같이 표현할 수 있다. 즉,</p>

\[f(n) = g(f \upharpoonright n).\]

<p>이를 서수에 대해서 일반화하면 다음과 같다.</p>

<blockquote>
  <p><strong>정리.</strong> $G: V → V$가 모임함수(class function)이라고 하자. 다음을 만족하는 모임함수 $F: \mathrm{Ord} → V$가 존재한다.</p>

\[F(\alpha) = G(F \upharpoonright \alpha)\]
</blockquote>

<p><strong>증명.</strong> 초한귀납법을 겁나게 쓰면 된다. (불친절해서 ㅈㅅ)</p>

  </div>
  <!-- <div
    style="border-bottom: 1px solid var(--lighter-slate); margin-bottom: 4em"
  ></div> -->
  <div style="margin-bottom: 6em"></div>
  
  <div class="post fade-in-section">
    <h1 class="post-title">
      <a href="/2024/12/01/net/"> 콤팩트성과 그물 </a>
    </h1>

    <span class="post-date">01 Dec 2024</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/수학/'">
        수학
      </div>
      
      <div class="tag" onclick="location.href='/tags/위상수학/'">
        위상수학
      </div>
      
    </div>
     <h3 id="콤팩트성">콤팩트성</h3>
<blockquote>
  <p><strong>정의.</strong> $X$가 위상공간이라고 하자.</p>

  <ol>
    <li>임의의 열린 덮개가 유한한 부분덮개를 가질 때 $X$를 <strong>콤팩트</strong>하다고 한다.</li>
    <li>임의의 점렬 $\lbrace x_n \in X \rbrace$가 수렴하는 부분점렬을 가질 때 $X$를 <strong>점렬 콤팩트</strong>하다고 한다.</li>
    <li>임의의 무한집합 $S \subset X$가 극점을 가질 때 $X$를 <strong>극점 콤팩트</strong>하다고 한다.</li>
  </ol>
</blockquote>

<blockquote>
  <p><strong>정리.</strong></p>

  <ol>
    <li>콤팩트 $\rightarrow$ 극점 콤팩트</li>
    <li>점렬 콤팩트 $\rightarrow$ 극점 콤팩트</li>
    <li>극점 콤팩트 $\not\rightarrow$ 콤팩트</li>
    <li>극점 콤팩트 $\not\rightarrow$ 점렬 콤팩트</li>
  </ol>
</blockquote>

<p><strong>증명.</strong></p>

<ol>
  <li>$S \subset X$가 극점이 없는 무한집합이라고 하자. $\overline{S} = S \cup S’ = S$이므로 $S$는 닫힌 집합이며, $X \setminus S$는 열린 집합이다. 임의의 $s \in S$에 대해, $s$가 극점이 아니므로 $U_s \cap S = \lbrace  s \rbrace$인 $s$의 근방 $U_s$가 존재한다. 따라서 다음 $X$의 열린 덮개는 유한한 부분덮개를 가지지 않는다.</li>
</ol>

\[\mathcal{C} = \lbrace  X \setminus S \rbrace \cup \bigcup_{s \in S} \lbrace  U_s \rbrace\]

<ol>
  <li>$S \subset X$가 무한집합이라고 하자. $S$의 원소들을 임의로 추출하여 점렬 $\lbrace  s_n \rbrace \;(n \neq m \implies s_n \neq s_m)$을 만든다. $X$가 점렬 콤팩트하므로 $\lbrace  s_n \rbrace → s$이며, $s$는 $S$의 극점이다.</li>
  <li>순서 토폴로지가 주어진 $\omega_1$은 극점 콤팩트하지만 콤팩트하지 않다.</li>
  <li>$X = \mathbb{N} \times \lbrace  0, 1 \rbrace$, $\mathbb{N}$에는 이산 토폴로지가 주어지고 $\lbrace  0, 1\rbrace$에는 자명한 토폴로지가 주어짐.</li>
</ol>

<p><strong>Remark.</strong> 4의 올바르지 못한 “증명”</p>

<blockquote>
  <p>$X$가 극점 콤팩트하다고 하자. 점렬 $(x_n)$이 주어졌을 때, $S = \lbrace  x_n : n \in \mathbb{N}\rbrace$이 유한집합이라면 $(x_n)$은 수렴하는 부분점렬을 자명하게 가진다. $S$가 무한집합이라면 $X$의 극점 콤팩트성에 의해 $x \in S’$가 존재한다. <strong>이제 다음 조건을 만족하는 $x$의 근방들의 가산 모임 $\mathcal{U} = \lbrace  U_n \rbrace$을 정의한다.</strong></p>

  <ol>
    <li>$n &lt; m \implies U_n \supset U_m$</li>
    <li>$V$가 $x$의 근방일 때, $\exists U \in \mathcal{U} : U \subset V$</li>
  </ol>

  <p>이로부터 다음 두 조건을 만족하는 함수 $k: \mathbb{N} → \mathbb{N}$을 정의할 수 있다.</p>

  <ol>
    <li>$x_{k(n)} \in U_n$</li>
    <li>$n &lt; m \implies k(n) &lt; k(m)$</li>
  </ol>

  <p>2가 가능한 이유는 $k(i)$가 $i \leq n$까지 정의되었을 때 $T = S \setminus \lbrace  x_i : i \leq k(n) \rbrace$가 여전히 $x$를 극점으로 가지기 때문이다. 즉, $(x_n)$은 수렴하는 부분점렬 $(x_{k(n)})$을 가진다.</p>
</blockquote>

<p>위 증명이 올바르지 않은 이유는 볼드체 부분이 일반적으로 가능하지 않기 때문이다. 대신 다음이 성립한다.</p>

<blockquote>
  <p><strong>정리.</strong> 1차 가산 T₁ 공간에서 극점 콤팩트성과 점렬 콤팩트성은 동치이다.</p>
</blockquote>

<h3 id="그물과-점렬">그물과 점렬</h3>

<blockquote>
  <p><strong>정의.</strong> $(J, \leq)$가 전순서라고 하자. 임의의 $x, y \in J$에 대해 $x, y \leq z$인 $z \in J$가 존재한다면 $(J, \leq)$를 <strong>방향 집합(directed set)</strong>이라고 한다.</p>
</blockquote>

<blockquote>
  <p><strong>정의.</strong> $K$가 $(J, \leq)$의 부분집합이라고 하자. 임의의 $x \in J$에 대해 $x \leq y$인 $y \in K$가 존재한다면 $K$를 <strong>공종(cofinal)</strong>이라고 한다.</p>
</blockquote>

<p><strong>Remark.</strong> $(J, \leq)$가 방향 집합이고 $K \subset J$가 공종이라면 $(K, \leq)$ 또한 방향 집합이다.</p>

<blockquote>
  <p><strong>정의.</strong> $(J, \leq)$가 방향 집합이라고 하자. 위상공간 $X$에 대해 $J$에서 $X$로 가는 함수 $f: J → X$를 <strong>그물(net)</strong>이라고 한다. 특히, $\alpha \in J$에 대해 $f(\alpha)$를 $x_\alpha$와 같이 표기한다.</p>
</blockquote>

<p><img src="https://velog.velcdn.com/images/dimenerno/post/9012f74b-245b-413c-8df4-f6ae30ebf7b3/image.png" alt="" /></p>

<blockquote>
  <p><strong>정의.</strong> 그물 $(x_\alpha)$가 $x$로 수렴한다는 것은, 임의의 $x$의 근방 $U$에 대해 어떤 $\alpha \in J$가 존재하여</p>

  <p>\(\alpha \leq \beta \implies x_\beta \in U\)
인 것이다.</p>
</blockquote>

<p>일반 위상 공간에서의 그물의 수렴은 1차 가산 공간에서 점렬의 수렴과 대응된다. 즉,</p>

<blockquote>
  <p><strong>정리.</strong> $X$가 1차 가산 공간이라고 하자.</p>

  <ol>
    <li>$A \subset X$에 대해, $x \in \bar{A}$일 필요충분조건은 $x$로 수렴하는 점렬 $(x_n)$이 존재하는 것이다.</li>
    <li>$f: X → Y$에 대해, $f$가 연속일 필요충분조건은 임의의 점렬 $(x_n)$에 대해 $x_n → x$라면  $f(x_n) → f(x)$인 것이다.</li>
  </ol>
</blockquote>

<blockquote>
  <p><strong>정리.</strong> $X$가 위상 공간이라고 하자.</p>

  <ol>
    <li>$A \subset X$에 대해, $x \in \bar{A}$일 필요충분조건은 $x$로 수렴하는 그물 $(x_\alpha)$가 존재하는 것이다.</li>
    <li>$f: X → Y$에 대해, $f$가 연속일 필요충분조건은 임의의 그물 $(x_\alpha)$에 대해 $x_\alpha → x$라면  $f(x_\alpha) → f(x)$인 것이다.</li>
  </ol>
</blockquote>

<p><strong>증명.</strong></p>

<ol>
  <li>$\mathcal{U}_x$를 $x$의 근방들의 집합이라고 하자. 역포함관계로 $\mathcal{U}_x$에 순서 $\leq$를 준다. $x \in \bar{A}$라면 임의의 $U_\alpha \in \mathcal{U}_x$에 대해 $x_\alpha \in U_\alpha \cap A, x_\alpha \neq x$인 $x_\alpha$가 존재한다. $x_\alpha → x$임을 확인하라.</li>
</ol>

<blockquote>
  <p><strong>정의.</strong> $(x_\alpha)_{\alpha \in J}$가 그물이라고 하자. $(I, \preceq)$가 방향 집합이고, $g: (I, \preceq) → (J, \leq)$가 순서 보존이며, $\operatorname{im}g$가 공종일 때, $(x_{g(\beta)})_{\beta \in I}$를 $(x_\alpha)$의 부분그물이라고 한다.</p>
</blockquote>

<blockquote>
  <p><strong>정리.</strong> $X$가 콤팩트할 필요충분조건은 임의의 그물이 수렴하는 부분그물을 가지는 것이다.</p>
</blockquote>

<p><strong>Remark.</strong> ”수렴하는 점렬이 존재한다“는 ”수렴하는 그물이 존재한다“보다 강한 조건이지만, ”임의의 점렬이 수렴하는 부분점렬을 가진다”는 “임의의 그물이 수렴하는 부분그물을 가진다”보다 강하지도, 약하지도 않은 조건임에 유의하라. 주어는 후자가 더 강하고, 술어는 전자가 더 강하다. 따라서 <strong>콤팩트성과 점렬 콤팩트성은 일반적으로 시사 관계가 없다.</strong> 구체적으로,</p>

<blockquote>
  <p><strong>정리.</strong></p>

  <ol>
    <li>콤팩트 $\not\rightarrow$ 점렬 콤팩트</li>
    <li>점렬 콤팩트 $\not\rightarrow$ 콤팩트</li>
  </ol>
</blockquote>

<p><strong>증명.</strong></p>

<ol>
  <li>$[0, 1]^{[0, 1]}$은 티호노프 정리에 의해 콤팩트하지만 점렬 콤팩트하지 않다.</li>
  <li>Long line과 $\omega_1$은 점렬 콤팩트하지만 콤팩트하지 않다.</li>
</ol>

  </div>
  <!-- <div
    style="border-bottom: 1px solid var(--lighter-slate); margin-bottom: 4em"
  ></div> -->
  <div style="margin-bottom: 6em"></div>
  
</div>

<div class="pagination">
  
  <a
    class="pagination-item older"
    href="/page8"
    >이전 글</a
  >
    
  <a
    class="pagination-item newer"
    href="/page6"
    >다음 글</a
  >
   
</div>

<script>
  const faders = document.querySelectorAll(".fade-in-section");

  const appearOptions = {
    // threshold: 0.05,
    // rootMargin: "0px 0px 50px 0px",
  };

  const appearOnScroll = new IntersectionObserver((entries, observer) => {
    entries.forEach((entry) => {
      if (entry.isIntersecting) {
        entry.target.classList.add("is-visible");
        observer.unobserve(entry.target);
      }
    });
  }, appearOptions);

  faders.forEach((fader) => {
    appearOnScroll.observe(fader);
  });
</script>
</div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script src="/public/js/script.js"></script>
  </body>
</html>
