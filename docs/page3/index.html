<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile" />
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />

  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=1"
  />

  <title>
     디멘의 블로그 &middot; 이데아를 여행하는 히치하이커 
  </title>

  <script>
    MathJax = {
      tex: {
        inlineMath: [
          ["$", "$"],
          ["\\(", "\\)"],
        ],
      },
      svg: {
        fontCache: "global",
      },
    };
  </script>
  <script
    type="text/javascript"
    id="MathJax-script"
    async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
  ></script>

  
  <link rel="canonical" href="/page3/" />
  

  <link rel="stylesheet" href="/public/css/poole.css" />
  <link rel="stylesheet" href="/public/css/syntax.css" />
  <link rel="stylesheet" href="/public/css/lanyon.css" />
  <link
    rel="stylesheet"
    href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400"
  />

  <!-- <link rel="apple-touch-icon-precomposed" sizes="144x144" href="">
  <link rel="shortcut icon" href="">
   -->
  <link
    rel="apple-touch-icon-precomposed"
    sizes="144x144"
    href="/public/apple-touch-icon.png"
  />
  <link rel="shortcut icon" href="/public/favicon.ico" />
  <!-- <link rel="alternate" type="application/rss+xml" title="RSS" href="http://localhost:4000/atom.xml"> -->
  <link
    rel="alternate"
    type="application/rss+xml"
    title="RSS"
    href=""
  />

  <script
    async
    src="https://www.googletagmanager.com/gtag/js?id=G-PVGYLWF7GR"
  ></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
      dataLayer.push(arguments);
    }
    gtag("js", new Date());

    gtag("config", "G-PVGYLWF7GR");
  </script>
</head>


  <body>

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p>이데아를 여행하는 히치하이커</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item" href="/">최근 글</a>

    

    
    
      
        
      
    
      
        
      
    
      
        
          <a class="sidebar-nav-item" href="/about/">저에 대하여</a>
        
      
    
      
        
          <a class="sidebar-nav-item" href="/archive-date/">날짜별로 보기</a>
        
      
    
      
        
          <a class="sidebar-nav-item" href="/archive-tag/">주제별로 보기</a>
        
      
    
      
    
      
        
          <a class="sidebar-nav-item" href="/guestbook/">방명록</a>
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
    
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
  </nav>

  <div class="sidebar-item">
    <p>
      &copy; 2025. All rights reserved.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/" title="Home">디멘의 블로그</a>
            <small>이데아를 여행하는 히치하이커</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="posts">
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2025/02/07/arithmetic-hierarchy/">
        산술 위계
      </a>
    </h1>

    <span class="post-date">07 Feb 2025</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/수학/'" >수학</div>
      
      <div class="tag" onclick="location.href='/tags/수리논리학/'" >수리논리학</div>
      
    </div>
  
    <p><img src="/public/arithmetic-hierarchy.png" width="340px" style="margin: 2em auto;" /></p>

<blockquote>
  <p><strong>주의.</strong> 이 글은 뇌피셜로 쓰였기 때문에 엄밀하지 않고, 심지어 틀린 내용이 있을 수 있습니다.</p>
</blockquote>

<p><strong>산술 위계(arithmetical hierarchy)</strong>는 산술 — 엄밀히는 1차 페아노 산술 — 의 명제들을 양화사의 복잡도에 따라 분류한 것이다. 산술 위계는 증명 이론 및 계산 복잡도 이론의 핵심 개념이며, 기술적 집합론과도 연관이 있다.</p>

<h2 id="1-delta_0-명제">1. $\Delta_0$ 명제</h2>

<h3 id="11-정의">1.1. 정의</h3>

<blockquote>
  <p><strong>정의.</strong> $\Sigma_0 = \Pi_0 = \Delta_0$는 상한이 있는 양화사만을 가지는 명제들의 집합이다.</p>
</blockquote>

<p>왜 같은 부류의 명제를 세 개의 이름으로 부르는지는 곧 명확해질 것이다. 이 글에서는 특별한 이유가 없을 때에는 세 이름 중 $\Delta_0$라는 이름을 대표로 사용하겠다.</p>

<p>예를 들어 다음 네 명제들은 모두 $\Delta_0$ 명제들이다.</p>

\[\begin{gather}
\phi_1 : 0 = 1\\
\phi_2(x) : \exists y &lt; x \; [y + y = x] \\
\phi_3(x, y) : \exists z \leq y \;[ xz = y ] \\
\end{gather}\]

<p>$\phi_1$은 거짓인 문장이다. $\phi_2$는 $x$가 짝수일 때, $\phi_3$는 $x$가 $y$의 약수일 때 참인 명제이다.</p>

<p>$\Delta_0$ 명제들은 양화사에 상한이 걸려 있기 때문에, 임의의 $x$가 주어졌을 때 $x$가 해당 명제에 부합하는지를 튜링 기계로 판단할 수 있다. 예를 들어 $x$가 $\phi_2$를 만족하는지 판단하는 튜링 기계는 다음과 같다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for y &lt; x:
   if y + y == x:
      return true;

return false;
</code></pre></div></div>

<p>위 튜링 기계는 $x$번의 반복 이내에 정지한다. 따라서 $\Delta_0$는 또는 튜링 기계 등의 기계 장치로 <strong>결정 가능(decidable)</strong>한, 또는 <strong>재귀적인(recursive)</strong>, 또는 <strong>계산 가능(computable)</strong>한 명제들이다(세 표현은 동의어이다). 그러나 뒤에서 자세히 설명하듯이, 모든 결정 가능한 명제들이 $\Delta_0$인 것은 아니다.</p>

<p>괴델의 표현가능성 정리에 따라 결정 가능한 참인 명제는 증명 가능하다. 그리고 이 글에서 $\phi$가 ‘참’이라 함은, $\mathsf{PA} \vDash \phi$가 아니라, 표준 자연수 모형 $\mathcal{N}$에 대해 $\mathcal{N} \vDash \phi$라는 의미이다. 다시 말해, 다음이 성립한다.</p>

<blockquote>
  <p><strong>정리.</strong> 참인 $\Delta_0$ 문장들의 집합은 완전하다. (즉, $\phi$가 참인 $\Delta_0$ 문장이라면 $\mathsf{PA} \vdash \phi$이다.)</p>
</blockquote>

<h3 id="12-계산-이론에서의-delta_0">1.2. 계산 이론에서의 $\Delta_0$</h3>

<p>프로그래밍 언어의 관점에서 보았을 때 $\Delta_0$ 문장들은 다음만을 허용하는 코드의 집합과 대응된다.</p>

<ul>
  <li>조건문</li>
  <li>상한이 있는 반복문</li>
  <li>덧셈과 곱셈</li>
</ul>

<p>주의할 점은, <em>상한이 없는 반복문</em>과 <em>변수 재지정</em>은 허용되지 않는다는 것이다. 예를 들어 다음의 코드는 소수 판별이 $\Delta_0$임을 입증한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for y &lt; x:
  for z &lt;= y:
    if yz == x:
      return false;

return true;
</code></pre></div></div>

<p>그러나 $x^y$를 계산하는 다음의 코드는 $\Delta_0$에 해당되지 않는다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let a = 1
for 1&lt;= z &lt;= y:
   a = a * x

return a
</code></pre></div></div>

<p>그렇다면 지수 연산은 $\Delta_0$가 아닌 것일까? 그렇지는 않다. 복잡하긴 하지만, $\Delta_0$ 명제로 지수를 표현하는 방법이 <a href="https://math.stackexchange.com/questions/5032077/how-to-express-exponentiation-with-a-delta-0-formula">있다</a>. 이 사례는 주어진 연산 또는 술어가 $\Delta_0$인지 판단하는 일이 까다로울 수 있음을 방증한다. 일례로 다음이 알려져 있다.</p>

<blockquote>
  <p><strong>정리.</strong> 팩토리얼은 $\Delta_0$이지만 테트레이션은 $\Delta_0$가 아니다.</p>
</blockquote>

<p>그러나 테트레이션은 결정 가능하다. 따라서 모든 결정 가능한 명제들이 $\Delta_0$인 것은 아니다.</p>

<h2 id="2-한-단계-올라가기">2. 한 단계 올라가기</h2>

<blockquote>
  <p><strong>정의.</strong></p>

\[\begin{gather}
\Sigma_1 := \{ \exists x_1 \cdots \exists x_n \;\phi : \phi \in \Pi_0 \}\\
\Pi_1 := \{ \forall x_1 \cdots \forall x_n \;\phi : \phi \in \Sigma_0 \}\\
\Delta_1 := \Sigma_1 \cap \Pi_1
\end{gather}\]
</blockquote>

<h3 id="21-sigma_1-명제">2.1. $\Sigma_1$ 명제</h3>

<p>다음 명제들은 $\Sigma_1$이다.</p>

\[\begin{gather}
\phi_1(x): \exists y \; \underbrace{[y^2 + y + 1 = x]}_{\Pi_0}\\
\phi_2(x): ∃y\; ∃z\; \underbrace{(y \text{ is prime} ∧ z \text{ is prime} ∧ x = y + z ∧ x \text{ is even})}_{\Pi_0}
\end{gather}\]

<p>$\phi_1$은 집합 $\lbrace 1, 3, 7, 13, \dots \rbrace$에서 참이다. $\phi_2$는 골드바흐의 추측으로, 모든 $x$가 이를 만족하는지는 알려져 있지 않다.</p>

<p>$\Sigma_1$은 <strong>재귀적으로 열거 가능(recursively enumerable)</strong>한 집합들의 모임이다. 즉, $\phi \in \Sigma_1$이라면 다음의 튜링 기계 $M$이 존재한다.</p>

<ul>
  <li>$\phi(c)$가 참이라면 $M$이 $\phi(c)$를 결정함이 보장된다.</li>
  <li>$\phi(c)$가 거짓이라면 $M$이 $\phi(c)$를 결정함이 보장되지 않는다.</li>
</ul>

<p>예를 들어 다음의 튜링 기계는 $\phi_2$가 재귀적으로 열거 가능함을 보여준다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for y &gt; 1:
   for z &gt; 1:
      if isPrime(y) &amp; isPrime(z) &amp; x = y + z &amp; isEven(x):
         return true;

return false;
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">return false</code> 문이 있기는 하지만, 반복문에서 빠져나올 <code class="language-plaintext highlighter-rouge">break</code> 문이 없으므로 <code class="language-plaintext highlighter-rouge">return false</code>는 도달 불가능하다. 즉, $\phi_2(c)$가 참이라면 위의 튜링 기계는 참을 반환하지만 거짓이라면 무한 루프에 빠진다.</p>

<p>$\phi \in \Sigma_1$이 표준 자연수 모형에서 참인 문장이라면 $\mathsf{PA} \vdash \phi$이다. $\phi : \exists x \; \psi(x)$ 꼴의 명제가 표준 자연수 모형에서 참이라는 것은 어떤 $c \in \mathbb{N}$에 대해 $\psi(c)$가 참이라는 의미이며, $\psi(c)$는 참인 $\Pi_0$ 문장이므로 증명 가능하기 때문이다. 따라서 다음이 성립한다.</p>

<blockquote>
  <p><strong>정리.</strong> 참인 $\Sigma_1$ 문장들의 집합은 완전하다.</p>
</blockquote>

<h3 id="22-sigma_1-setminus-delta_0-명제">2.2. $\Sigma_1 \setminus \Delta_0$ 명제</h3>

<p>그런데 사실 지금까지 필자는 독자를 오도했다. 앞서 $\Sigma_1$의 예시로 나열한 명제들은 사실 $\Delta_0$로 쓸 수 있기 때문이다.</p>

\[\begin{gather}
\phi_1: \exists y&lt;x \;{[y^2 + y + 1 = x]}\\
\phi_2(x): ∃y&lt;x\; ∃z&lt;x\; {(y \text{ is prime} ∧ z \text{ is prime} ∧ x = y + z ∧ x \text{ is even})}
\end{gather}\]

<p>그렇다면 $\Delta_0$에 속하지 않는 $\Sigma_1$ 명제는 어떻게 생겼을까? 한 가지 답은 <strong>정지 문제</strong>에서 찾을 수 있다.</p>

<p>먼저 $\mathrm{HaltsIn}(x, n)$를, “괴델 수가 $x$인 튜링 기계”가 $n$회의 연산 이내에 출력값을 내놓는지를 판별하는 술어라고 하자. 이 술어는 <strong>클레이니 술어</strong>로부터 쉽게 정의할 수 있으며, 클레이니 술어는 $\Sigma_0$임이 알려져 있다. 예를 들어 3의 제곱을 2회의 연산으로 계산하는 튜링 기계의 괴델 수가 $123$이라면 $\mathrm{HaltsIn}(123, 3)$은 참이지만 $\mathrm{HaltsIn}(123, 1)$는 거짓이다.</p>

<p>이제 다음 명제를 고려하자.</p>

\[\phi_1(x): \exists y \;[ \mathrm{HaltsIn}(x, y) ]\]

<p>위 명제가 말하는 바는, 괴델 수가 $x$인 튜링 기계가 언젠가 정지한다는 것이다. 즉, 위 명제는 정지 문제와 동치이다. 그런데 정지 문제는 결정 불가능하다. 앞서 $\Delta_0$ 명제는 모두 결정 가능함을 보았으므로, $\phi$는 $\Delta_0$에 속하지 않는 $\Sigma_1$ 명제이다.</p>

<p>다른 예시로, 다음 명제를 고려하자.</p>

\[\phi_2(x): \exists y \; [ \mathrm{Proves}(x, y) ]\]

<p>여기서 $\mathrm{Proves}(x, y)$는 “괴델 수가 $x$인 문장의 증명”의 괴델 수가 $y$일 때 참인 술어이다. 즉, $\phi_2(x)$는 괴델 수가 $x$인 문장이 증명 가능하다는 술어이다. 그런데 이 술어는 결정 가능하지 않다. 만약 $\phi_2$가 결정 가능하다면 (PA가 무모순적이라는 가정 하에) $\phi_2(\ulcorner 0 = 1 \urcorner)$이 거짓이라는 증명이 PA에 존재하게 되어 괴델의 불완전성 정리와 상충하기 때문이다.</p>

<h3 id="23-pi_1-명제">2.3. $\Pi_1$ 명제</h3>

<p>$\Sigma_1$ 명제가 재귀적으로 열거 가능한 명제들의 모임이라면, $\Pi_1$ 명제는 <strong>쌍대-재귀적으로 열거 가능한(co-recursively enumerable)</strong> 명제들의 모임이다. 즉 $\Pi_1$의 문장은 거짓이라면 결정 가능하지만 참이라면 결정 가능성이 보장되지 않는다. 예를 들어 다음 두 명제는 $\Delta_0$가 아닌 $\Pi_1$ 문장이다.</p>

\[\begin{gather}
\phi_3(x): \forall y \;[ \lnot \mathrm{HaltsIn}(x, y) ] \\
\phi_4(x): \forall y \; [ \lnot \mathrm{Proves}(x, y) ]
\end{gather}\]

<p>$\Sigma_1$의 경우와 달리, $\Pi_1$은 완전하지 않다. $\Sigma_1$ 문장의 부정이 $\Pi_1$이기 때문에, $\Pi_1$ 또한 완전하다면 $\Sigma_1 = \Pi_1=$ (결정 가능한 명제들의 모임)이 되기 때문이다.</p>

<blockquote>
  <p><strong>정리.</strong> 참인 $\Pi_1$ 문장들의 집합은 완전하지 않다.</p>
</blockquote>

<h3 id="24-delta_1-명제">2.4. $\Delta_1$ 명제</h3>

<p>$\Delta_1$ 명제는 $\Sigma_1$과 $\Pi_1$에 모두 속한다. 따라서 $\Delta_1$은 <strong>결정 가능한</strong> 명제들의 모임이다. 앞서 본 테트레이션은 $\Delta_0$가 아닌 $\Delta_1$ 명제이다.</p>

<h2 id="3-한-단계-더-올라가기">3. 한 단계 더 올라가기</h2>

<blockquote>
  <p><strong>정의.</strong></p>

\[\begin{gather}
\Sigma_2 := \{ \exists x_1 \cdots \exists x_n \;\phi : \phi \in \Pi_1 \}\\
\Pi_2 := \{ \forall x_1 \cdots \forall x_n \;\phi : \phi \in \Sigma_1 \}\\
\Delta_2 := \Sigma_2 \cap \Pi_2
\end{gather}\]
</blockquote>

<p>이제 패턴이 보일 거라 생각한다. $\Sigma_2$ 명제의 예시로, 다음을 보자.</p>

\[\phi_5(x) : \exists y \; [ \mathrm{DoesNotHaltOn}(x, y)]\]

<p>여기서 $\mathrm{DoesNotHaltOn}(x, y)$는, “괴델 수가 $x$인 튜링 기계”에 $y$를 입력했을 때 정지하지 않으면 참인 술어이다. 앞선 논의로부터 $\mathrm{DoesNotHaltOn}$이 $\Pi_1$임을 어렵지 않게 알 수 있다.</p>

<blockquote>
  <p><strong>정리.</strong> $\phi_5 \notin \Pi_1$</p>
</blockquote>

<p><strong>증명.</strong> $\phi_5 \in \Pi_1$이라고 가정하자. 우리의 목표는 이 가정이 “참인 $\Pi_1$ 문장들의 집합은 완전하다”를 시사함을 보이는 것이다.</p>

<p>$\psi(x)$가 임의의 $\Delta_0$ 명제라고 하자. $\theta : \forall x \;\psi(x)$는 $\Pi_1$ 문장이다. 다음의 튜링 기계 $M$을 생각하자.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if ψ(x):
   return 1;

while True:
</code></pre></div></div>

<p>이 튜링 기계는 값 $x$에 대해 $\psi(x)$가 참이면 정지하고 거짓이면 정지하지 않는다. 따라서 $\theta$가 참이라는 것은 모든 $x$에 대해 $M$이 정지한다는 것과 동치이며, 이것은 $\phi_5(\ulcorner M \urcorner)$이 거짓임과 동치이다. 그리고 가정에 의해 $\phi_5 \in \Pi_1$이므로, $\phi_5(\ulcorner M \urcorner)$이 거짓이라면 $\mathsf{PA} \vdash \lnot \phi(\ulcorner M \urcorner)$이다. 즉, $\mathsf{PA} \vdash \theta$가 되어 모든 참인 $\Pi_1$ 문장은 증명 가능하게 된다. 이것은 모순이다. ■</p>

<p><em>Remark.</em> 엄밀히는 위의 증명이 PA 내에서 표현 가능함을 보여야 한다.</p>

<p>앞서 $\Sigma_1$ 명제는 참일 때 결정 가능하고, $\Pi_1$ 명제는 거짓일 때 결정 가능하다고 했다. 그런데 $\Sigma_2$ 문장은 $\forall$과 $\exists$가 섞여 있기 때문에, 참일 때에도, 거짓일 때에도 결정이 불가능한 문장이 있을 수 있다.</p>

<h3 id="31-오라클">3.1. 오라클</h3>

<blockquote>
  <p><strong>정의.</strong> $\mathcal{O}$가 단 한 번의 연산으로 문제 $P$의 결과를 구할 수 있을 때 $\mathcal{O}$을 $P$의 <strong>오라클</strong>이라고 한다.</p>
</blockquote>

<p>예를 들어 정지 문제의 오라클은 주어진 튜링 기계의 정지 연부를 단 한 번의 연산으로 알아낼 수 있는, 그야말로 신적인 존재다.</p>

<p>산술 위계를 오르는 것은 점점 더 강한 오라클이 주어지는 것과 같다. 앞서 $\Sigma_1$ 명제의 예시로 다음을 보았다.</p>

\[\phi_1(x): \exists y \;[ \mathrm{HaltsIn}(x, y) ]\]

<p>그런데 만약 정지 문제 오라클 $\mathcal{O}$가 주어졌다면, $\phi_1$은 $\Delta_0$ 명제로 단순하게 표현 가능하다.</p>

\[\phi_1(x) : \mathcal{O}(x)\]

<p>또한 앞서 $\Sigma_2$ 명제의 예시로 다음을 보았다.</p>

\[\phi_5(x) : \exists y \; [ \mathrm{DoesNotHaltOn}(x, y)]\]

<p>정지 문제 오라클 $\mathcal{O}$가 주어졌다면, $\phi_5$는 $\Sigma_1$ 명제로 표현 가능하다.</p>

\[\phi_5(x): \exists y \; \lnot \mathcal{O}(x|_y)\]

<p>여기서 $x|_y$는 괴델 수가 $x$인 튜링 기계에 $y$를 입력한 상태의 괴델 수이다. 즉, $\Sigma_2$ 명제는 정지 문제의 오라클이 주어졌을 때 $\Sigma_1$ 명제로 환원된다. 비슷한 원리로, $\Pi_2$ 명제와 $\Delta_2$ 명제는 각각 정지 문제의 오라클이 주어졌을 때 $\Pi_1$ 명제와 $\Delta_1$ 명제로 환원된다.</p>

<p>나아가 <strong>2차 오라클</strong>을 정의할 수 있다. 2차 정지 문제 오라클은, 정지 문제 오라클을 사용하는 튜링 기계들에 대한 정지 문제 오라클이다. 예를 들어 $\mathcal{O}$가 다음 코드의 정지 여부를 판단하는 데 그치는 데 반해,</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for x &gt; 0:
   for y &gt; 0:
      for z &gt; 0:
         for n &gt; 2:
            if x^n + y^n == z^n:
               return True;
return False;
</code></pre></div></div>

<p>$\mathcal{O}^2$은 다음 코드의 정지 여부를 판단할 수도 있다. 다음의 코드는 NP 튜링 기계의 괴델 수 $x$를 입력받았을 때, $x$와 출력이 일치하는 P 튜링 기계가 존재하면 정지하고 존재하지 않으면 정지하지 않는다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let x ∈ NP;
for y ∈ P:
   if !Halts(
      let z = 0
      while x(z) == y(z):
         z = z + 1
   ):
      return 1; // x가 P에 속하는 NP일 때 정지
</code></pre></div></div>

<p>일반적으로 다음이 성립한다.</p>

<blockquote>
  <p><strong>정리.</strong> $\Pi_n, \Sigma_n, \Delta_n$의 명제들은 $k$차 오라클이 주어졌을 때 각각 $\Pi_{n - k}, \Sigma_{n - k}, \Delta_{n - k}$의 명제들이 된다.</p>
</blockquote>

  </div>
  <div style="border-bottom: 1px solid var(--lighter-slate); margin-bottom: 4em;"></div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2025/02/05/order/">
        곱군과 위수에 관한 노트: 페르마 소수 정리와 윌슨의 정리
      </a>
    </h1>

    <span class="post-date">05 Feb 2025</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/수학/'" >수학</div>
      
      <div class="tag" onclick="location.href='/tags/대수학/'" >대수학</div>
      
    </div>
  
    <h3 id="remarks">Remarks</h3>

<table>
  <thead>
    <tr>
      <th><strong>곱군</strong></th>
      <th><strong>합군</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1이 항등원</td>
      <td>0이 항등원</td>
    </tr>
    <tr>
      <td>$x$의 위수가 $r$일 때, $x^r = 1$</td>
      <td>$x$의 위수가 $r$일 때, $rx = 0$</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>소수 $p$에 대해 $p - 1$에 대한 정보가 주어졌다면 위수가 $p - 1$인 곱군 $(\mathbb{Z}/p\mathbb{Z})^\times$을 생각해 보자.</li>
  <li>곱군 $G$에 대해 $nm \mid |G|$는, $x^{nm} = 1$이지만 $x^n, x^m \neq 1$인 원소 $x$의 존재성과 동치이다.</li>
  <li>위수는 주기와 다르다. 일반적으로 <strong>(주기) = (위수) + 1</strong>이다.</li>
</ul>

<h3 id="페르마-소수-정리">페르마 소수 정리</h3>

<blockquote>
  <p><strong>정리.</strong> 소수 $p$가 두 정수 $a, b$에 대해 $p = a^2 + b^2$ 꼴로 나타내어질 필요충분조건은 $p \bmod 1 = 4$인 것이다.</p>
</blockquote>

<p><strong>증명.</strong></p>

<p>(⇒) 자명</p>

<p>(⇐) $G = (\mathbb{Z}/p\mathbb{Z})^\times$라고 하자. 조건에 의해 $4 \mid |G|$이다. 따라서 $n^4 = 1$이지만 $n^2 \neq 1$인 원소 $n$이 존재한다. 즉, $n^2 = -1$이다. 따라서 $p \mid n^2 + 1$이다. 이제 $\mathbb{Z}[i]$에서 생각해 보면 $p \mid (n + i)(n - i)$이다. 만약 $p$가 $\mathbb{Z}[i]$에서 기약이었다면 $p \mid n + i$ 또는 $p \mid n - i$인데 둘 다 불가능하다. 따라서 $p$는 기약이 아니며, 켤레성에 의해</p>

\[p = (a + bi)(a - bi) = a^2 + b^2\]

<p>이다. ■</p>

<h3 id="윌슨의-정리">윌슨의 정리</h3>

<blockquote>
  <p><strong>정리.</strong> $p$가 소수일 필요충분조건은 $(p - 1)! \equiv -1 \mod p$인 것이다.</p>
</blockquote>

<p><strong>증명.</strong></p>

<p>(⇒) $G = (\mathbb{Z}/p\mathbb{Z})^\times$라고 하자. $G$의 원소를 모두 곱한 값은 $(p - 1)!$이다. $x^2 = 1$의 근인 $\pm 1$을 제외한 $G$의 모든 원소는 자기 자신을 역원으로 가지지 않는다. 따라서 $(p - 1)! \equiv -1$이다.</p>

<p>(⇐) $N = (p - 1)! + 1$이라고 하자. 조건에 의해 $p \mid N$이다. 만약 $p$가 소수가 아니라면 어떤 소수 $q &lt; p$에 대해 $q \mid N$이다. 그러나 $N \bmod q = 1$이므로 모순이다. ■</p>

  </div>
  <div style="border-bottom: 1px solid var(--lighter-slate); margin-bottom: 4em;"></div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2025/01/25/beta-function/">
        베타 함수를 통한 페아노 산술에서의 괴델 수 정의
      </a>
    </h1>

    <span class="post-date">25 Jan 2025</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/수학/'" >수학</div>
      
      <div class="tag" onclick="location.href='/tags/수리논리학/'" >수리논리학</div>
      
    </div>
  
    <p><strong>요약.</strong> 1차 페아노 산술은 술어에 대한 양화를 허용하지 않기 때문에 덧셈과 곱셈 공리를 별도로 요구한다. 그러나 지수나 계승 등의 추가적인 연산은 — 튜플을 페아노 산술에서 정의할 수 있는 한 — 별도의 공리 없이 정의 가능하다. 그리고 튜플은 베타 암호화를 통해 페아노 산술에서 정의 가능하기 때문에, 페아노 산술은 지수, 계승, 소인수분해, 나아가 괴델 수까지 형식화할 수 있다.</p>

<h2 id="1-서론">1. 서론</h2>

<blockquote>
  <p><strong>정의.</strong> <strong>페아노 산술(Peano arithmetics, PA)</strong>은 $(0, S, +, \cdot)$를 부호수(signature)로 가지는 이론으로, 공리는 다음과 같다.</p>

  <ol>
    <li>$\forall x : S(x) \neq 0$</li>
    <li>$\forall x, y : S(x) = S(y) \rightarrow x = y$</li>
    <li>$\forall x : x + 0 = x$</li>
    <li>$\forall x, y : x + S(y) = S(x + y)$</li>
    <li>$\forall x, y : x \cdot 0 = 0$</li>
    <li>$\forall x, y : x \cdot S(y) = (x \cdot y) + x$</li>
  </ol>

  <p>추가로 다음의 귀납 공리꼴(axiom schema)을 가진다. 임의의 1차 논리식 $\phi(x)$에 대해,</p>

  <p> 7. $\big[ \phi(0) \land \forall x \; [ \phi(x) \rightarrow \phi(S(x)) ] \big] \rightarrow \forall x \;\phi(x)$</p>
</blockquote>

<p>추가적으로 편의를 위해 $&lt;, -, \bmod$를 다음과 같이 정의한다.</p>

\[\begin{aligned}
&amp;x &lt; y : &amp;&amp;\exists z \neq 0\; [x + z = y]\\
&amp;x - y = z : &amp;&amp;x = y + z \\
&amp;x \bmod y = z: &amp;&amp; (z &lt; y) \land \exists q \;[ qy + z = x ]
\end{aligned}\]

<p>역사적으로 데데킨트가 처음 제시한 페아노 산술은 2차 논리 이론이었기 때문에 귀납 <em>공리꼴</em> 대신 귀납 <em>공리</em>가 있었다. 또한 3번부터 7번 공리가 없었다.</p>

<blockquote>
  <p><strong>정의.</strong> <strong>2차 논리 페아노 산술</strong>은 $(0, S)$를 부호수(signature)로 가지는 이론으로, 공리는 다음과 같다.</p>

  <ol>
    <li>$\forall x : S(x) \neq 0$</li>
    <li>$\forall x, y : S(x) = S(y) \rightarrow x = y$</li>
    <li>$\forall \phi \bigg[ \big[ \phi(0) \land \forall x \; [ \phi(x) \rightarrow \phi(S(x)) ] \big] \rightarrow \forall x \;\phi(x)\bigg]$</li>
  </ol>
</blockquote>

<p>나머지 공리가 불필요한 이유는, 2차 논리는 술어에 대한 양화를 허용하기 때문에 2차 논리식만으로 덧셈과 곱셈을 정의할 수 있기 때문이다. 예를 들어 $w = u + v$는 다음 논리식과 동치이다.</p>

\[\forall \phi \bigg[ \forall x, y, z \big[ \phi(x, 0, x) \land (\phi(x, S(y), z) \rightarrow \phi(x, y, S(z)) \big] \rightarrow \phi(u, v, w) \bigg]\]

<p>그러나 2차 논리는 수많은 수학적 ·  철학적 허점을 가지는 것으로 드러났기 때문에 서두에서 소개한 1차 논리 페아노 산술이 표준으로 선택되었다. 이 선택의 함의는 첫째로 귀납 공리가 귀납 공리꼴이 된다는 것이고, 둘째는 덧셈과 곱셈을 별도의 공리를 통해 정의해야 한다는 것이다.</p>

<p>그런데 이런 의문이 남는다. 덧셈과 곱셈 말고 다른 연산은 따로 정의할 필요가 없는 것일까? 예를 들어 지수, 소인수분해, 계승과 같은 연산은 별도의 공리 없이 정의 가능할까? 나아가, 임의의 논리식을 자연수에 대응시키는 괴델 수 기법은 페아노 산술만으로 정의 가능할까?</p>

<h2 id="2-튜플">2. 튜플</h2>

<p>이 의문에 답하는 혜안은, <strong>튜플</strong>을 페아노 산술에서 정의할 수 있다면 기타 수많은 연산이 정의 가능해진다는 사실이다. 여기서 튜플이란 $(1, 4, 2)$와 같은 유한한 자연수의 나열을 말한다.</p>

<p>일례로 다음과 같은 술어와 함수들이 정의되어 있다고 가정하자.</p>

<ul>
  <li>$\mathrm{Tup}(\tau):$ $\tau$가 튜플이다.</li>
  <li>$\mathrm{At}(\tau, i):$ $\tau$가 튜플일 때, $\tau$의 $i$번째 자연수를 반환한다.</li>
  <li>$\mathrm{Len}(\tau):$ $\tau$의 길이를 반환한다.</li>
</ul>

<p>편의를 위해 $\mathrm{At}(\tau, i)$를 $\tau[i]$로 쓰도록 하자. 예를 들어 $\tau = (1, 4, 2)$라면 다음이 성립한다. (인덱스는 0부터 시작하는 것으로 생각한다)</p>

\[\mathrm{Tup}(\tau) \; \land \;  \mathrm{Len}(\tau) = 3 \;\land\; \tau[1] = 4\]

<p>튜플을 사용하면 다음과 같이 $z = x^y$를 정의할 수 있다.</p>

\[\forall \tau \bigg[ \big[ \mathrm{Tup}(\tau)\; \land \; \tau[0] = 1 \;\land \forall i &lt; y (\tau[i + 1] = \tau[i] \cdot x) \big] \rightarrow \tau[y] = z \bigg]\]

<h2 id="3-베타-암호화">3. 베타 암호화</h2>

<p>그렇다면 튜플을 덧셈과 곱셈, 그리고 1차 논리식만으로 정의할 수 있을까? 이에 대한 답은 <strong>“가능하다”</strong>이다. 아니나다를까역시나적시나 이 결과를 처음 증명한 사람은 괴델이다. 먼저 다음의 정리를 상기하자.</p>

<blockquote>
  <p><strong>중국인의 나머지 정리.</strong> $(n_1, \dots, n_k)$가 켤레서로소(pairwise coprime)라고 하자. $0 \leq r_i &lt; n_i$인 임의의 $(r_1, \dots, r_k)$에 대해 다음을 만족하는 수 $x$가 언제나 존재한다.</p>

\[x \bmod n_i = r_i\]
</blockquote>

<p>괴델의 아이디어는 중국인의 나머지 정리에서 $x$에 해당하는 수를 튜플 $(r_1, \dots, r_k)$의 코드로 생각하는 것이다. 그런데 여기에는 문제가 있다. $x$로부터 $(r_1, \dots, r_k)$를 복호화하기 위해서는 $(n_1, \dots, n_k)$가 주어져야 하는데, 이는 또다시 튜플을 요구하기 때문이다.</p>

<p>이 문제를 해결하기 위해 괴델은 다음의 보조정리를 꺼내든다.</p>

<blockquote>
  <p><strong>보조정리.</strong> $n!+ 1, 2n! + 1, \dots, n \cdot n! + 1$은 켤레서로소이다.</p>
</blockquote>

<p><strong>증명.</strong> $1 \leq a &lt; b \leq n$에 대해 $u = an! + 1, v = bn! + 1$이라고 하자.  유클리드 호제법에 의해,</p>

\[\mathrm{gcd}(u, v) = \mathrm{gcd}(u, v - u) = \mathrm{gcd}(an! + 1, (b - a)n!)\]

<p>이다. $(b - a)n!$의 모든 약수의 집합은 $\lbrace  1, 2, \dots, n\rbrace $이다. 그런데 이중 어느 원소도 $an! + 1$의 약수가 아니므로 $\mathrm{gcd}(an! + 1, (b - a)n!) = \mathrm{gcd}(u, v) = 1$이다. □</p>

<p>이제 우리는 튜플을 <strong>순서쌍</strong>으로서 정의할 수 있다.</p>

<blockquote>
  <p><strong>정의.</strong> 튜플 $(r_1, \dots, r_k)$를 다음과 같이 순서쌍 $\langle a, b \rangle$로 표현한다.</p>

  <ul>
    <li>$b = n! \quad \text{where} \quad n = \max(r_1, \dots, r_k, k)$</li>
    <li>$a \bmod (kb + 1) = r_k$</li>
  </ul>

  <p>단, $a$는 2번 조건을 만족하는 자연수 중 가장 작은 자연수로 선택한다.</p>
</blockquote>

<p>한편 튜플은 칸토어 대응을 통해 자연수로 표현이 가능하다.</p>

<blockquote>
  <p><strong>정의.</strong></p>

\[\langle a, b \rangle = \frac{(a + b)(a + b + 1)}{2} + b\]

</blockquote>

<p>이로써 우리는 튜플 $\tau$를 자연수 $n$으로 암호화(coding)할 수 있다. 그리고 역으로 $n$이 주어지면 덧셈, 곱셈, 그리고 나머지 연산만을 사용하여 $\tau$를 복호화해낼 수 있다. 그리고 나머지 연산은 덧셈, 곱셈, 그리고 1차 논리로부터 쉽게 정의가 가능하므로, 목표가 달성되었다.</p>

<p>역사적으로 괴델이 증명한 정리는 다음과 같다.</p>

<blockquote>
  <p><strong>$\beta$-함수 보조정리.</strong> 임의의 자연수열 $(n_1, \dots, n_k)$에 대해, 어떤 자연수 $a, b$가 존재하여 $1 \leq i \leq k$에 대해 $\beta(a, b, i) = n_i$이다. 여기서 $\beta$는 다음과 같이 정의된 함수이다.</p>

\[\beta(x, y, i) = x \bmod (iy + 1)\]

</blockquote>

<p>이런 이유로 지금까지의 과정을 <strong>베타 암호화(Beta coding)</strong>라고 부른다. 괴델은 베타 암호화를 이용하여 지수 연산과 소인수분해를 PA에서 성공적으로 정의했으며, 이로부터 괴델 수와 비롯된 여러 술어를 PA에서 형식화할 수 있었다. 제목에서 드러나다시피 원래 이 글의 목표는 이 과정을 모두 개괄하는 것이었으나 때늦게 찾아온 필자의 귀찮음 이슈와, 글을 여기까지 읽은 독자라면 이후 내용은 어렵지 않게 유추 가능하리라는 생각으로 이만 줄인다.</p>

  </div>
  <div style="border-bottom: 1px solid var(--lighter-slate); margin-bottom: 4em;"></div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2025/01/25/los/">
        워시의 정리
      </a>
    </h1>

    <span class="post-date">25 Jan 2025</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/수학/'" >수학</div>
      
      <div class="tag" onclick="location.href='/tags/수리논리학/'" >수리논리학</div>
      
    </div>
  
    <p><a href="https://dimenerno.github.io/2025/01/22/hypernaturals/">이전 글</a>에서 이어지는 내용이다.</p>

<h2 id="5-초자연수의-비표준적-특징">5. 초자연수의 비표준적 특징</h2>

<p>지금까지 우리가 살펴본 초자연수는 $[0], [1], [2], \dots$와 같이 표준 자연수와 상응하는 것들이었다. 이제 표준 자연수와는 괴리가 있는 초자연수들을 살펴 보자.</p>

<p>다음의 초자연수 $\mathfrak{n}$을 보자.</p>

\[(1, 2, 3, 4, \dots) \in \mathfrak{n}\]

<p>초자연수의 정의가 동치류이기 때문에 등호가 아닌 포함 관계로 표현함에 유의하라. 초자연수에서 부등호의 정의를 상기하면, 자연수 $n$에 대해 $[n] &lt; \mathfrak{n}$임을 알 수 있다. 즉, $\mathfrak{n}$은 모든 자연수보다 큰 초자연수이다. 따라서 초자연수에서는 다음이 성립한다.</p>

\[\phi_1 : \exists x \; ( \lbrace y : y &lt; x \rbrace \text{ is infinite } )\]

<p>위 명제는 자연수에서는 성립하지 않는다.</p>

<p>이번에는 다음의 초자연수 $\mathfrak{m}$을 보자.</p>

\[(1, 2!, 3!, 4!, \dots) \in \mathfrak{m}\]

<p>표준 자연수 $n$에 대해 $\mathfrak{m}$은 $[n]$으로 나누어떨어진다. 즉, $\mathfrak{m}$은 모든 자연수를 약수로 가진다. 따라서 초자연수에서는 다음이 성립한다.</p>

\[\phi_2 : \exists x \; (\lbrace y : y \mid x \rbrace \text{ is infinite })\]

<p>위 명제 또한 자연수에서는 성립하지 않는다.</p>

<p>그런데 이상한 점이 있다. 저번 글의 서론에서 필자는 자연수와 초자연수가 논리적으로 구분 불가능하다고 했다. 그러나 $\phi_1$과 $\phi_2$는 $\mathbb{N}^*$에서는 참이지만 $\mathbb{N}$에서는 거짓이므로, 둘은 논리적으로 구분 가능한 것으로 보인다. 필자가 거짓말을 한 것일까?</p>

<p>그렇지 않다. 이 표면적인 역설을 해결하는 실마리는, $\phi_1$과 $\phi_2$가 1차 논리로 표현 <em>불가능한</em> 문장이라는 사실이다. 콤팩트성 정리에 의해 “…가 유한하다”는 1차 논리로 표현 불가능하기 때문이다.</p>

<p>$\mathbb{N}^*$과 $\mathbb{N}$이 논리적으로 구분 불가능하다는 말의 엄밀한 의미는 다음과 같다.</p>

<blockquote>
  <p><strong>정의.</strong> 언어 $\mathcal{L}$의 모형 $\mathcal{M}_1$과 $\mathcal{M}_2$가 <strong>기초적으로 동등(elementarily equivalent)</strong>하다는 것은 임의의 (1차 논리) 문장 $\phi$에 대해
\(\mathcal{M_1} \vDash \phi \iff \mathcal{M}_2 \vDash \phi\)
가 성립하는 것이다.</p>
</blockquote>

<blockquote>
  <p><strong>정리.</strong> $\mathbb{N}$과 $\mathbb{N}^*$은 기초적으로 동등하다.</p>
</blockquote>

<p>위 정리는 워시의 정리의 특수한 결과이다. 워시의 정리를 소개하기 앞서, 일반화된 초곱의 개념을 먼저 살펴보자.</p>

<h2 id="6-초곱">6. 초곱</h2>

<p>집합 $I$와, $I$ 위의 자유 초필터 $\mathcal{U}$가 주어졌다고 하자. 또한, 언어 $\mathcal{L}$의 모형 $\lbrace \mathcal{M}_i \rbrace_{i \in I}$가 주어졌다고 하자. 이때, <strong>초곱(ultraproduct)</strong> $\mathcal{M}^* = \prod \mathcal{M}_i / \mathcal{U}$를 다음과 같이 정의한다.</p>

<blockquote>
  <h4 id="초곱의-원소">초곱의 원소</h4>

  <p>$\mathcal{M}^*$의 원소는 $\lbrace (a_i)_{i\in I} : a_i \in \mathcal{M}_i \rbrace$가 $\sim$에 대해 이루는 동치류이다. 여기서 $\sim$은 다음과 같이 정의된다.</p>

\[(a_i)_{i\in I} \sim (b_i)_{i \in I} \iff \lbrace i \in I : a_i = b_i \rbrace \in \mathcal{U}\]

  <h4 id="초곱-위의-연산">초곱 위의 연산</h4>

  <p>$f(x)$가 $\mathcal{L}$의 함수라고 하자. $\mathcal{M}^*$의 원소 $\mathfrak{a} = [(a_i)_{i\in I}]$에 대해 다음과 같이 정의한다.</p>

\[f(\mathfrak{a}) = [(f(a_i))_{i \in I}]\]

  <p>위 정의는 자연스러운 방식으로 $n$항 함수로 일반화된다.</p>

  <h4 id="초곱-위의-술어">초곱 위의 술어</h4>

  <p>$P(x, y)$가 $\mathcal{L}$의 술어라고 하자. $\mathcal{M}^*$의 두 원소 $\mathfrak{a} = [(a_i)_{i\in I}]$와 $\mathfrak{b} = [(b_i)_{i\in I}]$에 대해 다음과 같이 정의한다.</p>

\[\mathcal{M}^* \vDash P(\mathfrak{a}, \mathfrak{b}) \iff \lbrace i \in I : \mathcal{M}_i \vDash P(a_i, b_i) \rbrace \in \mathcal{U}\]

  <p>위 정의는 자연스러운 방식으로 $n$항 술어로 일반화된다.</p>
</blockquote>

<p>초곱 위의 연산과 술어를 정의할 때, 연산과 술어의 결과가 동치류에서 어떤 원소를 대표자로 선택하든 상관없이 같음을 보여야 한다. 이것은 $\mathcal{U}$의 교집합 속성으로부터 어렵지 않게 얻어지므로 연습문제로 남긴다.</p>

<p>이로써 우리는 초자연수를, $I, \mathcal{U}, \mathcal{L}, \mathcal{M}_i$가 각각 다음과 같을 때 도출되는 초곱으로 재정의할 수 있다.</p>

<ul>
  <li>$I = \mathbb{N}$</li>
  <li>$\mathcal{U} =$ 프레셰 초필터</li>
  <li>$\mathcal{L} = (0, S, &lt;)$</li>
  <li>$\mathcal{M}_i = \mathbb{N}$</li>
</ul>

<p>비슷한 방식으로 <strong>초실수(hyperreals)</strong>를 정의할 수 있다.</p>

<ul>
  <li>$I = \mathbb{N}$</li>
  <li>$\mathcal{U} =$ 프레셰 초필터</li>
  <li>$\mathcal{L} = (0, 1, +, ⋅, &lt;)$</li>
  <li>$\mathcal{M}_i = \mathbb{R}$</li>
</ul>

<h2 id="7-워시의-정리">7. 워시의 정리</h2>

<blockquote>
  <p><strong>워시의 정리(Łoś’s Theorem).</strong> 초곱 $\mathcal{M}^* = \prod \mathcal{M}_i / \mathcal{U}$가 주어졌을 때, 임의의 $\mathcal{L}$-문장 $\phi$에 대해 다음이 성립한다.</p>

\[\mathcal{M}^* \vDash \phi \iff \lbrace i \in I : \mathcal{M}_i \vDash \phi \rbrace \in \mathcal{U}\]
</blockquote>

<p><em>Proof.</em> $\phi$에 대한 구조적 귀납법으로 증명한다.</p>

<h4 id="1-phi가-원자-명제이다">1. $\phi$가 원자 명제이다</h4>

<p>“초곱 위의 술어” 정의에 의해 자명하게 성립한다.</p>

<h4 id="2-phi--psi-land-theta">2. $\phi := \psi \land \theta$</h4>

\[\begin{aligned}
&amp;\mathcal{M}^* ⊨ φ\\
&amp;\iff \mathcal{M}^* ⊨ ψ \land \mathcal{M}^* ⊨ θ\\
&amp;\iff \lbrace i ∈ I \mid \mathcal{M}_i ⊨ ψ \rbrace ∈ \mathcal{U} \land \lbrace i ∈ I \mid \mathcal{M}_i ⊨ θ \rbrace ∈ \mathcal{U} &amp;&amp;(*)
\\
&amp;\iff \lbrace i ∈ I \mid \mathcal{M}_i ⊨ ψ \rbrace \cap \lbrace i ∈ I \mid \mathcal{M}_i ⊨ θ \rbrace ∈ \mathcal{U} &amp;&amp;(**) \\
&amp;\iff \lbrace i ∈ I \mid \mathcal{M}_i ⊨ ψ \land \mathcal{M}_i ⊨ θ \rbrace ∈ \mathcal{U}\\
&amp;\iff \lbrace i ∈ I \mid \mathcal{M}_i ⊨ ψ∧θ \rbrace ∈ \mathcal{U}\\
&amp;\iff \lbrace i ∈ I \mid \mathcal{M}_i ⊨ φ \rbrace ∈ \mathcal{U}
\end{aligned}\]

<p>$(*)$는 귀납 가정에 의해 성립하고, $(**)$는 $\mathcal{U}$의 교집합 닫힘 속성으로 성립한다.</p>

<h4 id="3-phi--lnot-psi">3. $\phi := \lnot \psi$</h4>

<p>2와 비슷한 방법으로 하면 된다. 단, 귀납 가정과 $\mathcal{U}$의 초필터 속성($A \in \mathcal{U} \lor A^c \in \mathcal{U}$)를 사용한다.</p>

<h4 id="4-phi--exists-x-psi">4. $\phi := \exists x\; \psi$</h4>

<p>2와 비슷한 방법으로 하면 된다. 단, 귀납 가정만 사용해도 충분하다.</p>

<p>모든 명제는 1, 2, 3, 4로 구성할 수 있으므로 귀납법에 의해 정리가 증명되었다. ■</p>

<blockquote>
  <p><strong>따름정리.</strong> $\mathbb{N}$과 $\mathbb{N}^*$은 기초적으로 동등하다.</p>
</blockquote>

<p><em>Proof.</em> 워시의 정리에 의해 $\mathbb{N}^* \vDash \phi$일 필요충분조건은 $\lbrace i \in \mathbb{N} : \mathbb{N}^\ast_i \vDash \phi \rbrace \in \mathcal{U}$인 것이다. 그런데 $\mathbb{N}^*_i = \mathbb{N}$이므로, 필요충분조건은 $\mathbb{N} \vDash \phi$로 환원된다. ■</p>

  </div>
  <div style="border-bottom: 1px solid var(--lighter-slate); margin-bottom: 4em;"></div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2025/01/22/hypernaturals/">
        프레셰 필터와 비표준 자연수
      </a>
    </h1>

    <span class="post-date">22 Jan 2025</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/수학/'" >수학</div>
      
      <div class="tag" onclick="location.href='/tags/수리논리학/'" >수리논리학</div>
      
    </div>
  
    <p>뢰벤하임-스콜렘 정리에 따르면 표준 산술 모형과 기초적으로 동등(elementarily equivalent)하지만 구조적으로 상이(nonisomorphic)한 모형이 존재한다. 달리 말해, 자연수가 만족하는 모든 1차 논리 명제를 만족하지만 자연수가 아닌 수 체계가 존재한다.</p>

<p>이 글(시리즈)에서는 <strong>초곱(ultraproduct)</strong>을 이용하여 대표적인 산술의 비표준적 모형인 <strong>초자연수(hypernaturals)</strong>를 구성하고, 이것이 표준 산술 모형과 기초적으로 동등함을 보증하는 <strong>워시의 정리(Łoś’s theorem)</strong>를 증명한다.</p>

<h2 id="1-개괄">1. 개괄</h2>

<p>콤팩트성 정리에 의해 우리는 1차 논리가 유한과 무한을 구별하지 못함을 안다. 따라서 무한을 적절히 사용함으로써 자연수와 1차 논리적으로 구분 불가능한 모델을 정의할 수 있으리라 기대해봄직하다.</p>

<p>이에 따라 다음과 같이 초자연수 $[0], [1], [2], \dots$를 정의하자.</p>

\[\begin{aligned}
[][0] &amp;= (0, 0, 0, 0, 0, \dots) \\
[1] &amp;= (1, 1, 1, 1, 1, \dots) \\
[2] &amp;= (2, 2, 2, 2, 2, \dots)
\end{aligned}\]

<p>그런데 생각해 보면 모든 항이 0으로 차 있어야 $[0]$으로 간주하는 것은 지나치게 엄격하다. 예를 들어 처음 두 개의 항만 1이고 나머지 항은 모두 0인 튜플 $(1, 1, 0, 0, 0, \dots)$ 또한 $[0]$으로 보는 것이 자연스럽다. 따라서 유한 개의 항을 제외한 모든 항이 $n$이라면 그 튜플 또한 $[n]$으로 간주하도록 하자. 즉,</p>

\[[n] = \lbrace (x_1, x_2, x_3, \dots) \in \mathbb{N}^\omega : \lbrace i \in \mathbb{N}: x_i \neq n \rbrace \text{ is finite} \rbrace\]

<p>하지만 이제 다음의 문제가 생긴다. 다음 튜플은 $[0]$으로 간주해야 하는가, $[1]$로 간주해야 하는가?</p>

\[(0, 1, 0, 1, 0, 1, \dots)\]

<p>이 모호함을 제거하기 위해 우리는 짝수 집합과 홀수 집합 중 하나를 임의로 채택할 것이다. 만약 짝수 집합을 채택했다면 위 튜플은 $[0]$이 되고(인덱스는 0부터 시작하는 것으로 전제한다) 홀수 집합을 채택했다면 $[1]$이 될 것이다.</p>

<p>하지만 이 채택의 과정에는 주의가 필요하다. 만약 6의 배수의 집합이 채택되었다면, 3의 배수의 집합 또한 채택되어야 논리적으로 일관된다. 후자를 만족하는 튜플은 자명하게 전자를 만족하기 때문이다. 그리고 3의 배수의 집합이 채택되었으므로, 3의 배수가 <em>아닌</em> 수의 집합은 기각되어야 한다. 자연수의 모든 부분집합에 대해 이같은 채택과 기각의 과정을 거친 결과물은 <strong>초필터(ultrafilter)</strong>라고 불리는 구조와 상응될 것이다. 적절한 초필터가 주어지면 그것을 토대로 임의의 튜플을 초자연수에 대응시킬 수 있으며, 이 전체적인 과정을 <strong>초곱(ultraproduct)</strong>이라고 부른다.</p>

<h2 id="2-초필터의-정의">2. 초필터의 정의</h2>

<blockquote>
  <p><strong>정의.</strong> $X$가 집합이라고 하자. $X$의 부분집합들로 이루어진 집합 $\mathcal{F}$가 다음을 만족할 때, $X$의 <strong>필터</strong>라고 부른다.</p>

  <ol>
    <li>$X \in \mathcal{F}$</li>
    <li>$\varnothing \not\in \mathcal{F}$</li>
    <li>상위집합 닫힘: $A \in \mathcal{F}, A \subset B \implies B \in \mathcal{F}$</li>
    <li>유한 교집합 닫힘: $A, B \in \mathcal{F} \implies A \cap B \in \mathcal{F}$</li>
  </ol>
</blockquote>

<p>직관적으로 필터는 “큰 집합들의 모임”이다. 이 관점에서 보면 1번과 2번 공리는 전체집합은 크고 공집합은 작다는 자명한 원리를 진술한다. 3번 공리는 큰 집합을 포함하는 집합은 크다는 원리를, 4번 공리는 큰 집합끼리 유한 번 교집합을 해도 여전히 크다는 원리를 진술한다.</p>

<p>여담으로 필터는 초곱뿐 아니라 퍼지 논리(fuzzy logic)의 모형을 고전 논리의 모형으로 변환하는 데도 쓰인다. 이때 필터는 “큰 집합들의 모임”이 아닌 “참인 문장들의 모임”이 된다. 그리고 퍼지 논리에서 고전 논리로의 변환은 코헨의 강제법을 이해하는 한 가지 방식이기도 하다.</p>

<p><strong>하세 다이어그램(Hasse diagram)</strong>을 통해 필터를 더 직관적으로 이해할 수 있다. 색칠된 영역은 $X = \lbrace 0, 1, 2 \rbrace$의 필터이다. 하세 다이어그램을 $\varnothing$에서 $X$로 가는 물줄기의 흐름으로 이해하면, 특정 지점에 잉크를 떨어뜨렸을 때 그 잉크가 퍼져 나가는 영역은 필터를 이룬다.</p>

<p><img src="https://velog.velcdn.com/images/dimenerno/post/86ac1e36-13fe-46fb-a9cc-b6749d1c5a69/image.png" width="400px" style="margin: 20px auto 30px auto;" /></p>

<p>2번 공리와 4번 공리에 의해, $A \in \mathcal{F}$라면 $A^c := X \setminus A \notin \mathcal{F}$이다. 이 사실을 강화하여, $X$의 <em>모든</em> 부분집합에 대해 그 집합 또는 여집합이 필터에 있을 것을 요구하면 <strong>초필터(ultrafilter)</strong>의 정의를 얻는다.</p>

<blockquote>
  <p><strong>정의.</strong> $X$의 필터 $\mathcal{F}$가 다음을 만족할 때 $\mathcal{F}$는 초필터이다.</p>

\[\forall A \in \mathcal{P}(X) : A \in \mathcal{F} \lor A^c \in \mathcal{F}\]
</blockquote>

<p>앞선 그림의 필터는 초필터이다. 초필터는 하세 다이어그램의 정확히 절반을 차지한다는 사실에 주목하라.</p>

<h2 id="3-무한집합에서의-초필터">3. 무한집합에서의 초필터</h2>

<p>최소(least) 원소를 가지는 필터를 주 필터(principal filter)라고 하며, 주 필터가 아닌 필터를 자유 필터(free filter)라고 한다. 지금까지 우리가 본 모든 필터는 주 필터로, “특정 지점에 떨어뜨린 잉크가 퍼져 나가는 영역”의 이미지와 완전히 부합한다.</p>

<p>주 필터와 달리 자유 필터는 직관적으로 포착하기 힘들다. 다음의 정리 때문이다.</p>

<blockquote>
  <p><strong>정리.</strong> 유한집합 위의 필터는 모두 주 필터이다.</p>
</blockquote>

<p><em>Proof.</em> $A_0 \in \mathcal{F}$가 최소 원소가 아니라고 하자. 그러면 어떤 $B \in \mathcal{F}$가 존재하여 $A_1 = A_0 \cap B \subsetneq A$이다. 즉, $|A_1| &lt; |A_0 |$이다. $A_1$이 최소 원소라면 증명이 끝나고, 아니라면 똑같은 과정을 반복한다. 주어진 집합의 크기가 유한하므로 이 과정은 계속 반복될 수 없으며, 최소 원소에 종착하게 된다. ■</p>

<p>위 정리는 이렇게 이해할 수도 있다. 자유 필터는 그 내부에 무한히 이어지지만 (따라서 유한 교집합만으로 최소 원소에 도달할 수 없다) 공집합에 도달하지는 않는 부분집합의 체인을 가지는 필터이다. 이에 따라 무한집합 위의 필터만이 자유 필터가 될 수 있다.</p>

<p><img src="https://velog.velcdn.com/images/dimenerno/post/3769cca8-52df-4faa-af87-4225e588e89d/image.png" alt="" /></p>

<p>그 실례를 살펴보자.</p>

<blockquote>
  <p><strong>정의.</strong> $X$가 무한집합이라고 하자. $A \subset X$가 <strong>여유한(cofinite)</strong>하다는 것은 $X \setminus A$가 유한집합인 것이다.</p>
</blockquote>

<blockquote>
  <p><strong>정리.</strong> $\mathbb{N}$의 모든 여유한 부분집합의 모임을 $\mathcal{F}$라고 하자. $\mathcal{F}$는 자유 필터이다.</p>
</blockquote>

<p>증명은 연습문제로 남긴다. 위 정리의 $\mathcal{F}$를 <strong>프레셰 필터(Fréchet filter)</strong>라고 부른다. 일례로 10보다 큰 수들의 집합 $\lbrace 11, 12, 13, 14, \dots \rbrace$은 $\mathcal{F}$의 원소이지만, 짝수의 집합은 $\mathcal{F}$의 원소가 아니다.</p>

<p>프레셰 필터는 초필터가 아니다. 하지만 다음 정리에 의해 초필터로 확장할 수 있다.</p>

<blockquote>
  <p><strong>정리.</strong> 모든 필터는 초필터로 확장될 수 있다.</p>
</blockquote>

<p><em>Proof.</em> $X$의 모든 필터들의 모임 $\Omega$에 포함 관계로 정의되는 순서를 주자. 이 순서 하에서 체인을 이루는 필터들의 합집합은 필터임을 어렵지 않게 보일 수 있다. 따라서 초른의 보조정리에 의해 $\Omega$는 극대(maximal) 원소 $\mathcal{U}$를 가진다. 만약 $\mathcal{U}$가 초필터가 아니라면, 어떤 $A_0 \subset X$가 존재하여 $A_0, A_0^c \notin U$이다. 이제 다음과 같이 $\mathcal{V}$를 정의한다.</p>

\[\mathcal{V} = \mathcal{U} \cup \lbrace A \subset X : A_0 \subset A \rbrace \cup \lbrace A_0 \cap U : U \in \mathcal{U} \rbrace\]

<p>$\mathcal{V}$는 필터임을 확인할 수 있다. 이것은 $\mathcal{U}$의 극대성에 위배된다. 따라서 $\mathcal{U}$는 초필터이다. ■</p>

<p>따라서 자연수 집합은 프레셰 필터로부터 확장되는 자유 초필터를 가진다. 이 필터를 <strong>프레셰 초필터</strong>라고 부르자.</p>

<p><img src="https://velog.velcdn.com/images/dimenerno/post/30387200-2e80-4a74-82a2-b696ffe7e1cd/image.png" alt="" /></p>

<h2 id="4-초자연수">4. 초자연수</h2>

<p>지금까지의 논의를 정리하자면, 프레셰 초필터를 비롯한 자유 초필터는 다음의 성질을 가진다.</p>

<ol>
  <li>모든 여유한 집합을 원소로 가진다.</li>
  <li>유한집합은 원소로 가지지 않는다.</li>
  <li>$A \subset \mathbb{N}$일 때 $A$가 필터의 원소이거나 $A^c$가 필터의 원소이다.</li>
</ol>

<p>위 세 성질 덕분에 프레셰 초필터는 서론에서 초곱의 기초적인 아이디어를 개괄했을 때 맞닥뜨렸던 모호성의 문제를 해결하는 데 안성맞춤이다. 이제 우리는 다음과 같이 초자연수를 정의할 수 있다.</p>

<p>$\mathcal{U}$가 자유 초필터라고 하자. $\mathbb{N}^\omega$ 위에 다음의 동치 관계를 정의한다.</p>

\[(n_0, n_1, n_2, \dots) \sim (m_0, m_1, m_2, \dots) \iff \lbrace i \in \mathbb{N} : n_i = m_i \rbrace \in \mathcal{U}\]

<p>이것이 동치 관계임은 어렵지 않게 확인할 수 있다. 따라서 다음과 같이 동치류를 취할 수 있다.</p>

\[\mathbb{N}^* := \mathbb{N}^\omega/\sim\]

<p>$\mathbb{N}^*$을 <strong>초자연수(hypernaturals)</strong>라고 한다. 초자연수의 정의가 동치류인 것은 서론에서 초자연수를 $[n]$으로 적은 이유이다. 이제 남은 것은 초자연수의 연산과 술어 관계를 정의하는 것이다.</p>

<p>초자연수의 덧셈은 다음과 같이 자연스럽게 정의한다.</p>

\[(n_0, n_1, \dots) + (m_0, m_1, \dots) = (n_0 + m_0, n_1 + m_1, \dots)\]

<p>여기에는 한 가지 미묘한 문제가 있다. 초자연수의 정의가 동치류이기 때문에, 동치류의 어떤 원소를 택하더라도 위 덧셈의 결과에 영향을 주지 않음을 보여야 한다. 즉,</p>

\[\begin{gather}
(n_0, n_1, \dots), (n_0', n_1',  \dots) \in [n]\\
(m_0, m_1,  \dots), (m_0', m_1', \dots) \in [m]
\end{gather}\]

<p>에 대해,</p>

\[(n_0, n_1, \dots) + (m_0, m_1,  \dots), (n_0', n_1', \dots) + (m_0', m_1', \dots) \in [n + m]\]

<p>임을 보여야 한다. 다행히 이는 어렵지 않다.</p>

<p>곱셈과 역원 또한 비슷하게 정의하면 된다. 한편 $&lt;$와 같은 이항 관계는 다음과 같이 정의한다.</p>

\[(n_0, n_1, n_2, \dots) &lt; (m_0, m_1, m_2, \dots) \iff \lbrace i \in \mathbb{N} : n_i &lt; m_i \rbrace \in \mathcal{U}\]

<p>이 정의는 자연스럽게 삼항, 사항 관계로 일반화할 수 있다.</p>

<p>이로써 우리는 초자연수를 정의했다. 다음 글에서는 초자연수의 여러 비표준적인 특징과, 그런 비표준성에도 불구하고 초자연수와 자연수를 1차 논리로 구분할 수 없음을 보이는 워시의 정리를 살펴볼 것이다.</p>

  </div>
  <div style="border-bottom: 1px solid var(--lighter-slate); margin-bottom: 4em;"></div>
  
</div>

<div class="pagination">
  
    <a class="pagination-item older" href="/page4">이전 글</a>
  
  
    
      <a class="pagination-item newer" href="/page2">다음 글</a>
    
  
</div>

      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script src='/public/js/script.js'></script>
  </body>
</html>
