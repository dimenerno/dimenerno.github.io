<!DOCTYPE html>
<html lang="en-us">
  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile" />
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />

  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=1"
  />

  <title>
     디멘의 블로그 &middot; 이데아를 여행하는 히치하이커
    
  </title>

  <script>
    MathJax = {
      tex: {
        inlineMath: [
          ["$", "$"],
          ["\\(", "\\)"],
        ],
      },
      svg: {
        fontCache: "global",
      },
    };
  </script>
  <script
    type="text/javascript"
    id="MathJax-script"
    async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
  ></script>

  
  <link rel="canonical" href="/page9/" />
  

  <link rel="stylesheet" href="/public/css/poole.css" />
  <link rel="stylesheet" href="/public/css/syntax.css" />
  <link rel="stylesheet" href="/public/css/lanyon.css" />
  <link
    rel="stylesheet"
    href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400"
  />

  <!-- <link rel="apple-touch-icon-precomposed" sizes="144x144" href="">
  <link rel="shortcut icon" href="">
   -->
  <link
    rel="apple-touch-icon-precomposed"
    sizes="144x144"
    href="/public/apple-touch-icon.png"
  />
  <link rel="shortcut icon" href="/public/favicon.ico" />
  <!-- <link rel="alternate" type="application/rss+xml" title="RSS" href="http://localhost:4000/atom.xml"> -->
  <link
    rel="alternate"
    type="application/rss+xml"
    title="RSS"
    href=""
  />

  <script
    async
    src="https://www.googletagmanager.com/gtag/js?id=G-PVGYLWF7GR"
  ></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
      dataLayer.push(arguments);
    }
    gtag("js", new Date());

    gtag("config", "G-PVGYLWF7GR");
  </script>
</head>


  <body>
    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox" />

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p>이데아를 여행하는 히치하이커</p>
  </div>

  <nav class="sidebar-nav">
    <a
      class="sidebar-nav-item"
      href="/"
      >메인</a
    >

                
    <a
      class="sidebar-nav-item"
      href="/about/"
      >저에 대하여</a
    >
        
    <a
      class="sidebar-nav-item"
      href="/archive-date/"
      >날짜별로 보기</a
    >
        
    <a
      class="sidebar-nav-item"
      href="/archive-tag/"
      >주제별로 보기</a
    >
          
    <a
      class="sidebar-nav-item"
      href="/book/"
      >새벽의 자연학 수업</a
    >
        
    <a
      class="sidebar-nav-item"
      href="/guestbook/"
      >방명록</a
    >
                                                                                                              
  </nav>

  <div class="sidebar-item">
    <p>&copy; 2025. All rights reserved.</p>
    <p style="color: #202020">
      &copy; 2025. 디멘 reserved by 곰댕.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/" title="Home">디멘의 블로그</a>
            <small>이데아를 여행하는 히치하이커</small>
          </h3>
        </div>
      </div>

      <div class="container content"><head>
  <style>
    .fade-rise-1 {
      opacity: 0;
      transform: translateY(20px);
      /* animation: fadeRise 0.8s ease-out forwards;
      animation-delay: 0.2s; */
    }

    .fade-rise-2 {
      opacity: 0;
      transform: translateY(20px);
      /* animation: fadeRise 0.8s ease-out forwards;
      animation-delay: 0.4s; */
    }

    .fade-rise-3 {
      opacity: 0;
      transform: translateY(20px);
      /* animation: fadeRise 0.8s ease-out forwards;
      animation-delay: 0.6s; */
    }

        /* 이미지가 로드된 후 추가될 클래스에 animation 속성 추가 */
    .fade-rise-1.is-loaded {
      animation: fadeRise 0.8s ease-out forwards 0.2s;
    }
    .fade-rise-2.is-loaded {
      animation: fadeRise 0.8s ease-out forwards 0.4s;
    }
    .fade-rise-3.is-loaded {
      animation: fadeRise 0.8s ease-out forwards 0.6s;
    }

    @keyframes fadeRise {
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .fade-in-section {
      opacity: 0;
      transform: translateY(10px);
      transition: opacity 0.5s ease-out, transform 0.5s ease-out;
    }

    .fade-in-section.is-visible {
      opacity: 1;
      transform: none;
    }

    .spacer {
      height: 100vh;
    }
  </style>
</head>



<div class="posts">
  
  <div class="post fade-in-section">
    <h1 class="post-title">
      <a href="/2024/11/20/Rational-Real/"> 유리수와 실수의 집합론적 정의 </a>
    </h1>

    <span class="post-date">20 Nov 2024</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/수학/'">
        수학
      </div>
      
      <div class="tag" onclick="location.href='/tags/집합론/'">
        집합론
      </div>
      
    </div>
     <h3 id="1-칸토어의-동형성-정리">1. 칸토어의 동형성 정리</h3>

<blockquote>
  <p><strong>칸토어의 동형성 정리.</strong> 가산이고 양끝점이 없으며 조밀한 전순서 집합은 순서 동형에 대해 유일하다.</p>
</blockquote>

<p><strong>증명 1. (Back-and-Forth Argument)</strong>
<img src="https://velog.velcdn.com/images/dimenerno/post/888ce5aa-5181-425a-98ca-91db8396e86a/image.png" alt="" /></p>

<p>$n$번째 단계에서 $\mathrm{argmin}_k a_k \in A \setminus \mathrm{dom} f_n$을 순서 동형성을 만족하게끔 $b \in B  \setminus \mathrm{im} f_n$과 대응시키고, $\mathrm{argmin}_{l}b_l \in B \setminus (\mathrm{im} f_n \cup \lbrace  b \rbrace)$
을 순서 동형성을 만족하게끔 임의의 
$a \in A \setminus (\mathrm{dom}f_n \cup \lbrace a_k\rbrace)$
와 대응시킨다.</p>

<p><strong>증명 2. (Only-Forth Argument)</strong>
<img src="https://velog.velcdn.com/images/dimenerno/post/1ecaf995-ba92-4708-8d0b-fb81f7c2aad1/image.png" alt="" /></p>

<p>$n$ 번째 단계에서 $\mathrm{argmin}_k a_k \in A \setminus \mathrm{dom} f_n$을 순서 동형성을 만족하게끔 $b \in B \setminus  \mathrm{im}f_n$ 중에서 <em>가장 인덱스가 작은</em> $b_l$과 대응시킨다.</p>

<p><strong>잘못된 증명. (Incorrect Only-Forth Argument)</strong></p>

<p>$n$번째 단계에서 $\mathrm{argmin}_k a_k \in A \setminus \mathrm{dom} f_n$을 순서 동형성을 만족하게끔 <em>임의의</em> $b \in B \setminus  \mathrm{im}f_n$와 대응시킨다.</p>

<p><strong>잘못된 이유:</strong> $\mathrm{im} \left[ \bigcup f_n \right]$이 $B$ 전체를 소진한다는 보장이 없다. 일례로 모든 경우 선택된 $b$의 인덱스가 짝수인 경우가 가능하다.</p>

<h3 id="2-데데킨트-절단">2. 데데킨트 절단</h3>

<blockquote>
  <p><strong>정의.</strong> 전순서 집합 $(P, &lt;)$에 대하여 $P$의 부분집합 $A, B$가 다음을 만족할 때 $(A, B)$를 <strong>절단</strong>이라고 한다.</p>

  <ol>
    <li>$A \sqcup B = P$</li>
    <li>임의의 $a \in A, b \in B$에 대해 $a &lt; b$이다.</li>
  </ol>

  <p>추가로 다음을 만족할 때 <strong>데데킨트 절단</strong>이라고 한다.</p>

  <ol>
    <li>$A$는 최대 원소를 가지지 않는다.</li>
  </ol>

  <p>추가로 다음까지 만족할 때 <strong>틈</strong>이라고 한다.</p>

  <ol>
    <li>$B$는 최소 원소를 가지지 않는다.</li>
  </ol>
</blockquote>

<p><strong>Remark 1.</strong> $P$가 완비이다 ⇔ $P$는 틈을 가지지 않는다.
<strong>Remark 2.</strong> $P = \mathbb{Q}$일 때 틈은 무리수 집합을, 데데킨트 절단은 실수 집합을 나타낸다.</p>

<p><img src="https://velog.velcdn.com/images/dimenerno/post/9620e89e-2363-4d11-865a-7ecb11ea26d9/image.png" alt="" /></p>

<h3 id="3-완비화-정리">3. 완비화 정리</h3>

<blockquote>
  <p><strong>완비화 정리.</strong> $(P, &lt;)$가 양끝점이 없는 조밀한 전순서라면 다음을 만족하는 완비 전순서 $(C, \prec)$가 순서 동형에 대해 유일하게 존재한다.</p>

  <ol>
    <li>$P \subseteq C$</li>
    <li>$\prec$는 $P$에서 $&lt;$와 일치한다.</li>
    <li>$P$는 $C$에서 조밀하다. 즉, $c_1 &lt; c_2 \in C$에 대해 $c_1 &lt; p &lt; c_2$를 만족하는 $p \in P$가 언제나 존재한다.</li>
    <li>$C$는 양끝점이 없다.</li>
  </ol>
</blockquote>

<p><strong>유일성 증명.</strong>
$(C, \prec)$와 $(C^\ast, \prec^\ast)$가 조건을 만족하는 완비 전순서라고 하자. 다음과 같이 정의된 $\phi: C → C^\ast$는 순서 동형 사상이다.</p>

<ol>
  <li>$c \in P$라면 $\phi(c)=c$</li>
  <li>$c \notin P$라면 $\phi(c) = \sup^\ast  \lbrace  p \in P : p \prec c \rbrace$</li>
</ol>

<p><strong>존재성 증명.</strong>
다음과 같이 정의한다.</p>

\[\begin{gather}
\mathcal{G} = \lbrace  (A, B) : (A, B) \text{ is a gap of } P \rbrace \\
\mathcal{D} = \lbrace  (A, B) : (A, B) \text{ is a Dedekind cut of } P \rbrace \\
\mathcal{P} = \mathcal{D} \setminus \mathcal{G}
\end{gather}\]

<p>라고 하자. 다음과 같이 $\mathcal{D}$에 순서를 준다.</p>

\[(A_1, B_1) \prec (A_2, B_2) \iff A_1 \subset A_2\]

<p>$(A, B) \in \mathcal{P}$라면 어떤 $p$에 대해 $B = \lbrace  x \in P : x \geq p  \rbrace$이며, 이때 $(A, B) = [p]$라고 적자. 즉,</p>

\[\mathcal{P} = \lbrace  [p] : p \in P \rbrace\]

<p>$(\mathcal{P}, \prec) \sim (P, &lt;)$임을 쉽게 확인할 수 있다. 이제 다음을 보인다.</p>

<p><em>Claim.</em> $\mathcal{D}$는 $\mathcal{P}$에 대해 완비화 정리의 4가지 조건을 모두 만족하는 확장이다.</p>

<p>1, 2, 4는 자명하다. 3을 보인다.</p>

<p>$\mathfrak{d}_1 = (A_1, B_1), \mathfrak{d}_2 = (A_2, B_2) \in \mathcal{D}$에 대해 $\mathfrak{d_1} \prec \mathfrak{d}_2$, 즉 $A_1 \subset A_2$라고 하자. $p \in A_2 \setminus A_1$이며 $p$가 $B$의 최소 원소가 아닌 $p \in P$가 존재한다. 그러한 $p$에 대해 $\mathfrak{d}_1 \prec [p] \prec \mathfrak{d}_2$이다. □</p>

<p>마지막으로 다음을 보인다.</p>

<p><em>Claim.</em> $(\mathcal{D}, \prec)$는 완비이다.</p>

<p>$\mathcal{S}$가 위로 유계인 $\mathcal{D}$의 공집합이 아닌 부분집합이라고 하자. 다음과 같이 정의한다.</p>

\[\begin{gather}
A_\mathcal{S} = \bigcup \lbrace  A : (A, B) \in \mathcal{S} \rbrace\\
B_\mathcal{S} = \bigcap \lbrace  B : (A, B) \in \mathcal{S} \rbrace
\end{gather}\]

<p>$(A_\mathcal{S}, B_\mathcal{S}) \in \mathcal{D}$이며, $\mathcal{S}$의 최소 상계임을 확인할 수 있다. ◾</p>

<blockquote>
  <p><strong>집합론적 실수의 정의.</strong> 다음을 만족하는 집합 $(R, &lt;)$은 순서 동형에 대해 유일하다.</p>

  <ol>
    <li>완비 전순서 집합이다.</li>
    <li>양끝점이 없다.</li>
    <li>분리 가능하다(separable). 즉, $Q \subset R$이 존재하여 $Q$는 가산집합이고 $R$에서 조밀하다.</li>
  </ol>
</blockquote>

<p><strong>증명.</strong> 칸토어의 동형성 정리와 완비화 정리로부터 따라 나온다.</p>

  </div>
  <!-- <div
    style="border-bottom: 1px solid var(--lighter-slate); margin-bottom: 4em"
  ></div> -->
  <div style="margin-bottom: 6em"></div>
  
  <div class="post fade-in-section">
    <h1 class="post-title">
      <a href="/2024/11/19/CSB/"> 칸토어-슈뢰더-베른슈타인 정리 </a>
    </h1>

    <span class="post-date">19 Nov 2024</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/수학/'">
        수학
      </div>
      
      <div class="tag" onclick="location.href='/tags/집합론/'">
        집합론
      </div>
      
    </div>
     <blockquote>
  <p><strong>정리.</strong> 두 집합 $A, B$에 대해 $|A| \leq |B|$, $|A| \geq |B|$라면 $|A| = |B|$이다.</p>
</blockquote>

<p>매우 당연해 보이지만 $\leq$가 단사함수의 존재성으로, $=$가 전단사함수의 존재성으로 정의된다는 점에서 트리키한 함수 핸들링을 요구한다.</p>

<p>여담으로 “칸토어-베른슈타인 정리(위키피디아)” 또는 “슈뢰더-베른슈타인 정리(나무위키)”라고도 부르는데 “칸토어-슈뢰더 정리”라고 부르는 경우는 못 봤다. 홍대병에 취해 있다면 “칸토어-슈뢰더 정리”라고 불러보자.</p>

<h3 id="첫-번째-증명">첫 번째 증명</h3>

<p><img src="https://velog.velcdn.com/images/dimenerno/post/3e3b706b-77bc-4de3-a9ea-76fa4ffd8dbe/image.png" alt="" /></p>

<p>실선이 $f: A → B$, 점선이 $g: B → A$이다. 조건에 의해 $f, g$는 단사이다. $C := \mathrm{Im} f$가 $B$와 같다면 증명이 끝나므로, $C \subsetneq B$라고 하자.</p>

<p>임의의 $y \in B \setminus C$에 대해,</p>

<ul>
  <li>$x_1^y = g^{-1}(y)$</li>
  <li>
    <p>$x_{n+1}^y = g(f(x_n))$</p>
  </li>
  <li>$h_y(x_1^y) = y$</li>
  <li>$h_y(x_{n+1}^y) = f(x_n)$</li>
</ul>

<p>로 정의한다(보라색). 다음이 성립함을 확인하라.</p>

\[x^y_n = x^z_m \iff y = z, n = m\]

<p>따라서 다음의 함수 $h: X → Y$는 well-defined이다.</p>

\[h(x) = \begin{cases}
h_y(x) &amp;x = x^y_n \text{ for some } y, n \\\\
f(x) &amp;\text{otherwise}
\end{cases}\]

<p>$h$가 전단사임을 확인하라. ◾</p>

<h3 id="두-번째-증명">두 번째 증명</h3>

<blockquote>
  <p><strong>보조정리.</strong> $A_1 \subset B \subset A$에 대해 $|A_1| \leq |B| \leq |A|$이고 $|A_1| = |A|$라면 $|A_1| = |B| = |A|$이다.</p>
</blockquote>

<p><strong>증명.</strong> $f: A → A_1$가 전사라고 하자. 다음과 같이 $\lbrace A_n\rbrace , \lbrace B_n\rbrace , \lbrace C_n\rbrace $을 정의한다.</p>

\[\begin{gather}
A_0 = A, \; A_{n+1} = f[A_n] \\
B_0 = B, \; B_{n+1} = f[B_n] \\
C_n = A_n \setminus B_n
\end{gather}\]

<p>$C = \bigcup C_n, D = A \setminus C$라고 하자. $f[C] \subset C, f[D] \subset D$임을 확인하라. 따라서 다음의 $g: A → B$는 전사이다.</p>

\[g(x) = \begin{cases}
f(x) &amp; x \in C\\
x &amp; x \in D
\end{cases}\]

<p><strong>본 정리의 증명.</strong> $f: A → B, g: B → A$가 전사일 때 $|gf[A]| \leq |g[B]| \leq |A|$이므로 보조정리에 의해 $|g[B]| = |B| = |A|$이다. ◾</p>

<p>잘 생각해 보면 두 증명은 사실 같다.</p>


  </div>
  <!-- <div
    style="border-bottom: 1px solid var(--lighter-slate); margin-bottom: 4em"
  ></div> -->
  <div style="margin-bottom: 6em"></div>
  
  <div class="post fade-in-section">
    <h1 class="post-title">
      <a href="/2024/11/18/ZFC/"> ZFC 공리의 목록 </a>
    </h1>

    <span class="post-date">18 Nov 2024</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/수학/'">
        수학
      </div>
      
      <div class="tag" onclick="location.href='/tags/집합론/'">
        집합론
      </div>
      
    </div>
     <table>
  <thead>
    <tr>
      <th>공리명</th>
      <th>의미</th>
      <th>논리식(자유변수는 $\forall$로 양화)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>외연 공리</td>
      <td>집합은 원소의 모임이다.</td>
      <td>$X = Y \leftrightarrow (z \in X \leftrightarrow z \in Y)$</td>
    </tr>
    <tr>
      <td>공집합 공리*</td>
      <td>공집합이 존재한다.</td>
      <td>$\exists Z : z \not\in Z$</td>
    </tr>
    <tr>
      <td>짝 공리*</td>
      <td>$X, Y$로부터 $Z = \lbrace  X, Y \rbrace$를 정의할 수 있다.</td>
      <td>$\exists Z : z \in Z \leftrightarrow (z = X \lor z = Y)$</td>
    </tr>
    <tr>
      <td>합집합 공리</td>
      <td>$X = \lbrace  Y_i \rbrace$로부터 $Z = \bigcup Y_i$를 정의할 수 있다.</td>
      <td>$\exists Z : z \in Z \leftrightarrow \exists x \in X (z \in x)$</td>
    </tr>
    <tr>
      <td>멱집합 공리</td>
      <td>$X$로부터 $\mathcal{P}(X)$를 정의할 수 있다.</td>
      <td>$\exists Z : z \in Z \leftrightarrow (w \in z \rightarrow w \in X)$</td>
    </tr>
    <tr>
      <td>분류 공리꼴**</td>
      <td>$X$로부터 $Y = \lbrace  y \in X : \phi(y) \rbrace$를 정의할 수 있다. ($\phi$는 1차 논리식)</td>
      <td>$\exists Z : z \in Z \leftrightarrow (z \in X \land \phi(z))$</td>
    </tr>
    <tr>
      <td>무한 공리</td>
      <td>모든 자연수를 포함하는 집합이 존재한다.</td>
      <td>$\exists Z : \varnothing \in Z \land (z \in Z \rightarrow z \cup \lbrace  z \rbrace \in Z)$</td>
    </tr>
    <tr>
      <td>정칙 공리</td>
      <td>$\in$은 정렬 순서이다.</td>
      <td>$\exists x \in X : \forall y \in X [ y \not\in x]$</td>
    </tr>
    <tr>
      <td>치환 공리꼴</td>
      <td>$X$로부터 $f[X]$를 정의할 수 있다. ($f$는 class function)</td>
      <td>$\displaylines{&amp;[\forall x \in X \; \exists! y :\phi(x, y)] \rightarrow \\ &amp;[\exists Y \; \forall x \in X \; \exists y \in Y : \phi(x, y)]}$</td>
    </tr>
    <tr>
      <td>선택 공리</td>
      <td>집합족 $\lbrace  X_i \rbrace$에 대해 각 $X_i$의 원소를 하나씩 선택할 수 있다.</td>
      <td>$\displaylines{&amp;\varnothing \notin X \rightarrow \\&amp;\exists f : X \rightarrow \bigcup X [ f(x) \in x ]}$</td>
    </tr>
  </tbody>
</table>

<p><strong>Remarks.</strong></p>
<ul>
  <li>정칙 공리는 다음과 동치</li>
</ul>

\[\exists x \in X : x \cap X = \varnothing\]

<ul>
  <li>
    <p>(*)로 표시된 공리는 분류 공리꼴로부터 유도할 수 있다.</p>
  </li>
  <li>
    <p>(**)로 표시된 공리는 치환 공리꼴로부터 유도할 수 있다.</p>
    <ul>
      <li>분류 공리꼴의 내용은 “X가 집합이다 → f[X]가 집합이다(f는 함수)”이라는 것이다. f가 함수임을(즉, f의 정의역이 집합임을) 선결적으로 요구함에 유의하라.</li>
    </ul>
  </li>
</ul>

<h3 id="공리의-필요성">공리의 필요성</h3>
<p><strong>정리.</strong> 다음의 정리들은 선택 공리를 필요로 한다.</p>

<ul>
  <li>
    <p>$f: X → Y$가 전사일 때, 어떤 $X$의 부분집합 $Z$에 대해 $f\vert_Z$는 전단사이다.</p>
  </li>
  <li>
    <p>$\varnothing \not\in \lbrace  X_i\rbrace$일 때  $\prod X_i \neq \varnothing$이다.</p>
  </li>
  <li>
    <p><strong>정렬 원리:</strong> 임의의 집합에 정렬 순서를 줄 수 있다.</p>
  </li>
  <li>
    <p><strong>초른의 보조정리:</strong> $(X, &lt;)$의 임의의 체인이 $X$에서 상계를 가진다면, $X$는 극댓값(maximal element)을 가진다.</p>
  </li>
</ul>

<p><strong>정리.</strong> 다음의 정리들은 치환 공리꼴을 필요로 한다.</p>

<ul>
  <li>
    <p>$\omega + \omega$가 존재한다.</p>
  </li>
  <li>
    <p><strong>서수 완전성 정리.</strong> 모든 정렬 순서는 서수와 순서 동형이다.</p>
  </li>
</ul>


  </div>
  <!-- <div
    style="border-bottom: 1px solid var(--lighter-slate); margin-bottom: 4em"
  ></div> -->
  <div style="margin-bottom: 6em"></div>
  
  <div class="post fade-in-section">
    <h1 class="post-title">
      <a href="/2024/11/17/bell-rocket/"> 벨의 우주선 사고실험: 수동적 로렌츠 수축과 능동적 로렌츠 수축 </a>
    </h1>

    <span class="post-date">17 Nov 2024</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/물리학/'">
        물리학
      </div>
      
      <div class="tag" onclick="location.href='/tags/상대론/'">
        상대론
      </div>
      
    </div>
     <blockquote>
  <p>우주선 A, B가 가느다란 실로 연결된 채 관성 상태에 있다가 동시에 같은 가속도로 광속에 가깝게 운동하기 시작한다. A와 B를 연결하는 실은 어떻게 되는가?</p>

  <ol>
    <li>끊어진다.</li>
    <li>느슨해진다.</li>
    <li>변화가 없다.</li>
  </ol>
</blockquote>

<p>이 문제는 드원과 베란이 1959년에 처음 고안했으나 1976년에 벨¹이 CERN의 물리학자들과 나눈 토론을 통해 유명해졌다. 벨은 로렌츠 수축을 근거로 실이 끊어진다고 주장했으나 CERN의 물리학자들 대다수는 실에 변화가 없다고 반박했으며, 한 저명한 물리학자는 벨이 상대론을 오도하고 있다고까지 말했다. 그렇다면 정답은 과연 무엇일까?</p>

<p>정답은 <strong>1. 끊어진다</strong> 이다.</p>

<p>이 답은 일면 비직관적이다. 로렌츠 수축은 관성계에 의존적인 현상이기 때문이다. 일례로 철수에 대해 영희가 광속에 가깝게 움직인다면 영희는 수축한다. 하지만 동 상황에서 영희의 관성계를 기준으로는 철수가 광속에 가깝게 움직이므로 철수가 수축한다. 이같은 대칭성은 로렌츠 수축이 실재하는 물리적 현상이 아닌 관성계의 선택에 따른 수학적 현상임을 시사한다. 이같은 로렌츠 수축의 해석은 Rindler 1977의 글에서 볼 수 있듯이 물리학계에서 널리 퍼져있다.</p>

<blockquote>
  <p>로렌츠에 따르면 수축의 원인은 원자 구조를 밀집시키는 전기적 응집력이 [물체가 에테르를 통과함에 따라] 증가하는 데 있다… [하지만] 상대론에서 로렌츠 수축은 본질적으로 기하학적 투영 효과로서, 정지해 있는 막대기를 비스듬한 시선으로 보는 것과 유사하다.</p>

  <p><span style="color: gray">In relativity the effect is essentially a geometric “projection” effect, quite analogous to looking at a stationary rod which is not parallel to the plane of the retina.²</span></p>
</blockquote>

<p>그러나 Rindler의 설명은 반만 맞고 반은 틀렸다. 그 이유는 로렌츠 수축에 두 가지 유형이 있기 때문이다. <strong>수동적 로렌츠 변환</strong>(passive Lorentz transformation)의 경우에는 Rindler의 주장대로 로렌츠 수축이 관성계의 선택에 따른 부수 현상에 불과하지만, <strong>능동적 로렌츠 변환</strong>(active Lorentz transformation)의 경우에는 로렌츠 수축이 전기력의 증가와 같은 실질적 물리 현상을 야기한다. 본 글에서는 두 변환의 차이가 무엇인지, 그리고 어떻게 능동적 로렌츠 변환은 전기력과 연관되는지 살펴볼 것이다.</p>

<p>본론에 들어가기 앞서 해당 글의 내용은 Maudlin의 ⟪Philosophy of Physics: Space and Time⟫을 참고하여 작성되었음을 밝힌다.</p>

<h3 id="1-수동적-변환">1. 수동적 변환</h3>

<p>점입자 A가 빈 공간에서 관성 운동한다. A에 대해 정지해 있는 관성좌표계 $(x, t)$를 기준으로 민코프스키 다이어그램을 그리면 해당 상황은 (가)와 같이 표현할 수 있다. 반면 $(x, t)$에 대해 $0.6c$의 속도를 가지는 관성좌표계 $(x’, t’)$을 기준으로 하는 민코프스키 다이어그램은 (나) 및 (나’)와 같다.³</p>

<p><img src="https://velog.velcdn.com/images/dimenerno/post/74968d4c-9823-43ad-ba78-889f40201c84/image.png" alt="" /></p>

<p>A의 운동에 좌표를 부여하는 방식은 다르지만 (가)와 (나)는 동일한 물리적 상황을 표현한다. 이와 같이 계의 물리적 속성을 보존하는 관성좌표계의 변환을 <strong>수동적 변환</strong>이라고 한다. 뉴턴 역학에서 시공간의 수동적 변환은 전단 변환<span style="font-size: 0.8em">shear transformation</span>으로 주어지지만 잘 알려져 있듯이 상대론에서는 로렌츠 변환으로 주어진다.</p>

<h3 id="2-능동적-변환">2. 능동적 변환</h3>

<p>이제 A의 속도에 순간적으로 $-0.6c$가 더해진 상황을 생각해 보자. $(x, t)$에 대해 속도가 더해진 후의 다이어그램은 (다)와 같다.</p>

<p><img src="https://velog.velcdn.com/images/dimenerno/post/272d16ad-4f3e-4013-90c9-cd8ca82b1030/image.png" alt="" /></p>

<p>주목할 점은, (가)-(나)와는 달리 (가)-(다)는 <em>같은</em> 관성좌표계를 사용한다는 것이다. (가)-(다)의 변환은 관성좌표계의 변환이 아닌, A의 속도에 $-0.6c$가 더해졌다는 물리적 변화로 일어났다. 이처럼 물리적 변화로 인한 다이어그램의 변환을 <strong>능동적 변환</strong>이라고 한다.</p>

<p>일면 능동적 변환(나)와 수동적 변환(다)의 차이는 관점의 차이에 지나지 않는 것으로 보인다. 실제로 고전역학에서 능동적 변환과 수동적 변환은 동일시될 수 있으며, 이것은 고전역학에서 뇌터 정리를 적용할 수 있는 조건에 다름 아니다. 하지만 상대론에서 둘의 동일시는 매우 신중한 주의를 요구한다. 왜냐하면 상대론에서는 <strong>동시성의 상대성</strong>을 고려해야 하기 때문이다.</p>

<h3 id="3-동시성의-상대성">3. 동시성의 상대성</h3>

<p>동시성의 상대성이 왜 중요한지 알아보기 위해 상황을 바꿔보자. 두 점입자 A, B가 빈 공간에서 서로 $c$의 거리를 유지하고 있다. 이 상황을 A에 대해 정지해 있는 관성좌표계 $(x, t)$와, A에 대해 $0.6c$로 움직이는 관성계 $(x’, t’)$으로 표현한 민코프스키 다이어그램은 각각 다음과 같다.</p>

<p><img src="https://velog.velcdn.com/images/dimenerno/post/9d7bd171-b743-4b0a-a2d5-5f9839604b53/image.png" alt="" /></p>

<p>$(x, t)$에서 $P$와 $Q$가 동시적이므로 A, B의 거리는 $d$이다. 반면 $(x’, t’)$에서는 $P$와 $Q’$가 동시적이므로 A, B 거리는 $d’$이다. 민코프스키 기하학을 이용하여 계산하면 $d’ = 0.8c$ 이며 $d’ &lt; d$이다.⁴</p>

<p>같은 현상을 능동적 변환으로 해석해 보자. A, B가 $c$의 거리를 유지하다가 $(x, t)$에 대해 동시에 $-0.6c$의 속도가 더해졌다고 하자. 민코프스키 다이어그램은 다음과 같다. $(x’’, t’’)$은 속도가 더해진 이후의 A를 기준으로 하는 관성좌표계이다.</p>

<p><img src="https://velog.velcdn.com/images/dimenerno/post/0061f8a1-e866-41cd-978f-ce7a3888df4d/image.png" alt="" /></p>

<p>$(x, t)$에서 $(P, Q)$가 동시적이므로 A, B의 거리는 $d$이다. 반면 $(x’’, t’’)$에서는 $(P, Q’’)$가 동시적이므로 A, B의 거리는 $d’‘$이다. 마찬가지로 민코프스키 기하학을 이용하여 $d’‘$을 계산하면 $d’’ = 1.25c$ 이며 $d’’ &gt; d$이다.</p>

<p>따라서 상대론에서는 수동적 변환과 능동적 변환 사이에 실질적인 차이가 있다. 수동적 변환은 A 관점의 거리를 유지시키고 새 관성좌표계 관점의 거리를 수축시키는 한편, 능동적 변환은 기존 관성좌표계 관점의 거리를 유지시키고 A 관점의 거리를 팽창시킨다.</p>

<table>
  <thead>
    <tr>
      <th>A와 B의 거리</th>
      <th>A 관점</th>
      <th>A에 대해 움직이는 관성계 관점</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>수동적 변환</td>
      <td>유지</td>
      <td>수축</td>
    </tr>
    <tr>
      <td>능동적 변환 (A와 B가 분리되어 있을 때)</td>
      <td>팽창</td>
      <td>유지</td>
    </tr>
  </tbody>
</table>

<h3 id="4-강체의-능동적-변환">4. 강체의 능동적 변환</h3>

<p>앞서 본 경우에는 A와 B가 분리되어 있었다. 이제 A와 B가 강체를 이루는 경우를 생각해 보자. 구체적으로 A, B가 길이가 $c$인 강철 막대기 M의 양끝점이라고 하자.</p>

<p>강체의 특징은 수용 가능한 변화에 대해 원 상태를 유지하는 성질을 가지고 있다는 것이다. 예를 들어 고무공은 강체가 아니기 때문에 힘을 가하면 부피가 줄어들거나 늘어나지만, 강철공은 부피가 변하지 않는다.</p>

<p>그렇다면 M이 능동적 변환에 가해졌을 때 무슨 일이 일어날 것인가? 예컨대 M이 관성좌표계 $(x, t)$에서 관성 운동하던 도중, M의 모든 부분이 “$(x, t)$에 대해 동시에” 가속하여 $0.6c$의 속도에 다다르면 M에는 무슨 일이 일어날 것인가?</p>

<p>M이 강체가 아니었다면 M의 길이는 A의 관점에서 $1.25c$로 팽창했을 것이다. 그러나 M은 강체이므로 자신의 원래 길이를 유지하려고 한다. 이에 따라 M이 가속하는 동안 M의 내부에서는 두 가지 효과가 대립하며 매우 복잡한 양상이 펼쳐진다.</p>

<ul>
  <li>효과 1: 동시성의 상대성으로 인해 B가 A보다 먼저 가속하여 M의 양끝이 잡아당겨진다.</li>
  <li>효과 2: M의 강체적 특성으로 인해 M의 원자 구조가 효과 1에 저항하는 장력을 발생시킨다.</li>
</ul>

<p>효과 2로 발생하는 내부 장력을 <strong>상대론적 장력</strong>(relativistic stress)이라고 부른다. 만약 M이 충분히 강한 강체라면 상대론적 장력을 버텨내어 M의 길이는 (A, B의 관점에서) $c$로 유지된다. 그러나 가속이 너무나 급격하여 상대론적 장력이 M의 수용 범위를 벗어나면 강체는 변형되거나 파괴된다. 일례로 쿠크다스를 광속에 가깝게 가속시키면 쿠크다스는 파괴된다.</p>

<h3 id="5-결론">5. 결론</h3>

<table>
  <thead>
    <tr>
      <th>A와 B의 거리</th>
      <th>A 관점</th>
      <th>A에 대해 움직이는 관성계 관점</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>수동적 변환</td>
      <td>유지</td>
      <td>수축</td>
    </tr>
    <tr>
      <td>능동적 변환 (A와 B가 분리되어 있을 때)</td>
      <td>팽창</td>
      <td>유지</td>
    </tr>
    <tr>
      <td>능동적 변환 (A와 B가 강체를 이룰 때)</td>
      <td>유지</td>
      <td>감소</td>
    </tr>
  </tbody>
</table>

<p>이제 벨의 사고실험으로 돌아가자. 두 우주선 A, B가 가속할 때 “우주선-실-우주선” 계는 능동적 변환을 겪는다. A의 관점에서 두 효과가 관측된다.</p>

<ul>
  <li>효과 1: A와 B는 분리되어 있으므로 A와 B의 거리는 팽창한다.</li>
  <li>효과 2: 팽팽히 당겨진 실의 강체적 특성에 의해 실의 길이는 유지된다.</li>
</ul>

<p>이에 따라 가속이 일정 시간 이상 지속되면 효과 1이 효과 2를 압도하여 실은 끊어진다. 만약 A와 B가 실이 아니라 강철 케이블로 연결되어 있었다면 효과 2가 효과 1을 압도하여 A와 B는 (A 및 B의 관점에서) 일정한 거리를 유지하게 된다.</p>

<hr />

<p>¹ 벨 부등식의 벨이 맞다.</p>

<p>² Rindler (1977), p. 41.</p>

<p>³ (나)와 (나’)은 같은 다이어그램이다. 이 부분이 이해가 안 된다면 이 글을 읽기에 앞서 로렌츠 변환과 민코프스키 다이어그램을 복습하자!</p>

<p>⁴ 그림에서는 $d’ &gt; d$인 것으로 보이지만, 민코스프키 다이어그램의 기하학은 유클리드 기하학이 아닌 민코프스키 기하학임을 유념해야 한다. 평면지도에서는 알래스카가 아프리카와 거의 비슷한 크기이지만 실제로는 아프리카가 훨씬 더 크듯이, 민코프스키 다이어그램에서는 $d’ &gt; d$인 것으로 보이지만 실제 로렌츠 변환을 계산하면 $d’ &lt; d$이다.</p>

  </div>
  <!-- <div
    style="border-bottom: 1px solid var(--lighter-slate); margin-bottom: 4em"
  ></div> -->
  <div style="margin-bottom: 6em"></div>
  
</div>

<div class="pagination">
  
  <span class="pagination-item older">이전 글</span>
    
  <a
    class="pagination-item newer"
    href="/page8"
    >다음 글</a
  >
   
</div>

<script>
  const faders = document.querySelectorAll(".fade-in-section");

  const appearOptions = {
    // threshold: 0.05,
    // rootMargin: "0px 0px 50px 0px",
  };

  const appearOnScroll = new IntersectionObserver((entries, observer) => {
    entries.forEach((entry) => {
      if (entry.isIntersecting) {
        entry.target.classList.add("is-visible");
        observer.unobserve(entry.target);
      }
    });
  }, appearOptions);

  faders.forEach((fader) => {
    appearOnScroll.observe(fader);
  });

  // 배너 이미지 로드 후 애니메이션 트리거 스크립트
  document.addEventListener('DOMContentLoaded', () => {
  const bannerImages = document.querySelectorAll('.fade-rise-1[src="/public/banner.png"], .fade-rise-2[src="/public/banner-2.png"]'); // 애니메이션 시작을 기다릴 이미지들
  const elementsToAnimate = document.querySelectorAll('.fade-rise-1, .fade-rise-2, .fade-rise-3'); // 애니메이션 될 요소들
  let loadedImagesCount = 0;
  const totalImagesToWait = bannerImages.length;

  // 기다릴 이미지가 없으면 즉시 애니메이션 시작
  if (totalImagesToWait === 0) {
    elementsToAnimate.forEach(el => el.classList.add('is-loaded'));
    return;
  }

  const checkAllImagesLoaded = () => {
    if (loadedImagesCount === totalImagesToWait) {
      // 모든 이미지가 로드되면 애니메이션 클래스 추가
      elementsToAnimate.forEach(el => el.classList.add('is-loaded'));
    }
  };

  bannerImages.forEach(img => {
    // 이미지가 캐시되어 이미 로드 완료된 경우
    if (img.complete) {
      loadedImagesCount++;
    } else {
      // 이미지 로드 완료 이벤트 리스너 추가
      img.addEventListener('load', () => {
        loadedImagesCount++;
        checkAllImagesLoaded(); // 이미지 로드될 때마다 체크
      });
      // 에러 발생 시 처리 (선택 사항)
      img.addEventListener('error', () => {
        console.error('Failed to load image:', img.src);
        // 에러 발생 시에도 애니메이션을 시작하려면 여기서 loadedImagesCount를 증가시키거나 다른 로직 추가
        // 현재 로직에서는 에러 시 카운트가 증가하지 않아 모든 이미지 로드되지 않으면 애니메이션 안 시작
        loadedImagesCount++; // 에러 발생 시에도 카운트 증가 (모든 이미지를 처리했음을 알림)
        checkAllImagesLoaded();
      });
    }
  });

  // 모든 이미지에 대해 complete 상태를 확인하거나 리스너를 설정한 후,
  // 이미 모든 이미지가 로드 완료 상태였을 경우를 대비해 마지막으로 체크
  checkAllImagesLoaded();
});
</script>
</div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script src="/public/js/script.js"></script>
  </body>
</html>
