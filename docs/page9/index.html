<!DOCTYPE html>
<html lang="en-us">
  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile" />
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />

  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=1"
  />

  <title>
     디멘의 블로그 &middot; 이데아를 여행하는 히치하이커
    
  </title>

  <style>
    .answer {
      display: none;
      margin-top: 10px;
      color: #333;
    }
  </style>

  <script>
    function toggleAnswer(id) {
      const answer = document.getElementById("answer" + id);
      if (answer.style.display === "none" || answer.style.display === "") {
        answer.style.display = "block";
      } else {
        answer.style.display = "none";
      }
    }
  </script>

  <script>
    MathJax = {
      tex: {
        inlineMath: [
          ["$", "$"],
          ["\\(", "\\)"],
        ],
      },
      svg: {
        fontCache: "global",
      },
    };
  </script>
  <script
    type="text/javascript"
    id="MathJax-script"
    async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
  ></script>

  
  <link rel="canonical" href="/page9/" />
  

  <link rel="stylesheet" href="/public/css/poole.css" />
  <link rel="stylesheet" href="/public/css/syntax.css" />
  <link rel="stylesheet" href="/public/css/lanyon.css" />
  <link
    rel="stylesheet"
    href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400"
  />

  <!-- <link rel="apple-touch-icon-precomposed" sizes="144x144" href="">
  <link rel="shortcut icon" href="">
   -->
  <link
    rel="apple-touch-icon-precomposed"
    sizes="144x144"
    href="/public/apple-touch-icon.png"
  />
  <link rel="shortcut icon" href="/public/favicon.ico" />
  <!-- <link rel="alternate" type="application/rss+xml" title="RSS" href="http://localhost:4000/atom.xml"> -->
  <link
    rel="alternate"
    type="application/rss+xml"
    title="RSS"
    href=""
  />

  <script
    async
    src="https://www.googletagmanager.com/gtag/js?id=G-PVGYLWF7GR"
  ></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
      dataLayer.push(arguments);
    }
    gtag("js", new Date());

    gtag("config", "G-PVGYLWF7GR");
  </script>
</head>


  <body>
    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox" />

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p>이데아를 여행하는 히치하이커</p>
  </div>

  <nav class="sidebar-nav">
    <a
      class="sidebar-nav-item"
      href="/"
      >메인</a
    >

                
    <a
      class="sidebar-nav-item"
      href="/about/"
      >저에 대하여</a
    >
        
    <a
      class="sidebar-nav-item"
      href="/archive-date/"
      >날짜별로 보기</a
    >
        
    <a
      class="sidebar-nav-item"
      href="/archive-tag/"
      >주제별로 보기</a
    >
          
    <a
      class="sidebar-nav-item"
      href="/book/"
      >새벽의 자연학 수업</a
    >
        
    <a
      class="sidebar-nav-item"
      href="/guestbook/"
      >방명록</a
    >
        
    <a
      class="sidebar-nav-item"
      href="/notes/"
      >복습노트 아카이브</a
    >
                                                                                                                          
  </nav>

  <div class="sidebar-item">
    <p>&copy; 2025. All rights reserved.</p>
    <p style="color: #202020">
      &copy; 2025. 디멘 reserved by 곰댕.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/" title="Home">디멘의 블로그</a>
            <small>이데아를 여행하는 히치하이커</small>
          </h3>
        </div>
      </div>

      <div class="container content"><head>
  <style>
    .fade-rise-1 {
      opacity: 0;
      transform: translateY(20px);
      /* animation: fadeRise 0.8s ease-out forwards;
      animation-delay: 0.2s; */
    }

    .fade-rise-2 {
      opacity: 0;
      transform: translateY(20px);
      /* animation: fadeRise 0.8s ease-out forwards;
      animation-delay: 0.4s; */
    }

    .fade-rise-3 {
      opacity: 0;
      transform: translateY(20px);
      /* animation: fadeRise 0.8s ease-out forwards;
      animation-delay: 0.6s; */
    }

        /* 이미지가 로드된 후 추가될 클래스에 animation 속성 추가 */
    .fade-rise-1.is-loaded {
      animation: fadeRise 0.8s ease-out forwards 0.2s;
    }
    .fade-rise-2.is-loaded {
      animation: fadeRise 0.8s ease-out forwards 0.4s;
    }
    .fade-rise-3.is-loaded {
      animation: fadeRise 0.8s ease-out forwards 0.6s;
    }

    @keyframes fadeRise {
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .fade-in-section {
      opacity: 0;
      transform: translateY(10px);
      transition: opacity 0.5s ease-out, transform 0.5s ease-out;
    }

    .fade-in-section.is-visible {
      opacity: 1;
      transform: none;
    }

    .spacer {
      height: 100vh;
    }
  </style>
</head>



<div class="posts">
  
  <div class="post fade-in-section">
    <h1 class="post-title">
      <a href="/2025/01/07/reference-1/"> 지시에 대하여 — 기술주의와 인과 이론 </a>
    </h1>

    <span class="post-date">07 Jan 2025</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/철학/'">
        철학
      </div>
      
      <div class="tag" onclick="location.href='/tags/언어철학/'">
        언어철학
      </div>
      
    </div>
     <blockquote>
  <p>해당 글은 <a href="https://plato.stanford.edu/entries/reference/">스탠퍼드 철학백과의 지시 항목</a>을 요약 및 정리한 글이다.</p>
</blockquote>

<h2 id="1-서론">1. 서론</h2>

<p>”저것은 금성이다“, “영국의 마지막 여왕은 엘리자베스 2세이다”에서 ‘저것‘, ’금성’, ’영국의 마지막 여왕‘, ‘엘리자베스 2세’는 이 세상에서 오직 하나의 대상을 특정하여 <strong>지시</strong>하는 표현들이다. 그러나 이들 표현이 특정 대상을 지시하게 되는 구체적 원리는 철학적 의문으로 가득하다.</p>

<p>이 글에서 다루는 질문은 여섯 가지이다.</p>

<ol>
  <li><strong>지시의 주체:</strong> 화자인가 단어인가?</li>
  <li><strong>지시 표현의 의미:</strong> 기술구인가, 지시체인가, 그 외의 것인가?</li>
  <li><strong>지시의 메커니즘:</strong> 지시 표현은 어떻게 특정 인물/대상에 결부되는가?</li>
  <li><strong>지시 이론의 범위:</strong> 모든 지시 표현은 공통의 메커니즘을 가지는가?</li>
  <li><strong>지시의 사적성:</strong> 지시는 화자의 사적 특징(e.g. 심리 상태)에 얼마나 의존하는가?</li>
  <li><strong>지시 이론의 의의:</strong> 지시 관계라는 것이 실제로 있는가? 철학적으로 유의미한가?</li>
</ol>

<p>이 글에서 다루는 이론은 <strong>기술주의, 인과 이론, 특성 모델, 의도주의</strong>의 네 가지이며, 추가로 <strong>지시 회의주의</strong>를 짧게 다룬다.</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>기술주의</th>
      <th>인과 이론</th>
      <th>특성 모델</th>
      <th>의도주의</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>주체</td>
      <td>화자</td>
      <td>지시어</td>
      <td>다원적</td>
      <td>화자</td>
    </tr>
    <tr>
      <td>의미</td>
      <td>기술적 내용</td>
      <td>지시체</td>
      <td>특성과 내용</td>
      <td> </td>
    </tr>
    <tr>
      <td>메커니즘</td>
      <td>단어는 구체적인 기술적 내용과 결부되어 그에 부합하는 대상을 지시한다.</td>
      <td>단어는 지시체의 명명식으로 거슬러 올라가는 인과적 사슬과 결부되어 지시한다.</td>
      <td>단어는 통상적 지시 규칙(특성)과 결부되어 대상(내용)을 지시한다.</td>
      <td>단어는 특정 대상을 지시하려는 의도와 결부되어 지시한다.</td>
    </tr>
    <tr>
      <td>범위</td>
      <td>넓음</td>
      <td>좁음(이름)</td>
      <td>보통</td>
      <td>넓음</td>
    </tr>
    <tr>
      <td>사적성</td>
      <td>강한 사적성</td>
      <td>약한 사적성</td>
      <td>보통 사적성</td>
      <td>강한~보통 사적성</td>
    </tr>
    <tr>
      <td>학자</td>
      <td>(프레게), 러셀, 스트로슨, 라이헨바흐</td>
      <td>밀, 크립키, 캐플런</td>
      <td>캐플런</td>
      <td>캐플런, 그라이스, 라이머</td>
    </tr>
    <tr>
      <td>강점</td>
      <td>프레게의 퍼즐을 설명</td>
      <td>크립키의 논증을 해결</td>
      <td>순수지표사의 원리를 해명</td>
      <td>불순지표사의 원리를 해명</td>
    </tr>
    <tr>
      <td>단점</td>
      <td>크립키의 양상 논증 및 의미론적 논증</td>
      <td>다수의 담지자를 가지는 이름의 문제</td>
      <td>불순지표사에서 화자-청자 딜레마 발생</td>
      <td>험티덤티 문제</td>
    </tr>
  </tbody>
</table>

<h2 id="2-고유이름">2. 고유이름</h2>

<h3 id="21-고유이름에-대한-기술주의-이론">2.1. 고유이름에 대한 기술주의 이론</h3>

<blockquote>
  <p><strong>기술주의 논제.</strong></p>

  <ol>
    <li>고유이름 $n$은 특정 <strong>기술적 내용</strong> $P$와 결부된다.</li>
    <li>$n$이 $P$와 결부되는 이유는 <strong>화자</strong>가 마음속에서 $n$을 $P$와 결부하기 때문이다.</li>
    <li>$P$를 만족하는 대상 $c$가 <strong>유일하게 존재할 때,</strong> $n$은 $c$를 지시한다.</li>
    <li>$n$의 <strong>의미</strong>와 $n$의 지시체는 구별되며, 전자가 후자를 결정한다.</li>
    <li>$n$의 의미는 $P$이다.</li>
  </ol>
</blockquote>

<p>예를 들어 ‘금성‘이라는 이름에 “태양계의 두 번째 행성”이라는 기술적 내용을 결부하는 화자는, 해당 기술적 내용을 만족하는 대상이 유일하며 그 대상이 금성이기 때문에 ’금성‘을 사용하여 금성을 지시한다.</p>

<p><em>Remark.</em></p>

<ol>
  <li>
    <p>기술적 내용은 기술구로 이해하는 것이 표준적이지만, 설(Searle) 등은 기술적 내용이 언어적으로 명시 가능한 것뿐 아니라 지각에 기반할 수도 있다고 주장한다.</p>
  </li>
  <li>
    <p>기술적 내용은, 그것을 만족시키는 대상이 불변한다는 특징을 가진다. 후술하다시피 이것은 기술주의가 지표사를 적절히 설명하지 못하는 원인이다.</p>
  </li>
  <li>
    <p>$n$의 의미는 <a href="https://velog.io/@dimenerno/De-Re%EC%97%90-%EB%8C%80%ED%95%9C-%EC%BD%B0%EC%9D%B8%EC%9D%98-%EA%B3%B5%EA%B2%A9">대언적</a>이다. 후술하다시피 이것은 기술주의가 양상 반론에 직면하는 원인이다.</p>
  </li>
  <li>
    <p>1번, 3번, 4번, 5번 논제는 이름의 <strong>의미론</strong> — 즉, 이름을 정의역으로 가지는 의미 함수 $M$의 공역이 무엇인지 설명하는 이론 — 을 제공하고, 2번 논제는 이름의 <strong>메타의미론</strong> — 즉, 각 이름 $n$에 대해 사상 $n \mapsto M(n)$은 어떻게 정의되는지 설명하는 이론 — 을 제공한다.</p>
  </li>
</ol>

<h4 id="논변-1-여러-담지자를-가지는-이름의-사례">논변 1. 여러 담지자를 가지는 이름의 사례</h4>

<p>A와 B가 ’보리스 존슨‘이라는 이름을 가진 두 명의 사람을 아는 경우를 고려하자. 한 명은 A와 B의 직장 동료이고, 다른 한 명은 영국의 전 총리이다. A가 B에게 “보리스 존슨은 중대한 실수를 저질렀다.”라고 말하자, B는 “어느 보리스 존슨을 의미하는가?”라고 묻는다. 이에 대해 A는 “영국의 전 총리”라고 대답한다.</p>

<p>위 사례에서 ’보리스 존슨‘이 지시하는 바는 (1) 화자인 A에게 결정권이 있으며, 이 결정은 (2) 화자가 마음속으로 염두에 두고 있는 기술적 내용을 매개로 이루어지는 것으로 보인다.</p>

<h4 id="논변-2-프레게의-퍼즐">논변 2. 프레게의 퍼즐</h4>

<p>다음 예문을 보자.</p>

<blockquote>
  <ol>
    <li>샛별은 개밥바라기이다.</li>
    <li>산타클로스는 북극에 산다.</li>
    <li>프레드는 마크 트웨인이 미국인이었다고 믿지만 새뮤얼 클레먼스가 미국인이었다고는 믿지 않는다.</li>
  </ol>
</blockquote>

<p>1은 참이지만 선험적(a priori)이지 않다. 2는 무의미(nonsense)하지 않다. 3의 경우 프레드의 믿음은 정합적(consistent)이다.</p>

<p>만약 이름의 의미가 그 지시체라면 1은 자기동일성 법칙에 따라 선험적이어야 하고, 2는 지시체(의미)가 결여된 문장이므로 무의미해야 하고, 3의 경우 마크 트웨인과 새뮤얼 클래먼스의 의미가 같으므로 프레드의 믿음은 비정합적이어야 한다. 그러나 기술주의는 이름의 의미와 지시체를 구별함으로써 세 예문에 대한 적절한 설명을 내놓는다.</p>

<h4 id="반론-1-양상-논증">반론 1. 양상 논증</h4>

<p>만약 내가 ‘보리스 존슨’에 대해 “브렉시트를 시행한 영국의 전 총리”라는 기술구를 결부시킨다 해도 나는 아래 문장을 참이라고 주장할 수 있다.</p>

<blockquote>
  <p>1. 보리스 존슨은 브렉시트를 시행하지 않을 수 있었다.</p>
</blockquote>

<p>그러나 이름의 의미가 기술구와 동등하다면 1은 2와 동치이다.</p>

<blockquote>
  <p>2. 다음이 사실일 수 있었다: 브렉시트를 시행한 영국의 전 총리는 브렉시트를 시행하지 않았다.</p>
</blockquote>

<p>그러나 2는 거짓이다. 따라서 이름의 의미는 기술적 내용이 아니다.</p>

<p><em>Remark.</em> 이름의 의미가 대상(re)이 아닌 기술적 내용(dicto)이므로, 1 → 2는 <a href="https://velog.io/@dimenerno/De-Re%EC%97%90-%EB%8C%80%ED%95%9C-%EC%BD%B0%EC%9D%B8%EC%9D%98-%EA%B3%B5%EA%B2%A9">De Dicto 치환</a>이다. De Re 치환의 경우 1은 3이 된다.</p>

<blockquote>
  <p>3. 브렉시트를 시행한 영국의 전 총리가 $c$일 때, 다음이 사실일 수 있었다: $c$는 브렉시트를 시행하지 않았다.</p>
</blockquote>

<p>2와 달리 3은 참으로 간주하는 데 문제가 없다.</p>

<p><em>Remark.</em> 양상 논증에 대처하기 위해 기술주의자는 3번, 4번 논제를 수정하고 5번 논제를 기각할 수 있다.</p>

<ol>
  <li>
    <p>$P$를 만족하는 대상 $c$가 <strong>현실 세계에서</strong> 유일하게 존재할 때, $n$은 $c$를 지시한다.</p>
  </li>
  <li>
    <p>$n$의 의미는 $n$의 지시체, 즉 $c$이다. (즉, $n$의 의미는 대물적이다)</p>
  </li>
</ol>

<p>그러나 이렇게 수정된 기술주의는 프레게의 퍼즐을 적절히 설명하지 못할 뿐더러, 다음의 의미론적 논증 또한 적절히 설명하지 못한다는 점에서 한계가 많은 이론이다.</p>

<h4 id="반론-2-의미론적-논증">반론 2. 의미론적 논증</h4>

<p>의미론적 논증은 방금 제시한 수정 기술주의를 비롯, 기술주의에 속하는 일군의 이론을 반박하는 논증이다. 요지는, 많은 경우 화자가 이름 $n$에 결부하는 기술적 내용 $P$는 세계에서 특정 대상을 <em>유일하게</em> 집어내지 못하며(즉, 기술은 <strong>불충분</strong>하며), 애초에 기술적 내용은 지시에 <strong>불필요</strong>하다는 것이다.</p>

<p>먼저 기술적 내용이 불충분함을 보여주는 사례로서 크립키가 제시한 <strong>파인만-겔만 사고실험</strong>이 있다. 대부분의 사람이 ‘파인만’이라는 이름에 결부하는 기술적 내용은 “미국의 유명한 물리학자” 정도이다. 이는 겔만 또한 해당하는 기술이다. 그러나 우리는 ‘파인만’이라는 이름으로 파인만을 성공적으로 지시하는 듯하다.</p>

<p>나아가 기술적 내용이 불필요함을 보여주는 사례로서 마찬가지로 크립키가 제시한 <strong>괴델-슈미트 사고실험</strong>을 보자. 크립키는 다음의 상황을 가정한다.</p>

<blockquote>
  <p>사실 산술의 불완전성을 처음 증명한 수학자는 괴델이 아닌 슈미트라는 무명의 수학자다. 그러나 증명을 발표하기 전, 슈미트는 의문스러운 죽음을 당했고 그의 증명은 괴델의 손에 들어가 괴델의 이름으로 발표되었다.</p>
</blockquote>

<p>(이 괴상한 사고실험에 대해서는 자기보다 위대한 논리학자인 괴델을 시기했던 크립키의 분풀이라는 카더라가 전해진다)</p>

<p>만약 (P1) 위 가정이 사실이고, (P2) 기술주의가 올바르며, (P3) 대부분의 사람이 ’괴델‘이라는 이름에 결부하는 기술적 내용이 ”산술의 불완전성을 처음 증명한 수학자“라면, (C) 대부분의 사람이 ’괴델‘이라는 이름으로 지시하는 대상은 괴델이 아닌 슈미트라는 결론이 도출된다. 그러나 이것은 반직관적이다. 따라서 기술주의는 올바르지 않다.</p>

<p><em>Remark.</em> 의미론적 논증을 극복하기 위해기술주의자는 다음 두 노선 중 하나를 택할 수 있다.</p>

<ol>
  <li>
    <p>이름에 결부되는 기술적 내용은 화자에게 개인적으로 이용 가능한 정보를 초월할 수 있다.</p>
  </li>
  <li>
    <p>이름에 결부되는 기술적 내용으로 “나에게 이 이름을 전달해 준 사람이 그 이름으로 지시하고자 했던 사람”을 채택할 수 있다.</p>
  </li>
</ol>

<p>스트로슨은 1번 노선을 선택한다. 그에 따르면 화자는 이름과 결부되어야 하는 기술적 내용을 제시하는 작업을 타인에게 의존할 수 있다. 이 경우, ‘파인만’ 또는 ‘괴델’의 의미는 파인만 전문가, 또는 괴델 전문가가 각 이름에 결부하는 기술적 내용이다. 그러나 스트로슨주의는 화자의 지시 의도를, 실제로 이루어지는 지시와 무관한 것으로 만든다는 점에서 반직관적이라는 한계가 있다.</p>

<p>2번 노선은 인과 이론과 밀접하게 닿아있다. 해당 이론을 살펴보도록 하자.</p>

<h3 id="22-고유이름에-대한-밀주의-및-인과-이론">2.2. 고유이름에 대한 밀주의 및 인과 이론</h3>

<blockquote>
  <p><strong>밀주의 논제.</strong> 고유이름의 의미는 곧 지시체이다.</p>
</blockquote>

<p>“밀주의”라는 이름에서 알 수 있듯이 이 입장은 존 스튜어트 밀로 거슬러 올라간다. 밀주의 이론들은 “샛별은 개밥바라기이다”와 같은 동일성 진술이 <strong>후험적이지만 필연적으로 참</strong>임을 함의한다.</p>

<p><em>Remark.</em> 크립키는 <strong>선험적이지만 우연적으로 참</strong>인 문장 또한 존재한다고 주장하며, “미터 원기의 길이는 1m이다”를 그 사례로 든다.</p>

<p>밀주의 논제는 이름에 대한 의미론을 제공한다. 이를 보충하는 대표적인 메타의미론으로 인과 이론이 있다.</p>

<blockquote>
  <p><strong>인과 이론</strong>.</p>

  <ol>
    <li>처음으로 대상 $c$를 이름 $n$으로 부르는 사건인 <strong>명명식</strong>이 있다.</li>
    <li>명명식에 참여한 사람을 시초로 하여, $n$으로 $c$를 지시하는 화자는 의사소통을 통해 해당 용례를 다른 화자에게 전달한다. 이같은 용례의 전달은 이름의 <strong>인과적 사슬</strong>을 형성한다.</li>
    <li>이름 $n$의 의미(지시체)는 $n$의 인과적 사슬의 시발점에 이루어진 명명식에서 명명된 대상이다.</li>
  </ol>
</blockquote>

<p>인과 이론의 미묘한 문제 중 하나는 어떤 의사소통 전달이 인과적 사슬에 실질적으로 참여하는지를 구별하는 문제이다. 일례로 내가 직장 동료에게 거만한 나의 고양이를 ’나폴레옹‘으로 불렀다고 해서 이 의사소통이 ’나폴레옹‘이라는 이름의 인과적 사슬에 실질적으로 참여하지는 않는다(이름의 가식적 사용). 또한 <strong>마다가스카르 사례</strong>와 같이 이름의 지시체가 도중에 바뀌는 경우도 있다(이름의 혼동된 사용). 여기서는 이 문제에 대한 논의를 생략한다.</p>

<h3 id="23-다수의-담지자가-있는-이름의-문제">2.3. 다수의 담지자가 있는 이름의 문제</h3>

<p>앞선 ‘보리스 존슨‘의 사례와 같이 다수의 담지자가 있는 이름의 경우, 지시의 결정권은 화자에게 있는 듯하다. 이 사실은 고전적 기술주의의 경우 문제가 되지 않는다. 그러나 스트로슨주의와 인과 이론에게 이 문제는 골칫거리이다.</p>

<p>스트로슨주의의 경우 이름 $n$의 지시체는 전문가 집단에 의해 유일하게 결정되므로 최대 1개의 지시체만을 가질 수 있다. 그러나 다수의 담지자가 있는 이름이 분명 가능하므로, 스트로슨주의는 이름을 더 세분화해서 생각해야 한다. 즉, 문자적으로 동등하지만($\ulcorner n_1 \urcorner = \ulcorner n_2 \urcorner$) 의미론적으로 다른($n_1 \mapsto c_1, n_2 \mapsto c_2, c_1 \neq c_2$) 이름들이 가능하다고 보는 것이다. 그러나 이 경우, 화자가 $\ulcorner n_i \urcorner$를 발화할 때 $i$를 결정하는 원리가 무엇이냐는 문제가 생긴다. <em>해당 원리가 화자의 내면 기술구일 수는 없는데, $\ulcorner n_i \urcorner$을 사용하여 $c_1$ 또는 $c_2$를 지시할 수 있으나 $c_1$과 $c_2$를 구별해 내는 데 충분한 지시적 내용을 갖추지 못한 화자를 떠올릴 수 있기 때문이다.</em></p>

<blockquote>
  <p>필자는 이탤릭체 내용을 받아들이지 못했다. 그런 경우가 정말로 있나?</p>
</blockquote>

<p>밀주의에도 비슷한 문제가 발생한다. 이 문제를 극복하기 위해 캐플런은 이름을 <strong>심리 현상</strong>으로 간주한다. 즉, 이름 $n$은 문자적 내용 $\ulcorner n \urcorner$과, $\ulcorner n \urcorner$으로 $c$를 지시하려는 의도가 얽힌 심리 현상이며, 인과적 사슬을 통해 전달되는 것은 이 심리 현상이다. 이에 따르면 다수의 담지자를 가지는 이름은 $n_1 = (\ulcorner n \urcorner, c_1), n_2 = (\ulcorner n \urcorner, c_2)$과 같이 구별되는 이름이며, $n_1$과 $n_2$를 성공적으로 습득한 화자는 자신의 의도에 따라 $n_1$ 또는 $n_2$를 선택하여 사용할 수 있다.</p>

<p>캐플런과 구별되는 또 하나의 노선은 다수의 담지자 문제를 인과 이론과 지표사 이론의 혼합으로 해결하려는 시도이다. 이 노선은 르카나티, 펠처, 래인스버리 등에 의해 채택되었으며, 다음 글에서 살펴 볼 지표사 이론에 대한 이해를 요구한다.</p>

  </div>
  <!-- <div
    style="border-bottom: 1px solid var(--lighter-slate); margin-bottom: 4em"
  ></div> -->
  <div style="margin-bottom: 6em"></div>
  
  <div class="post fade-in-section">
    <h1 class="post-title">
      <a href="/2024/12/26/uncountability-of-reals/"> 대각선 논법 없이 실수의 비가산성 증명하기 </a>
    </h1>

    <span class="post-date">26 Dec 2024</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/수학/'">
        수학
      </div>
      
      <div class="tag" onclick="location.href='/tags/위상수학/'">
        위상수학
      </div>
      
    </div>
     <blockquote>
  <p><strong>정리.</strong> $\mathbb{R}$은 비가산이다. 즉, $\mathbb{N}$에서 $\mathbb{R}$로 가는 전사함수는 존재하지 않는다.</p>
</blockquote>

<p>수학과 2학년 정도 되면 한번쯤은 들어 봤을 정리이다. 가장 널리 알려진 증명은 칸토어의 대각선 논법이다. 하지만 대각선 논법 없이 이 정리를 증명하는 방법이 있다. 각각 $\mathbb{R}$의 순서적 특징과, 위상적 특징을 이용한다.</p>

<h3 id="1-동형성-정리를-이용한-증명">1. 동형성 정리를 이용한 증명</h3>

<p><a href="https://dimenerno.github.io/2024/11/20/Rational-Real/">칸토어의 동형성 정리</a>에 따르면 다음을 만족하는 전순서 집합 $(S, \leq)$는 모두 순서 동형이다.</p>

<ol>
  <li>$S$는 가산이다.</li>
  <li>$S$는 조밀하다. 즉, $x, y \in S$에 대해 $x &lt; y$라면 $x &lt; z &lt; y$인 $z \in S$가 존재한다.</li>
  <li>$S$는 상계 및 하계를 가지지 않는다.</li>
</ol>

<p>$(\mathbb{Q}, \leq)$는 위 세 조건을 모두 만족하고, $(\mathbb{R}, \leq)$는 2와 3을 만족한다. 따라서 만약 $\mathbb{R}$이 가산이면 $(\mathbb{R}, \leq)$는 $(\mathbb{Q}, \leq)$와 순서 동형이다. 하지만 전자는 완비인데 반해 후자는 그렇지 않으므로 $\mathbb{R}$은 비가산이다. ■</p>

<h3 id="2-콤팩트성을-이용한-증명">2. 콤팩트성을 이용한 증명</h3>

<p><img src="https://velog.velcdn.com/images/dimenerno/post/433e72e3-822b-42a1-98dc-18fd2e260561/image.png" alt="" /></p>

<p>$X$가 고립점이 없는 콤팩트한 하우스도르프 공간이라고 하자. 또한 $X \neq \varnothing$이라고 하자.</p>

<p><em>Claim 1.</em> $U \neq \varnothing$가 $X$의 열린 집합이라고 하자. $x \in X$에 대해 $x \notin \bar{V}$이면서 $V \subset U$인 열린 집합 $V$가 존재한다.</p>

<p><em>Proof of Claim 1.</em> $x \neq y$이며 $y \in U$가 존재한다. 왜냐하면 $x \in U$인 경우 $X$가 고립점을 가지지 않으므로 존재하고, $x \notin U$인 경우 $U$가 공집합이 아니기 때문에 존재하기 때문이다. $X$가 하우스도르프이므로 $x, y$를 근방 $V_x, V_y$로 분리할 수 있다. $V = V_y \cap U$가 얻고자 하는 집합이다 (Fig 1의 색칠된 부분). □</p>

<p><em>Claim 2.</em> $X$는 비가산이다.</p>

<p><em>Proof of Claim 2.</em> $X$가 가산이라고 하자. $X$의 원소들을 $\lbrace  x_n \rbrace_{n \in \mathbb{Z}^+}$와 같이 나열한다. $V_0 = X$라고 하자. Claim 1에 의해 각 $n$에 대해 $x_n \notin \bar{V_n}$인 열린 집합 $V_n$이고 $V_n \subset V_{n-1}$인 열린 집합 $V_n$이 존재한다 (Fig 2). $X$가 콤팩트하므로 유한 교집합 성질에 의해</p>

\[V = \bigcap_{n \in \mathbb{Z}^+} \bar{V}_n \neq \varnothing\]

<p>이다. 하지만 $x_n \in V$라면 $x_n \in \bar{V}_n$이 되어 모순이다. 따라서 $X$는 비가산이다. □</p>

<p><em>Claim 3.</em> $\mathbb{R}$은 비가산이다.</p>

<p><em>Proof of Claim 3.</em> $[0, 1]$은 고립점을 가지지 않는 콤팩트 하우스도르프 공간이다. 따라서 비가산이다. 이에 따라 $\mathbb{R}$은 비가산이다. ■</p>

  </div>
  <!-- <div
    style="border-bottom: 1px solid var(--lighter-slate); margin-bottom: 4em"
  ></div> -->
  <div style="margin-bottom: 6em"></div>
  
  <div class="post fade-in-section">
    <h1 class="post-title">
      <a href="/2024/12/25/Cantor-Bendixson/"> 칸토어-벤딕슨 정리 </a>
    </h1>

    <span class="post-date">25 Dec 2024</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/수학/'">
        수학
      </div>
      
      <div class="tag" onclick="location.href='/tags/위상수학/'">
        위상수학
      </div>
      
    </div>
     <blockquote>
  <p><strong>정의.</strong> 위상공간 $X$의 집합 $P$에 대해 $P’ = P$일 때 $P$를 <strong>완벽한 집합(perfect set)</strong>이라고 한다. ($P’$은 $P$의 집적점들의 집합)</p>
</blockquote>

<p><em>Remark.</em> 모든 완벽한 집합은 닫힌 집합이지만, 역은 성립하지 않는다. 일반적으로 $S \not\subset S’$ ($S$가 고립점을 가짐), $S’ \not\subset S$ ($S$가 닫힌 집합이 아님) 임에 유의하라.</p>

<blockquote>
  <p><strong>정의.</strong> $X$의 임의의 부분공간이 린델뢰프일 때 $X$를 <strong>세습적 린델뢰프(hereditarily Lindelöf)</strong>라고 한다.</p>
</blockquote>

<blockquote>
  <p><strong>약한 칸토어-벤딕슨 정리.</strong> $X$가 세습적 린델뢰프 공간이라고 하자. $F \subset X$가 닫힌 집합일 때 어떤 완벽한 집합 $P$와 가산집합 $C$가 존재하여 $F = P \sqcup C$이다.</p>
</blockquote>

<p><img src="https://velog.velcdn.com/images/dimenerno/post/d1f81be8-2878-4158-844b-96ce3d8cc418/image.png" alt="" /></p>

<p><strong>증명.</strong> 다음과 같이 $P, C$를 정의한다.</p>

\[P = \lbrace  x \in F : \text{For all nbd $U$ of $x$, $U \cap F$ is uncountable} \rbrace\]

\[C = \lbrace  x \in F : \text{There exists a nbd $U$ of $x$ s.t. $U \cap F$ is countable} \rbrace\]

<p>$F = P \sqcup C$임에 주목하라.</p>

<p><em>Claim 1.</em> $C$는 $F$에서 열린 집합이다.</p>

<p><em>Proof of Claim.</em> $x \in C$일 때 어떤 $x$의 근방 $U$가 존재하여 $U \cap F$가 가산이다. 즉, 임의의 $y \in U \cap F$에 대해 $U$는 $y$의 근방이고 $U \cap F$가 가산이므로 $y \in C$이다. 따라서 $U \cap F \subset C$이다. □</p>

<p><em>Claim 2.</em> $C$는 가산이다.</p>

<p><em>Proof of Claim.</em> $F$의 부분공간 토폴로지를 생각하자. 가정에 의해 이 토폴로지는 린델뢰프이다. 임의의 $x \in C$에 대해 $U_x \cap F$가 가산인 $x$의 근방 $U_x$를 찾을 수 있다. 그러면 $\lbrace  U_x \rbrace_{x \in C}$는 $C$의 $F$-열린 덮개이며, 린델뢰프 가정에 의해 $C = \bigcup_{\alpha \in J} U_\alpha$ ($J$는 가산)이다. $U_\alpha$가 가산이므로 $C$는 가산이다. □</p>

<p><em>Claim 3.</em> $P$는 완벽하다.</p>

<p><em>Proof of Claim.</em> Claim 1에 의해 $P$는 $F$에서 닫힌 집합이며, $F$가 닫힌 집합이므로 $P$는 $X$에서 닫힌 집합이다. 따라서 $P’ \subset P$이다. 역을 보이기 위해 $x \in P$라고 하자. 임의의 $x$의 근방 $U$에 대해 $U \cap F = (U \cap C) \sqcup (U \cap P)$가 비가산이다. $C$가 가산이므로, $U \cap P$가 비가산이어야 한다. 따라서 $U$는 $P$와 $\lbrace x \rbrace$보다 큰 교집합을 가지며, $x \in P’$이다. ■</p>

<hr />

<blockquote>
  <p><strong>정의.</strong> 분리 가능한(separable) 완비 거리화 가능 공간을 <strong>폴란드 공간(Polish space)</strong>이라고 한다.</p>
</blockquote>

<p>거리화 가능 공간에서 분리 가능성, 2차 가산, 그리고 린델뢰프는 동치이므로 해당 세 가지 조건 중 하나로 정의를 대체할 수 있다. ‘폴란드 공간’이라는 이름은 해당 공간을 처음으로 연구한 학자들인 시에르핀스키, 쿠라토프스키, 타르스키 등이 폴란드인들이었기 때문에 기인했다.</p>

<p>$X$가 폴란드 공간이라는 더 강한 조건이 주어지면 칸토어-벤딕슨 분해가 유일함을 증명할 수 있다.</p>

<blockquote>
  <p><strong>강한 칸토어-벤딕슨 정리.</strong> $X$가 폴란드 공간이라고 하자. $F \subset X$가 닫힌 집합일 때 어떤 완벽한 집합 $P$와 가산집합 $C$가 존재하여 $F = P \sqcup C$이다. 또한, 해당 분해는 유일하다.</p>
</blockquote>

<p>또한 다음이 성립한다.</p>

<blockquote>
  <p><strong>정리.</strong> 폴란드 공간의 완벽한 집합은 $2^{\aleph_0}$의 크기를 가진다.</p>
</blockquote>

<p><strong>증명.</strong> 추후 기술적 집합론에 대한 글에서 따로 다룰 예정.</p>

<p>이로부터 다음의 결론이 따라 나온다.</p>

<blockquote>
  <p><strong>따름정리: 실수의 닫힌집합에서의 연속체 가설.</strong> 실수의 닫힌집합은 가산이거나 $2^{\aleph_0}$의 크기를 가진다.</p>
</blockquote>

<p><strong>증명.</strong> 실수는 폴란드 공간이므로 칸토어-벤딕슨 정리에 의해 모든 닫힌집합이 가산집합과 완벽한 집합의 서로소 합으로 분해된다. 후자가 공집합일 경우 해당 닫힌집합은 가산이며, 그렇지 않을 경우 $2^{\aleph_0}$이다. ■</p>

<p>칸토어는 위 정리의 증명으로부터 일반적인 연속체 가설을 증명할 수 있으리라는 희망을 품었지만 잘 알려져 있다시피 그 희망은 실현되지 못했다.</p>

  </div>
  <!-- <div
    style="border-bottom: 1px solid var(--lighter-slate); margin-bottom: 4em"
  ></div> -->
  <div style="margin-bottom: 6em"></div>
  
  <div class="post fade-in-section">
    <h1 class="post-title">
      <a href="/2024/12/16/adjoints/"> 어드조인트에 대한 직관적 이해 </a>
    </h1>

    <span class="post-date">16 Dec 2024</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/수학/'">
        수학
      </div>
      
      <div class="tag" onclick="location.href='/tags/범주론/'">
        범주론
      </div>
      
    </div>
     <p>카테고리 이론의 핵심 개념 중 하나는 어드조인트(adjoint)이다.</p>

<blockquote>
  <p><strong>정의.</strong> $\mathcal{A}, \mathcal{B}$가 카테고리이고, $F: \mathcal{A} \to \mathcal{B}, G: \mathcal{B} \to \mathcal{A}$가 함자(functor)라고 하자. $F$가 $G$의 <strong>좌 어드조인트(left adjoint)</strong>라는 것은 임의의 $A \in \mathcal{A}, B \in \mathcal{B}$에 대해 $\mathcal{B}(F(A), B)$와 $\mathcal{A}(A, G(B))$가 자연스럽게 일대일 대응될 수 있다는 것이다. 즉,</p>

\[\begin{gather}
(F(A) \xrightarrow{g} B) \quad \mapsto \quad (A \xrightarrow{\bar{g}} G(B))\\
(A \xrightarrow{f} G(B)) \quad \mapsto \quad (F(A) \xrightarrow{\bar{f}} B)
\end{gather}\]

  <p>또한 $G$를 $F$의 <strong>우 어드조인트(right adjoint)</strong>라고 한다. 기호로 $F \dashv G$로 표기한다.</p>
</blockquote>

<p>필자는 이 정의를 형식적인 수준에서만 이해하고 있었는데, 최근 어드조인트를 직관적으로 이해하는 몇 가지 방식을 발견했다.</p>

<h3 id="1-형-변환으로서의-어드조인트">1. 형 변환으로서의 어드조인트</h3>

<p>좌 어드조인트는 프로그래밍에서 다운캐스팅 형 변환에, 우 어드조인트는 업캐스팅 형 변환에 비견할 수 있다.</p>

<p>예를 들어 $\mathbf{Z}$가 정수를 원소로 가지고, $x \leq y$일 때 그리고 오직 그 경우에만 $x \to y$ 사상이 유일하게 존재하는 카테고리라고 하자. 또한 $\mathbf{Z}^2$가 정수쌍을 원소로 가지고, $\mathbf{x} \preceq \mathbf{y}$일 때 그리고 오직 그 경우에만 $\mathbf{x} \to \mathbf{y}$ 사상이 유일하게 존재하는 카테고리라고 하자(여기서 $\preceq$는 사전식 순서이다).</p>

<p>$F: \mathbf{Z} \to \mathbf{Z}^2, G: \mathbf{Z}^2 \to \mathbf{Z}$가 각각 $F(x) = (x, 0), G(x, y) = x$라면 자연스러운 방식으로 함자가 된다. 또한 $F \dashv G$이다. $x \in \mathbf{Z}, y \in \mathbf{Z}^2$에 대해 $F(x) \leq y$라면 $x \leq G(y)$이고, 그 역도 성립하기 때문이다.</p>

<p><img src="https://velog.velcdn.com/images/dimenerno/post/8040c20d-c1bc-4d92-bd45-256f48b79d75/image.png" alt="" /></p>

<p>위의 논의를 코드로 표현하면 다음과 같다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Z</span> <span class="o">{</span>
	<span class="kt">int</span> <span class="n">x</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Z2</span> <span class="kd">extends</span> <span class="no">Z</span> <span class="o">{</span>
	<span class="c1">// int x;</span>
	<span class="kt">int</span> <span class="n">y</span><span class="o">;</span>
<span class="o">}</span>

<span class="no">Z2</span> <span class="nf">F</span><span class="o">(</span><span class="no">Z</span> <span class="n">z</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">return</span> <span class="k">new</span> <span class="nf">Z2</span><span class="o">(</span><span class="n">z</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
<span class="o">}</span>

<span class="no">Z</span> <span class="nf">G</span><span class="o">(</span><span class="no">Z2</span> <span class="n">z2</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">return</span> <span class="k">new</span> <span class="nf">Z</span><span class="o">(</span><span class="n">z2</span><span class="o">.</span><span class="na">x</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이 코드에서 $F$는 실질적으로 다운캐스팅, $G$는 업캐스팅에 해당함에 주목하라.</p>

<h3 id="2-근사로서의-어드조인트">2. 근사로서의 어드조인트</h3>

<p>$F \dashv G$일 때 $F, G$는 $\mathcal{A}$과 $\mathcal{B}$의 원소들을 서로 근사하는 방법으로 생각할 수 있다. 특히 좌 어드조인트는 ‘좌측에서 우측으로‘의 근사이고, 우 어드조인트는 ‘우측에서 좌측으로’의 근사이다.</p>

<p>예를 들어 $\mathbf{Z}$가 정수를 원소로 가지고, $x \leq y$일 때 그리고 오직 그 경우에만 $x \to y$ 사상이 유일하게 존재하는 카테고리라고 하자. 또한 $\mathbf{R}$이 실수를 원소로 가지고, $x \leq y$일 때 그리고 오직 그 경우에만 $x \to y$ 사상이 유일하게 존재하는 카테고리라고 하자. 이때 $\lceil \cdot \rceil, \lfloor \cdot \rfloor$는 표준적인 방식으로 함자 $\mathbf{R} → \mathbf{Z}$가 되고, 포함 사상 $\iota$는 함자 $\mathbf{Z} → \mathbf{R}$이 된다. 또한 $\lceil \cdot \rceil \dashv \iota \dashv \lfloor \cdot \rfloor$임을 확인할 수 있다.</p>

<p><img src="https://velog.velcdn.com/images/dimenerno/post/e26ee728-09b0-4280-ac4c-511f89cef615/image.png" alt="" /></p>

<p>즉 $\lceil \cdot \rceil$는 $r$을 $r \leq \lceil r \rceil$로 ‘좌측에서 우측으로 끌어올리는’ 변환이고, $\lfloor \cdot \rfloor$은 $r$을 $\lfloor r \rfloor \leq r$로 ‘우측에서 좌측으로 잡아당기는’ 변환이다.</p>

<p>또한 $I, T$가 각각 $\mathcal{A}$의 초기 대상(initial object) 및 종단 대상(terminal object)라고 하자. 즉, 임의의 $A \in \mathcal{A}$에 대해</p>

<ul>
  <li>사상 $I \to A$가 유일하게 존재한다.</li>
  <li>사상 $A \to T$가 유일하게 존재한다.</li>
</ul>

<p>일례로 $\mathbf{Set}$에서 공집합은 초기 대상이고 홑원소 집합은 종단 대상이다.</p>

<p>홑원소 카테고리 $\mathcal{U}$에 대해 함자 $F: \mathcal{A} \to \mathcal{U}$가 유일하게 존재한다. $G_I, G_T: \mathcal{U} \to \mathcal{A}$가 각각 상이 $I, T$인 함자라고 하자. 이때 앞선 경우와 비슷한 원리로 $G_T \dashv F \dashv G_I$가 됨을 확인하라. (종단 대상은 가장 “오른쪽”에 있는 대상이므로 $G_T$는 “왼쪽에서 오른쪽으로”의 근사이며, 초기 대상은 가장 “왼쪽”에 있는 대상이므로 $G_I$는 “오른쪽에서 왼쪽으로”의 근사이다.)</p>

<h3 id="3-구축과-파괴로서의-어드조인트">3. 구축과 파괴로서의 어드조인트</h3>

<p>좌 어드조인트는 구축을, 우 어드조인트는 파괴를 의미한다. 따라서 일반적으로 자유함자(free functor)는 좌 어드조인트, 망각함자(forgetful functor)는 우 어드조인트이다.</p>

<p>일례로 군의 카테고리를 $\mathbf{Grp}$, 모노이드의 카테고리를 $\mathbf{Mon}$이라 하자. $F$를 자유함자, $U$를 망각함자라고 하자. 그리고 $R: \mathbf{Mon} → \mathbf{Grp}$를 다음과 같이 정의한다.</p>

<ul>
  <li>$R(M) = \lbrace  m \in M : \exists m^{-1} \in M \rbrace$</li>
  <li>$R(f): m \mapsto f(m)$</li>
</ul>

<p>이 때, 다음 다이어그램이 성립하여 $F \dashv U \dashv R$이다.</p>

<p><img src="https://velog.velcdn.com/images/dimenerno/post/1640d6b4-bd6a-4098-9fe8-e9a7ab164041/image.png" alt="" /></p>

<p>$R$이 $U$보다 더 파괴적이기 때문에 $U \dashv R$인 것으로 이해할 수 있다.</p>


  </div>
  <!-- <div
    style="border-bottom: 1px solid var(--lighter-slate); margin-bottom: 4em"
  ></div> -->
  <div style="margin-bottom: 6em"></div>
  
  <div class="post fade-in-section">
    <h1 class="post-title">
      <a href="/2024/12/11/VL-axiom/"> V = L 공리의 무모순성 </a>
    </h1>

    <span class="post-date">11 Dec 2024</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/수학/'">
        수학
      </div>
      
      <div class="tag" onclick="location.href='/tags/집합론/'">
        집합론
      </div>
      
    </div>
     <h2 id="1-전체">1. 전체</h2>

<h3 id="11-폰-노이만-전체">1.1. 폰 노이만 전체</h3>

<p><a href="https://dimenerno.github.io/2024/12/05/transfinite-recursion/">초한귀납적으로</a> $\lbrace  V_\alpha \rbrace$를 정의하자.</p>

<ul>
  <li>$V_0 = \varnothing$</li>
  <li>$V_{\alpha + 1} = V_\alpha \cup \mathcal{P}(V_\alpha)$</li>
  <li>$\lambda$가 극한 서수일 때, $V_\lambda = \bigcup_{\alpha &lt; \lambda} V_\alpha$</li>
</ul>

<p>처음 몇 개의 $V_\alpha$는 다음과 같다.</p>

<ul>
  <li>$V_1 = \lbrace  \varnothing \rbrace$</li>
  <li>$V_2 = \lbrace  \varnothing, \lbrace  \varnothing \rbrace \rbrace$</li>
  <li>$V_3 = \lbrace  \varnothing, \lbrace  \varnothing \rbrace, \lbrace  \lbrace  \varnothing \rbrace \rbrace, \lbrace  \varnothing, \lbrace  \lbrace  \varnothing\rbrace \rbrace  \rbrace$</li>
  <li>$V_\omega = \mathsf{HF}$</li>
</ul>

<p>모든 서수 $\alpha$에 대해 $V_\alpha$를 모아둔 모임을 <strong>폰 노이만 전체</strong>라고 한다.</p>

\[V = \bigcup_{\alpha \in \mathrm{Ord}} V_\alpha\]

<p>$x \in y \in z$가 $x \in z$를 시사할 때 $z$를 <strong>추이적 집합(transitive set)</strong>이라고 한다. 이것은 $V$의 중요한 특징이다.</p>

<blockquote>
  <p><strong>정리.</strong></p>

  <ol>
    <li>$\alpha \in \mathrm{Ord}$에 대해 $V_\alpha$는 추이적이다.</li>
    <li>$V$는 추이적이다.</li>
  </ol>
</blockquote>

<p>증명은 초한귀납법을 이용한다. 이에 따라 $V$를 다음과 같이 정의해도 무방하다.</p>

<ul>
  <li>$V_0 = \varnothing$</li>
  <li>$V_{\alpha + 1} = \mathcal{P}(V_\alpha)$</li>
  <li>$\lambda$가 극한 서수일 때, $V_\lambda = \bigcup_{\alpha &lt; \lambda}V_\alpha$</li>
</ul>

<p>직관적으로 생각했을 때 $V$는 모든 집합을 포함하는 듯하다. 실제로 다음을 증명할 수 있다.</p>

<blockquote>
  <p><strong>정리.</strong> $x$가 집합이라면 $x \in V$이다.</p>
</blockquote>

<p><strong>증명.</strong> 집합 $x$에 대해 $x$의 <strong>추이적 폐포</strong> $\bar{x}$를, $x$를 원소로 가지는 가장 작은 추이적 집합으로 정의한다(추이적 집합들의 교집합은 추이적이기 때문에 이 정의는 정당하다).</p>

<p>$x \notin V$라고 가정하자. 분류 공리에 의해 $y = \lbrace  u \in \bar{x} : u \notin V \rbrace$가 집합이며, 정초 공리에 의해 $y$의 $\in$-극소 원소 $z$가 존재한다. 만약 $w \notin V$인 $w \in z$가 존재한다면,  추이성에 의해 $w \in y$가 되어 $z$의 $\in$-극소성과 모순된다. 따라서 $z$의 모든 원소는 $V$에 있으며, 치환 공리로부터 $\Omega = \lbrace  \alpha \in \mathrm{Ord} \mid \exists w \in z : w \in V_\alpha\rbrace$가 집합이다. 부랄리포르티 정리에 의해 $\beta = \bigcup_{\alpha \in \Omega}\alpha$가 서수이며, <strong>$z \in V_{\beta + 1}$이다.</strong> (이 부분에서 $V_{\beta + 1} = \mathcal{P}(V_\beta)$임이 필요하다) 따라서 모순이다. ■</p>

<p>이에 따라 $V$는 집합이 아니다. 따라서 $V$는 모든 집합을 포함한다는 점에서 ZFC의 모델이지만, <a href="https://math.stackexchange.com/questions/56726/how-can-there-be-genuine-models-of-set-theory">많은 수학자들은 모델이 집합일 것을 요구하기 때문에</a> 엄격한 의미에서의 모델은 아니다. 하지만 이 글에서는 편의를 위해 $V$를 집합론의 모델이라고 부르도록 한다. 또한 $x \in V$를 “$x$는 집합이다“의 형식적 표현으로 이해하도록 한다.</p>

<h3 id="12-괴델-구성-가능-전체">1.2. 괴델 구성 가능 전체</h3>

<p>먼저 다음과 같이 구성 가능성을 정의한다.</p>

<blockquote>
  <p><strong>정의.</strong> $u$가 집합 $S$로부터 <strong>구성 가능</strong>하다는 것은, 어떤 1차 논리 명제 $\phi(y, x_1, \dots, x_n)$와 $c_1, \dots, c_n \in S$가 존재하여 다음이 성립하는 것이다.</p>

\[y \in u \iff y \in S \land \phi(y, c_1, \dots, c_n)\]

  <p>단, $\phi$의 양화사의 정의역은 $S$이다.</p>
</blockquote>

<p>예를 들어 $S = \lbrace 0, 1, 2\rbrace$일 때 다음은 $u = \lbrace  1, 2 \rbrace$를 구성한다.</p>

<ul>
  <li>$\phi(y, x_1, x_2) := (y = x_1) \lor (y = x_2)$</li>
  <li>$c_1 = 1, c_2 = 2$</li>
</ul>

<p>또한 $S = \mathbb{N}$일 때 다음은 $u = \lbrace 0, 3, 6, 9, \dots \rbrace$를 구성한다.</p>

<ul>
  <li>$\phi(y, x_1) := x_1 \mid y$</li>
  <li>$c_1 = 3$</li>
</ul>

<p>괴델의 구성가능성은 일반적인 의미에서의 구성가능성, 즉 언어로서의 표현가능성과 다르다. 일례로 언어로 표현가능한 실수의 집합은 가산이므로, 어떤 실수는 언어로 표현이 불가능하다. 그러한 실수를 $r$이라고 하자. 이제 $S = \mathbb{R}$일 때, 다음은 $u = \lbrace  r \rbrace$을 구성한다.</p>

<ul>
  <li>$\phi(y, x_1) := x_1 = y$</li>
  <li>$c_1 = r$</li>
</ul>

<p>즉, 괴델의 구성가능성은 자유변수의 초기화를 임의의 원소에 대해 허용한다는 점에서 강력하다. 그러나 자유변수의 수가 유한하다는 점에서 한계를 가진다. 이제 초한귀납적으로 $\lbrace  L_\alpha \rbrace$를 정의하자.</p>

<ul>
  <li>$L_0 = \varnothing$</li>
  <li>$L_{\alpha + 1} = \lbrace  x : x \text{ is constructible from } L_\alpha  \rbrace$</li>
  <li>$\lambda$가 극한 서수일 때, $L_\lambda = \bigcup_{\alpha &lt; \lambda} L_\alpha$</li>
  <li>$L = \bigcup_{\alpha &lt; \lambda} L_\alpha$</li>
</ul>

<p>$\alpha &lt; \omega$일 때 $L_\alpha = V_\alpha$임을 쉽게 보일 수 있다. $\alpha = n$일 때, 최대 $n$개의 $\lor$ 연언으로 $x \in V_\alpha$를 구성할 수 있기 때문이다. 따라서,</p>

<ul>
  <li>$L_1 = \lbrace  \varnothing \rbrace$</li>
  <li>$L_2 = \lbrace  \varnothing, \lbrace  \varnothing \rbrace \rbrace$</li>
  <li>$L_3 = \lbrace  \varnothing, \lbrace  \varnothing \rbrace, \lbrace  \lbrace  \varnothing \rbrace \rbrace, \lbrace  \varnothing, \lbrace  \lbrace  \varnothing\rbrace \rbrace  \rbrace$</li>
  <li>$L_\omega = \mathsf{HF}$</li>
</ul>

<p>하지만 $L_{\omega + 1} \subsetneq V_{\omega + 1}$이다. $\mathcal{P}(\mathbb{N}) \subset V_{\omega + 1}$이므로 $V_{\omega + 1}$은 비가산인 반면, 1차 논리 문장들의 집합과  $L_\omega$는 모두 가산이므로 $L_{\omega + 1}$ 또한 가산이기 때문이다. 일반적으로 $\alpha$가 가산일 때 $L_\alpha$는 가산이다.</p>

<p>그럼에도 $L$은 $V$와 많은 특징을 공유한다. 일례로,</p>

<blockquote>
  <p><strong>정리.</strong> $\alpha \in \mathrm{Ord}$에 대해 다음이 성립한다.</p>

  <ol>
    <li>$L_\alpha$는 추이적이다. (따라서 $L$이 추이적이다)</li>
    <li>$\alpha \in L_{\alpha + 1} \setminus L_{\alpha}$</li>
  </ol>
</blockquote>

<p>증명은 초한귀납법을 사용한다.</p>

<p>$L$은 모든 서수를 포함하므로 부랄리포르티 정리에 의해 집합이 아님에 유의하라. 대신 $x \in L_\alpha$에 대응되는 1차 논리식 $\mathsf{IsInL}_\alpha(x)$가 존재한다. 증명은 조금 까다로운데, 괴델 수를 이용하여 명제를 산술화하면 된다. (<a href="https://math.stackexchange.com/questions/198437/a-formula-that-defines-constructible-universe">링크</a> 참조) 따라서 $x \in L$을 $\exists \alpha \in \mathrm{Ord} :\mathsf{IsInL}_\alpha(x)$를 대체하는 형식적 표현으로 이해하여 사용하도록 한다. (물론 $\alpha \in \mathrm{Ord}$ 또한 1차 논리식을 대체하는 형식적 표현으로 이해되어야 한다)</p>

<h2 id="2-상대화">2. 상대화</h2>

<h3 id="21-명제의-상대화">2.1. 명제의 상대화</h3>

<p>1차 논리 명제는 양화사를 포함할 수 있다. 때문에 양화사의 정의역을 어떻게 설정하느냐의 따라 명제의 의미가 달라진다.</p>

<p>명제 $\phi$와 집합 (또는 모임) $A$에 대해, $\phi$의 상대화 $\phi^A$를 $\phi$의 모든 양화사를 $A$로 제한한 명제로 정의한다. 약간의 서사적 표현을 곁들이자면, $\phi^A$는 $A$의 “내부”에서 이해한 $\phi$라고 할 수 있겠다. 예를 들어, $\phi : \forall x \; \exists y : y &lt; x$일 때</p>

<ul>
  <li>$\phi^\mathbb{N} : \forall x \in \mathbb{N} \; \exists y \in \mathbb{N} : y &lt; x$</li>
  <li>$\phi^\mathbb{Z} : \forall x \in \mathbb{Z} \; \exists y \in \mathbb{Z} : y &lt; x$</li>
</ul>

<p>$T_\mathbb{Q}$가 자연수 및 정수를 특정할 수 있는 정도의 표현력을 지니는 유리수 이론이라고 하면,</p>

<ul>
  <li>$T_\mathbb{Q} \vdash \phi$</li>
  <li>$T_\mathbb{Q} \not\vdash \phi^\mathbb{N}$</li>
  <li>$T_\mathbb{Q} \vdash \phi^{\mathbb{Z}}$</li>
</ul>

<p>이다. 따라서 $\phi$는 자연수와 유리수를 성공적으로 구분해 내지만, 정수와 유리수는 구분해 내지 못한다. 이 관찰을 일반화하면, 이론 $T$와 집합 $A$에 대해 $T \vdash \phi \leftrightarrow \phi^A$인 $\phi$가 많으면 많을수록 $A$는 $T$의 기술에 잘 “부합한다“고 말할 수 있다.</p>

<p>위 논의를 조금 일반화하여, 다음과 같이 정의한다.</p>

<blockquote>
  <p><strong>정의.</strong> 이론 $T$와 집합 $A$에 대해서</p>

\[T \vdash \forall x_1, \dots, x_n \in A (\phi(x_1, \dots, x_n) \leftrightarrow \phi^A(x_1, \dots, x_n))\]

  <p>일 때, $\phi$는 $A$에 대해 <strong>절대적(absolute)</strong>이라고 한다.</p>
</blockquote>

<p>일례로 $T_\mathbb{Q}$에 대해 $\phi(x) : \exists y (y &lt; x)$는 정수에 대해 절대적이지만 자연수에 대해 절대적이지는 않다.</p>

<h3 id="22-l-상대화">2.2. $L$-상대화</h3>

<p>이제 우리의 목표는 $L$이 $\mathsf{ZF}$와 극대적으로 부합함을 보이는 것이다. 즉,</p>

<blockquote>
  <p><strong>정리 1.</strong> $\phi$가 ZF의 공리라면 $\mathsf{ZF} \vdash \phi^L$이다.</p>
</blockquote>

<p>정리 1의 의미를 말로 풀어 보자면,</p>

<blockquote>
  <p>“$L$의 내부에서 보았을 때 $L$은 ZF의 모델이다”를 ZF로 증명할 수 있다.</p>
</blockquote>

<p>물론 우리는 $L \subset V$만 알고 $V = L$인지는 알지 못하기 때문에, 어떤 집합 $x$는 $L$에 속하지 않을 수도 있다. 그러나 설령 $x \in V \setminus L$인 집합 $x$가 있더라도, 그러한 $x$의 결여는 $L$의 <em>내적 정합성</em>을 깨뜨리지 않는다는 것이 정리 1의 내용이다.</p>

<p>예를 들어 어떤 집합 $y, z$에 대해 $x = \lbrace  y, z \rbrace$가 $L$에 결여되어 있다고 하자. 일면 $x$의 결여는 $L$이 짝 공리 $\mathsf{Pair}$을 만족하지 않음을 시사하는 듯하다.</p>

\[\mathsf{Pair} := \forall y, z \; \exists x \; \forall w: w \in x \leftrightarrow (w = y \lor w = z)\]

<p>하지만 $L$의 내부에서 본 짝 공리는 다음과 같다.</p>

\[\mathsf{Pair}^L := \forall y, z \in L \; \exists x \in L \; \forall w \in L: w \in x \leftrightarrow (w = y \lor w = z)\]

<p>$\forall y, z$의 양화 또한 $L$로 한정됨에 주목하라. 즉, $x = \lbrace  y, z \rbrace$의 결여가 $L$에게 문제를 일으키는 경우는 $y, z \in L$일 때이다. 거꾸로 말해, $x = \lbrace  y, z \rbrace \notin L$이 $y, z \notin L$을 시사한다면 $L$은 $\mathsf{Pair}^L$을 만족한다. 이것이 “$L$이 내적 정합성을 유지하는 방식으로 집합을 결여한다”의 의미이다.</p>

<p>정리 1이 성립하는 핵심 이유는 $L$과 $V$가 <strong>추이성이라는 성질을 공유</strong>하기 때문이다.</p>

<blockquote>
  <p><strong>보조정리.</strong> 다음 술어는 ZF에서 $L$에 대해 절대적이다.</p>

  <ol>
    <li>$x \in y$</li>
    <li>$x \subset y$</li>
    <li>$x = \bigcup y$</li>
    <li>$x = \lbrace  y, z \rbrace$</li>
    <li>$\alpha \in \mathrm{Ord}$</li>
    <li>$x$는 추이적이다.</li>
    <li><a href="https://math.stackexchange.com/questions/404699/delta-0-formulas">$\Delta_0$ 논리식</a></li>
  </ol>
</blockquote>

<p>또한 다음을 증명할 수 있다.</p>

<blockquote>
  <p><strong>정리 2.</strong> $\mathsf{ZF} \vdash (V = L)^L$</p>
</blockquote>

<p>여기서 $V = L$은, “모든 집합이 $L$에 속한다”를 의미한다. 따라서 일면 보기에 $(V = L)^L$은 “$L$에 속하는 모든 집합이 $L$에 속한다”라는 자명한 명제인 듯하다. 하지만 실제로 $V = L$을 논리식으로 적으면</p>

\[\forall x \; \exists \alpha  : \alpha \in \mathrm{Ord} \land x \in L_\alpha\]

<p>이므로 $(V = L)^L$은</p>

\[\forall x \in L \; \exists \alpha \in L : (\alpha \in \mathrm{Ord})^L \land (x \in L_\alpha)^L\]

<p>이다. 특히, $\alpha \in \mathrm{Ord}$와 $x \in L_\alpha$가 진정한 의미에서의 $\in$-술어가 아닌 1차 논리식의 형식적 표현이기 때문에 마찬가지로 $L$로 상대화해야 함에 유의하라. 이에 따라 $(V = L)^L$을 ZF에서 증명하기 위해서는 $\alpha \in \mathsf{Ord}$와 $x \in L_\alpha$가 절대적임을 증명해야 한다. 두 증명 모두 초한귀납법을 사용하면 가능하다.</p>

<p>정리 1과 정리 2로부터 다음을 증명할 수 있다.</p>

<blockquote>
  <p><strong>정리 3.</strong> $\mathsf{ZFL} \vdash \phi \implies \mathsf{ZF} \vdash \phi^L$</p>
</blockquote>

<p><strong>증명.</strong> $\mathsf{ZFL} \vdash \phi$의 증명 길이에 대한 귀납법으로 증명한다. 증명 길이가 0일 때 $\phi$는 ZFL의 공리이다. $\phi$가 ZF의 공리일 때 정리 1로부터 증명되고, $\phi$가 $V = L$일 때 정리 2로부터 증명된다.</p>

<p>이제 $\phi$가 $\lbrace  \psi_1, \dots, \psi_n \rbrace$에 추론 규칙을 적용하는 것으로 증명된다고 가정하자. $\psi_k$의 증명 길이는 $\phi$보다 작으므로 귀납 가정에 의해 $\mathsf{ZF} \vdash \psi_k^L$이며,  논리 공리와 추론 규칙은 $L$에 대해 절대적임을 쉽게 보일 수 있다. 따라서 $(\psi_1 \land \dots \land \psi_n) \rightarrow \phi$가 논리적 참이라면 $(\psi_1^L \land \dots \land \psi_n^L) → \phi^L$ 또한 논리적 참이며, 이에 따라 $\mathsf{ZF} \vdash \phi^L$이다. ■</p>

<p>정리 3의 따름정리로서 정리 4를 얻는다.</p>

<blockquote>
  <p><strong>정리 4.</strong> ZF가 무모순적이라면 ZFL 또한 무모순적이다.</p>
</blockquote>

<p><strong>증명.</strong> ZFL이 모순적이라면 $\mathsf{ZFL} \vdash \varnothing \neq \varnothing$이며, 정리 3에 의해 $\mathsf{ZF} \vdash (\varnothing \neq \varnothing)^L \iff \mathsf{ZF} \vdash \varnothing \neq \varnothing$이다.</p>

<p>따라서 <strong>V = L은 ZF와 일관적이다</strong>.</p>

  </div>
  <!-- <div
    style="border-bottom: 1px solid var(--lighter-slate); margin-bottom: 4em"
  ></div> -->
  <div style="margin-bottom: 6em"></div>
  
</div>

<div class="pagination">
  
  <a
    class="pagination-item older"
    href="/page10"
    >이전 글</a
  >
    
  <a
    class="pagination-item newer"
    href="/page8"
    >다음 글</a
  >
   
</div>

<script>
  const faders = document.querySelectorAll(".fade-in-section");

  const appearOptions = {
    // threshold: 0.05,
    // rootMargin: "0px 0px 50px 0px",
  };

  const appearOnScroll = new IntersectionObserver((entries, observer) => {
    entries.forEach((entry) => {
      if (entry.isIntersecting) {
        entry.target.classList.add("is-visible");
        observer.unobserve(entry.target);
      }
    });
  }, appearOptions);

  faders.forEach((fader) => {
    appearOnScroll.observe(fader);
  });

  // 배너 이미지 로드 후 애니메이션 트리거 스크립트
  document.addEventListener('DOMContentLoaded', () => {
  const bannerImages = document.querySelectorAll('.fade-rise-1[src="/public/banner.png"], .fade-rise-2[src="/public/banner-2.png"]'); // 애니메이션 시작을 기다릴 이미지들
  const elementsToAnimate = document.querySelectorAll('.fade-rise-1, .fade-rise-2, .fade-rise-3'); // 애니메이션 될 요소들
  let loadedImagesCount = 0;
  const totalImagesToWait = bannerImages.length;

  // 기다릴 이미지가 없으면 즉시 애니메이션 시작
  if (totalImagesToWait === 0) {
    elementsToAnimate.forEach(el => el.classList.add('is-loaded'));
    return;
  }

  const checkAllImagesLoaded = () => {
    if (loadedImagesCount === totalImagesToWait) {
      // 모든 이미지가 로드되면 애니메이션 클래스 추가
      elementsToAnimate.forEach(el => el.classList.add('is-loaded'));
    }
  };

  bannerImages.forEach(img => {
    // 이미지가 캐시되어 이미 로드 완료된 경우
    if (img.complete) {
      loadedImagesCount++;
    } else {
      // 이미지 로드 완료 이벤트 리스너 추가
      img.addEventListener('load', () => {
        loadedImagesCount++;
        checkAllImagesLoaded(); // 이미지 로드될 때마다 체크
      });
      // 에러 발생 시 처리 (선택 사항)
      img.addEventListener('error', () => {
        console.error('Failed to load image:', img.src);
        // 에러 발생 시에도 애니메이션을 시작하려면 여기서 loadedImagesCount를 증가시키거나 다른 로직 추가
        // 현재 로직에서는 에러 시 카운트가 증가하지 않아 모든 이미지 로드되지 않으면 애니메이션 안 시작
        loadedImagesCount++; // 에러 발생 시에도 카운트 증가 (모든 이미지를 처리했음을 알림)
        checkAllImagesLoaded();
      });
    }
  });

  // 모든 이미지에 대해 complete 상태를 확인하거나 리스너를 설정한 후,
  // 이미 모든 이미지가 로드 완료 상태였을 경우를 대비해 마지막으로 체크
  checkAllImagesLoaded();
});
</script>
</div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script src="/public/js/script.js"></script>
  </body>
</html>
