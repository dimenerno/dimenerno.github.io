<!DOCTYPE html>
<html lang="en-us">
  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile" />
  <link href="https://fonts.googleapis.com/css2?family=Libre+Baskerville&display=swap" rel="stylesheet">
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />

  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=1"
  />

  <title>
     Arithmetic Hierarchy &middot; 디멘의 블로그 
  </title>

  <style>
    .answer {
      display: none;
      margin-top: 10px;
      color: #333;
    }
  </style>

<style>
  .lang-toggle-wrapper {
    display: flex;
    align-items: center;
    gap: 0.4em;
    margin-right: 0.5em;
  }

  .lang-label {
    font-size: 0.9em;
    line-height: 1;
  }

  .switch {
    position: relative;
    display: inline-block;
    width: 44px;
    height: 24px;
  }

  .switch input {
    opacity: 0;
    width: 0;
    height: 0;
  }

  .slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #e7e8eb;
    transition: 0.4s;
    border-radius: 24px;
  }

  .slider::before {
    position: absolute;
    content: "";
    height: 18px;
    width: 18px;
    left: 3px;
    bottom: 3px;
    background-color: white;
    transition: 0.4s;
    border-radius: 50%;
  }

  .switch input:checked + .slider {
    background-color: #2e2e2e;
  }

  .switch input:checked + .slider::before {
    transform: translateX(20px);
  }

  .lang-ko, .lang-en {
  transition: opacity 0.3s ease;
}
</style>

  <script>
    function toggleAnswer(id) {
      const answer = document.getElementById("answer" + id);
      if (answer.style.display === "none" || answer.style.display === "") {
        answer.style.display = "block";
      } else {
        answer.style.display = "none";
      }
    }
  </script>

  <script>
    MathJax = {
      tex: {
        inlineMath: [
          ["$", "$"],
          ["\\(", "\\)"],
        ],
      },
      svg: {
        fontCache: "global",
      },
    };
  </script>
  <script
    type="text/javascript"
    id="MathJax-script"
    async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
  ></script>

  
  <link rel="canonical" href="/2025/02/07/arithmetic-hierarchy/en" />
  

  <link rel="stylesheet" href="/public/css/poole.css" />
  <link rel="stylesheet" href="/public/css/syntax.css" />
  <link rel="stylesheet" href="/public/css/lanyon.css" />
  <link
    rel="stylesheet"
    href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400"
  />


  <link
    rel="apple-touch-icon-precomposed"
    sizes="144x144"
    href="/public/apple-touch-icon.png"
  />
  <link rel="shortcut icon" href="/public/favicon.ico" />
  <link
    rel="alternate"
    type="application/rss+xml"
    title="RSS"
    href=""
  />

  <script
    async
    src="https://www.googletagmanager.com/gtag/js?id=G-PVGYLWF7GR"
  ></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
      dataLayer.push(arguments);
    }
    gtag("js", new Date());

    gtag("config", "G-PVGYLWF7GR");
  </script>
</head>


  <style>
    /* 검색 입력창 */
    #search-input {
      padding: 6px 12px;
      font-size: 15px;
      border: 1px solid #eee;
      border-radius: 20px;
      outline: none;
      transition: all 0.2s ease-in-out;
      width: 90%;
      max-width: 240px;
      background-color: #fefefe;
    }

    #search-input::placeholder {
      color: var(--slate);
    }

    /* 입력창 포커스 시 */
    #search-input:focus {
      border-color: #9ea0a3;
      background-color: white;
    }

    @media (max-width: 600px) {
      .lang-label {
        display: none;
      }
    }
  </style>

  <body>
    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox" />

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p class="lang-ko">이데아를 여행하는 히치하이커</p>
    <p class="lang-en" style="display: none;">Alice in Logicland</p>
  </div>

  <nav class="sidebar-nav">
    <a
    class="sidebar-nav-item lang-ko"
    href="/"
    >메인</a>
    <a
    class="sidebar-nav-item lang-en"
    href="/"
    >Main</a
  >
                                                                                                                                                                                                       
    <a
      class="sidebar-nav-item lang-ko"
      href="/pages/about/"
      >저에 대하여</a
    >
    <a
    class="sidebar-nav-item lang-en"
    href="/pages/about/"
    >About Me</a
  >
        
    <a
      class="sidebar-nav-item lang-ko"
      href="/pages/archive-date/"
      >날짜별로 보기</a
    >
    <a
    class="sidebar-nav-item lang-en"
    href="/pages/archive-date/"
    >List by dates</a
  >
        
    <a
      class="sidebar-nav-item lang-ko"
      href="/pages/archive-tag/"
      >주제별로 보기</a
    >
    <a
    class="sidebar-nav-item lang-en"
    href="/pages/archive-tag/"
    >List by topics</a
  >
        
    <a
      class="sidebar-nav-item lang-ko"
      href="/pages/random/"
      >랜덤 포스트</a
    >
    <a
    class="sidebar-nav-item lang-en"
    href="/pages/random/"
    >Go to a random post</a
  >
        
    <a
      class="sidebar-nav-item lang-ko"
      href="/pages/book/"
      >새벽의 자연학 수업</a
    >
    <a
    class="sidebar-nav-item lang-en"
    href="/pages/book/"
    >Twilight Wonders (Korean)</a
  >
        
    <a
      class="sidebar-nav-item lang-ko"
      href="/pages/notes/"
      >복습노트 아카이브</a
    >
    <a
    class="sidebar-nav-item lang-en"
    href="/pages/notes/"
    >Maths Review Notes (Korean)</a
  >
        
    <a
      class="sidebar-nav-item lang-ko"
      href="/pages/guestbook/"
      >방명록</a
    >
    <a
    class="sidebar-nav-item lang-en"
    href="/pages/guestbook/"
    >Guestbook</a
  >
                
    <a
      class="sidebar-nav-item lang-ko"
      href="/pages/tractatus/"
      >⟪논리철학논고⟫ 읽기</a
    >
    <a
    class="sidebar-nav-item lang-en"
    href="/pages/tractatus/"
    >Reading Tractatus</a
  >
          
  </nav>

  <div class="sidebar-item">
    <p>&copy; 2025. All rights reserved.</p>
    <p style="color: #202020">
      &copy; 2025. 디멘 reserved by 곰댕.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead" style="width: 100%">
        <div
          class="container"
          style="
            display: flex;
            justify-content: space-evenly;
            align-items: center;
            padding: 0px;
            margin-left: 4em;
            margin-right: 0;
            max-width: none;
            overflow-y: hidden;
          "
        >
          <h3
            class="masthead-title"
            style="
              display: flex;
              flex-direction: row;
              gap: 0.3em;
              align-items: end;
              line-height: 1;
            "
          >
            <a
              href="/"
              style="white-space: nowrap"
              class="lang-ko"
              title="Home"
              >디멘의 블로그</a>
            <a
              href="/"
              style="white-space: nowrap"
              class="lang-en"
              title="Home"
            >Dimen's Blog</a>
            <small><div class="lang-ko">이데아를 여행하는 히치하이커</div>
              <div class="lang-en">Alice in Logicland</div></small>

          </h3>
          <form
            id="search-form"
            action="/search.html"
            method="get"
            style="display: flex; justify-content: end; padding-right: 1em"
          >
            <input
              type="text"
              name="q"
              id="search-input"
              placeholder="검색"
            />
          </form>

          <div class="lang-toggle-wrapper">
            <span class="lang-label">한</span>
            <label class="switch">
              <input type="checkbox" id="lang-toggle" />
              <span class="slider round"></span>
            </label>
            <span class="lang-label">EN</span>
          </div>
        </div>
      </div>

      <div class="container content"><div class="post">
  <h1 class="post-title">Arithmetic Hierarchy</h1>
  <span class="post-date">07 Feb 2025</span>
  
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/mathematics/'" >Mathematics</div>
      
      <div class="tag" onclick="location.href='/tags/logic/'" >Logic</div>
      
    </div>
  
  <blockquote>
  <p>This post was machine translated and has not yet been proofread. It may contain minor errors or unnatural expressions. Proofreading will be done in the near future.</p>
</blockquote>

<p><img src="/public/arithmetic-hierarchy.png" width="340px" style="margin: 2em auto;" /></p>

<blockquote>
  <p><strong>Warning.</strong> This article was written informally and may therefore lack rigour or even contain incorrect content.</p>
</blockquote>

<p>The <strong>arithmetic hierarchy</strong> is a classification of propositions in arithmetic — more precisely, first-order Peano arithmetic — according to the complexity of their quantifiers. The arithmetic hierarchy is a central concept in proof theory and computational complexity theory, and is also related to descriptive set theory.</p>

<h2 id="1-delta_0-propositions">1. $\Delta_0$ Propositions</h2>

<h3 id="11-definition">1.1. Definition</h3>

<blockquote>
  <p><strong>Definition.</strong> $\Sigma_0 = \Pi_0 = \Delta_0$ is the set of propositions containing only bounded quantifiers.</p>
</blockquote>

<p>Why the same class of propositions is referred to by three names will become clear shortly. In this article, unless there is a specific reason otherwise, we shall use $\Delta_0$ as the representative name among the three.</p>

<p>For example, the following four propositions are all $\Delta_0$.</p>

\[\begin{gather}
\phi_1 : 0 = 1\\
\phi_2(x) : \exists y &lt; x \; [y + y = x] \\
\phi_3(x, y) : \exists z \leq y \;[ xz = y ] \\
\end{gather}\]

<p>$\phi_1$ is a false statement. $\phi_2$ is true when $x$ is even, and $\phi_3$ is true when $x$ is a divisor of $y$.</p>

<p>Since $\Delta_0$ propositions have bounded quantifiers, it is possible to determine whether an arbitrary $x$ satisfies the corresponding proposition using a Turing machine. For instance, a Turing machine that determines whether $x$ satisfies $\phi_2$ is as follows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for y &lt; x:
   if y + y == x:
      return true;

return false;
</code></pre></div></div>

<p>The above Turing machine halts within $x$ iterations. Therefore, $\Delta_0$ propositions are <strong>decidable</strong>, <strong>recursive</strong>, or <strong>computable</strong> (the three expressions are synonymous). However, as we shall explain in detail later, not all decidable propositions are $\Delta_0$.</p>

<p>According to Gödel’s representability theorem, decidable true propositions are provable. In this article, when we say that $\phi$ is ‘true’, we mean $\mathcal{N} \vDash \phi$ for the standard model of arithmetics $\mathcal{N}$, rather than $\mathsf{PA} \vDash \phi$.</p>

<p>The following holds:</p>

<blockquote>
  <p><strong>Theorem.</strong> The set of true $\Delta_0$ sentences is complete. (That is, if $\phi$ is a true $\Delta_0$ sentence, then $\mathsf{PA} \vdash \phi$.)</p>
</blockquote>

<h3 id="12-delta_0-in-computational-theory">1.2. $\Delta_0$ in Computational Theory</h3>

<p>From a programming language perspective, $\Delta_0$ sentences correspond to the set of code that permits only the following:</p>

<ul>
  <li>Conditional statements</li>
  <li>Bounded loops</li>
  <li>Addition and multiplication</li>
</ul>

<p>It should be noted that <em>unbounded loops</em> and <em>variable reassignment</em> are not permitted. For example, the following code demonstrates that primality testing is $\Delta_0$:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for y &lt; x:
  for z &lt;= y:
    if yz == x:
      return false;

return true;
</code></pre></div></div>

<p>However, the following code that computes $x^y$ does not correspond to $\Delta_0$:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let a = 1
for 1&lt;= z &lt;= y:
   a = a * x

return a
</code></pre></div></div>

<p>So is exponentiation not $\Delta_0$? Not necessarily. Although complex, there are <a href="https://math.stackexchange.com/questions/5032077/how-to-express-exponentiation-with-a-delta-0-formula">methods</a> to express exponentiation with a $\Delta_0$ proposition. This case demonstrates that determining whether a given operation or predicate is $\Delta_0$ can be intricate. For instance, the following is known:</p>

<blockquote>
  <p><strong>Theorem.</strong> Factorial is $\Delta_0$, but tetration is not $\Delta_0$.</p>
</blockquote>

<p>However, tetration is decidable. Therefore, not all decidable propositions are $\Delta_0$.</p>

<h2 id="2-moving-up-one-level">2. Moving Up One Level</h2>

<blockquote>
  <p><strong>Definition.</strong></p>

\[\begin{gather}
\Sigma_1 := \{ \exists x_1 \cdots \exists x_n \;\phi : \phi \in \Pi_0 \}\\
\Pi_1 := \{ \forall x_1 \cdots \forall x_n \;\phi : \phi \in \Sigma_0 \}\\
\Delta_1 := \Sigma_1 \cap \Pi_1
\end{gather}\]
</blockquote>

<h3 id="21-sigma_1-propositions">2.1. $\Sigma_1$ Propositions</h3>

<p>The following propositions are $\Sigma_1$:</p>

\[\begin{gather}
\phi_1(x): \exists y \; \underbrace{[y^2 + y + 1 = x]}_{\Pi_0}\\
\phi_2(x): ∃y\; ∃z\; \underbrace{(y \text{ is prime} ∧ z \text{ is prime} ∧ x = y + z ∧ x \text{ is even})}_{\Pi_0}
\end{gather}\]

<p>$\phi_1$ is true in the set $\lbrace 1, 3, 7, 13, \ldots\rbrace $. $\phi_2$ is Goldbach’s conjecture; it is not known whether all $x$ satisfy this.</p>

<p>$\Sigma_1$ is the collection of <strong>recursively enumerable</strong> sets. That is, if $\phi \in \Sigma_1$, then there exists a Turing machine $M$ such that:</p>

<ul>
  <li>If $\phi(c)$ is true, then $M$ is guaranteed to decide $\phi(c)$.</li>
  <li>If $\phi(c)$ is false, then $M$ is not guaranteed to decide $\phi(c)$.</li>
</ul>

<p>For example, the following Turing machine shows that $\phi_2$ is recursively enumerable:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for y &gt; 1:
   for z &gt; 1:
      if isPrime(y) &amp; isPrime(z) &amp; x = y + z &amp; isEven(x):
         return true;

return false;
</code></pre></div></div>

<p>Although there is a <code class="language-plaintext highlighter-rouge">return false</code> statement, since there is no <code class="language-plaintext highlighter-rouge">break</code> statement to exit the loop, <code class="language-plaintext highlighter-rouge">return false</code> is unreachable. That is, if $\phi_2(c)$ is true, the above Turing machine returns true, but if it is false, it falls into an infinite loop.</p>

<p>If $\phi \in \Sigma_1$ is a sentence that is true in the standard model of arithmetics, then $\mathsf{PA} \vdash \phi$. A proposition of the form $\phi : \exists x \; \psi(x)$ being true in the standard model of arithmetics means that $\psi(c)$ is true for some $c \in \mathbb{N}$, and since $\psi(c)$ is a true $\Pi_0$ sentence, it is provable. Therefore, the following holds:</p>

<blockquote>
  <p><strong>Theorem.</strong> The set of true $\Sigma_1$ sentences is complete.</p>
</blockquote>

<h3 id="22-sigma_1-setminus-delta_0-propositions">2.2. $\Sigma_1 \setminus \Delta_0$ Propositions</h3>

<p>However, I have in fact been misleading the reader thus far. The propositions I listed earlier as examples of $\Sigma_1$ can actually be written as $\Delta_0$:</p>

\[\begin{gather}
\phi_1: \exists y&lt;x \;{[y^2 + y + 1 = x]}\\
\phi_2(x): ∃y&lt;x\; ∃z&lt;x\; {(y \text{ is prime} ∧ z \text{ is prime} ∧ x = y + z ∧ x \text{ is even})}
\end{gather}\]

<p>So what do propositions that strictly belong to $\Sigma_1$ look like? One answer can be found in the <strong>halting problem</strong>.</p>

<p>First, let $\mathrm{HaltsIn}(x, n)$ be a predicate that determines whether “the Turing machine with Gödel number $x$” produces an output within $n$ operations. This predicate can be easily defined from the <strong>Kleene predicate</strong>, and the Kleene predicate is known to be $\Sigma_0$. For example, if the Gödel number of a Turing machine that computes the square of 3 in 2 operations is $123$, then $\mathrm{HaltsIn}(123, 3)$ is true but $\mathrm{HaltsIn}(123, 1)$ is false.</p>

<p>Now consider the following proposition:</p>

\[\phi_1(x): \exists y \;[ \mathrm{HaltsIn}(x, y) ]\]

<p>What this proposition states is that the Turing machine with Gödel number $x$ eventually halts. That is, the above proposition is equivalent to the halting problem. However, the halting problem is undecidable. Since we showed earlier that all $\Delta_0$ propositions are decidable, $\phi$ is a $\Sigma_1$ proposition that does not belong to $\Delta_0$.</p>

<p>As another example, consider the following proposition:</p>

\[\phi_2(x): \exists y \; [ \mathrm{Proves}(x, y) ]\]

<p>Here, $\mathrm{Proves}(x, y)$ is a predicate that is true when the Gödel number of “a proof of the sentence with Gödel number $x$” is $y$. That is, $\phi_2(x)$ is a predicate stating that the sentence with Gödel number $x$ is provable. However, this predicate is not decidable. If $\phi_2$ were decidable, then (under the assumption that PA is consistent) there would exist a proof in PA that $\phi_2(\ulcorner 0 = 1 \urcorner)$ is false, which would conflict with Gödel’s incompleteness theorem.</p>

<h3 id="23-pi_1-propositions">2.3. $\Pi_1$ Propositions</h3>

<p>If $\Sigma_1$ propositions are the collection of recursively enumerable propositions, then $\Pi_1$ propositions are the collection of <strong>co-recursively enumerable</strong> propositions. That is, a $\Pi_1$ sentence is decidable if false, but not necessarily decidable if true. For example, the following two propositions are $\Pi_1$ sentences that are not $\Delta_0$:</p>

\[\begin{gather}
\phi_3(x): \forall y \;[ \lnot \mathrm{HaltsIn}(x, y) ] \\
\phi_4(x): \forall y \; [ \lnot \mathrm{Proves}(x, y) ]
\end{gather}\]

<p>Unlike the case of $\Sigma_1$, $\Pi_1$ is not complete. Since the negation of a $\Sigma_1$ sentence is $\Pi_1$, if $\Pi_1$ were also complete, then $\Sigma_1 = \Pi_1 =$ (collection of decidable propositions).</p>

<blockquote>
  <p><strong>Theorem.</strong> The set of true $\Pi_1$ sentences is not complete.</p>
</blockquote>

<h3 id="24-delta_1-propositions">2.4. $\Delta_1$ Propositions</h3>

<p>$\Delta_1$ propositions belong to both $\Sigma_1$ and $\Pi_1$. Therefore, $\Delta_1$ is the collection of <strong>decidable</strong> propositions. The tetration we saw earlier is a $\Delta_1$ proposition that is not $\Delta_0$.</p>

<h2 id="3-moving-up-another-level">3. Moving Up Another Level</h2>

<blockquote>
  <p><strong>Definition.</strong></p>

\[\begin{gather}
\Sigma_2 := \{ \exists x_1 \cdots \exists x_n \;\phi : \phi \in \Pi_1 \}\\
\Pi_2 := \{ \forall x_1 \cdots \forall x_n \;\phi : \phi \in \Sigma_1 \}\\
\Delta_2 := \Sigma_2 \cap \Pi_2
\end{gather}\]
</blockquote>

<p>I believe the pattern should now be clear. As an example of a $\Sigma_2$ proposition, consider the following:</p>

\[\phi_5(x) : \exists y \; [ \mathrm{DoesNotHaltOn}(x, y)]\]

<p>Here, $\mathrm{DoesNotHaltOn}(x, y)$ is a predicate that is true if “the Turing machine with Gödel number $x$” does not halt when given input $y$. From the preceding discussion, it is not difficult to see that $\mathrm{DoesNotHaltOn}$ is $\Pi_1$.</p>

<blockquote>
  <p><strong>Theorem.</strong> $\phi_5 \notin \Pi_1$</p>
</blockquote>

<p><strong>Proof.</strong> Suppose $\phi_5 \in \Pi_1$. Our goal is to show that this assumption implies “the set of true $\Pi_1$ sentences is complete”.</p>

<p>Let $\psi(x)$ be an arbitrary $\Delta_0$ proposition. Then $\theta : \forall x \;\psi(x)$ is a $\Pi_1$ sentence. Consider the following Turing machine $M$:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if ψ(x):
   return 1;

while True:
</code></pre></div></div>

<p>This Turing machine halts for value $x$ if $\psi(x)$ is true and does not halt if it is false. Therefore, $\theta$ being true is equivalent to $M$ halting for all $x$, which is equivalent to $\phi_5(\ulcorner M \urcorner)$ being false. By assumption, $\phi_5 \in \Pi_1$, so if $\phi_5(\ulcorner M \urcorner)$ is false, then $\mathsf{PA} \vdash \lnot \phi(\ulcorner M \urcorner)$. That is, $\mathsf{PA} \vdash \theta$, making all true $\Pi_1$ sentences provable. This is a contradiction. ■</p>

<p><em>Remark.</em> Strictly speaking, one should show that the above proof is expressible within PA.</p>

<p>We said earlier that $\Sigma_1$ propositions are decidable when true, and $\Pi_1$ propositions are decidable when false. However, since $\Sigma_2$ sentences have mixed $\forall$ and $\exists$ quantifiers, there may be sentences that are undecidable both when true and when false.</p>

<h3 id="31-oracles">3.1. Oracles</h3>

<blockquote>
  <p><strong>Definition.</strong> When $\mathcal{O}$ can obtain the result of problem $P$ in a single operation, we call $\mathcal{O}$ an <strong>oracle</strong> for $P$.</p>
</blockquote>

<p>For example, an oracle for the halting problem is a truly divine entity that can determine whether a given Turing machine halts in a single operation.</p>

<p>Ascending the arithmetic hierarchy is equivalent to being given increasingly powerful oracles. We saw earlier the following as an example of a $\Sigma_1$ proposition:</p>

\[\phi_1(x): \exists y \;[ \mathrm{HaltsIn}(x, y) ]\]

<p>However, if a halting problem oracle $\mathcal{O}$ were given, $\phi_1$ could be expressed simply as a $\Delta_0$ proposition:</p>

\[\phi_1(x) : \mathcal{O}(x)\]

<p>Also, we saw earlier the following as an example of a $\Sigma_2$ proposition:</p>

\[\phi_5(x) : \exists y \; [ \mathrm{DoesNotHaltOn}(x, y)]\]

<p>If a halting problem oracle $\mathcal{O}$ were given, $\phi_5$ could be expressed as a $\Sigma_1$ proposition:</p>

\[\phi_5(x): \exists y \; \lnot \mathcal{O}(x|_y)\]

<p>Here, $x|_y$ is the Gödel number of the state where input $y$ is given to the Turing machine with Gödel number $x$. That is, $\Sigma_2$ propositions reduce to $\Sigma_1$ propositions when given an oracle for the halting problem. By similar principles, $\Pi_2$ and $\Delta_2$ propositions reduce to $\Pi_1$ and $\Delta_1$ propositions, respectively, when given an oracle for the halting problem.</p>

<p>Furthermore, we can define <strong>second-order oracles</strong>. A second-order halting problem oracle is a halting problem oracle for Turing machines that use halting problem oracles. For example, whilst $\mathcal{O}$ is limited to determining whether the following code halts:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for x &gt; 0:
   for y &gt; 0:
      for z &gt; 0:
         for n &gt; 2:
            if x^n + y^n == z^n:
               return True;
return False;
</code></pre></div></div>

<p>$\mathcal{O}^2$ can also determine whether the following code halts. The following code takes as input the Gödel number $x$ of an NP Turing machine, halts if there exists a P Turing machine whose output matches $x$, and does not halt if no such machine exists:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let x ∈ NP;
for y ∈ P:
   if !Halts(
      let z = 0
      while x(z) == y(z):
         z = z + 1
   ):
      return 1; // halts when x is an NP that belongs to P
</code></pre></div></div>

<p>In general, the following holds:</p>

<blockquote>
  <p><strong>Theorem.</strong> Propositions in $\Pi_n$, $\Sigma_n$, $\Delta_n$ become propositions in $\Pi_{n-k}$, $\Sigma_{n-k}$, $\Delta_{n-k}$, respectively, when given a $k$-th order oracle.</p>
</blockquote>

</div>



  <!-- Utterances -->
  <script src="https://utteranc.es/client.js"
        repo="dimenerno/dimenerno.github.io"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
  </script></div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script src="/public/js/script.js"></script>
    <script src="/public/js/lang.js"></script>
  </body>
</html>
