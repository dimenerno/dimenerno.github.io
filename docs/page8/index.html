<!DOCTYPE html>
<html lang="en-us">
  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile" />
  <link href="https://fonts.googleapis.com/css2?family=Libre+Baskerville&display=swap" rel="stylesheet">
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />

  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=1"
  />

  <title>
     디멘의 블로그 &middot; 이데아를 여행하는 히치하이커
    
  </title>

  <style>
    .answer {
      display: none;
      margin-top: 10px;
      color: #333;
    }
  </style>

<style>
  .lang-toggle-wrapper {
    display: flex;
    align-items: center;
    gap: 0.4em;
    margin-right: 0.5em;
  }

  .lang-label {
    font-size: 0.9em;
    line-height: 1;
  }

  .switch {
    position: relative;
    display: inline-block;
    width: 44px;
    height: 24px;
  }

  .switch input {
    opacity: 0;
    width: 0;
    height: 0;
  }

  .slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #e7e8eb;
    transition: 0.4s;
    border-radius: 24px;
  }

  .slider::before {
    position: absolute;
    content: "";
    height: 18px;
    width: 18px;
    left: 3px;
    bottom: 3px;
    background-color: white;
    transition: 0.4s;
    border-radius: 50%;
  }

  .switch input:checked + .slider {
    background-color: #2e2e2e;
  }

  .switch input:checked + .slider::before {
    transform: translateX(20px);
  }

  .lang-ko, .lang-en {
  transition: opacity 0.3s ease;
}
</style>

  <script>
    function toggleAnswer(id) {
      const answer = document.getElementById("answer" + id);
      if (answer.style.display === "none" || answer.style.display === "") {
        answer.style.display = "block";
      } else {
        answer.style.display = "none";
      }
    }
  </script>

  <script>
    MathJax = {
      tex: {
        inlineMath: [
          ["$", "$"],
          ["\\(", "\\)"],
        ],
      },
      svg: {
        fontCache: "global",
      },
    };
  </script>
  <script
    type="text/javascript"
    id="MathJax-script"
    async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
  ></script>

  
  <link rel="canonical" href="/page8/" />
  

  <link rel="stylesheet" href="/public/css/poole.css" />
  <link rel="stylesheet" href="/public/css/syntax.css" />
  <link rel="stylesheet" href="/public/css/lanyon.css" />
  <link
    rel="stylesheet"
    href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400"
  />


  <link
    rel="apple-touch-icon-precomposed"
    sizes="144x144"
    href="/public/apple-touch-icon.png"
  />
  <link rel="shortcut icon" href="/public/favicon.ico" />
  <link
    rel="alternate"
    type="application/rss+xml"
    title="RSS"
    href=""
  />

  <script
    async
    src="https://www.googletagmanager.com/gtag/js?id=G-PVGYLWF7GR"
  ></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
      dataLayer.push(arguments);
    }
    gtag("js", new Date());

    gtag("config", "G-PVGYLWF7GR");
  </script>
</head>


  <style>
    /* 검색 입력창 */
    #search-input {
      padding: 6px 12px;
      font-size: 15px;
      border: 1px solid #eee;
      border-radius: 20px;
      outline: none;
      transition: all 0.2s ease-in-out;
      width: 90%;
      max-width: 240px;
      background-color: #fefefe;
    }

    #search-input::placeholder {
      color: var(--slate);
    }

    /* 입력창 포커스 시 */
    #search-input:focus {
      border-color: #9ea0a3;
      background-color: white;
    }

    @media (max-width: 600px) {
      .lang-label {
        display: none;
      }
    }
  </style>

  <body>
    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox" />

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p class="lang-ko">이데아를 여행하는 히치하이커</p>
    <p class="lang-en" style="display: none;">Alice in Logicland</p>
  </div>

  <nav class="sidebar-nav">
    <a
    class="sidebar-nav-item lang-ko"
    href="/"
    >메인</a>
    <a
    class="sidebar-nav-item lang-en"
    href="/"
    >Main</a
  >
                                                                                                                                                                                                     
    <a
      class="sidebar-nav-item lang-ko"
      href="/about/"
      >저에 대하여</a
    >
    <a
    class="sidebar-nav-item lang-en"
    href="/about/"
    >About Me</a
  >
        
    <a
      class="sidebar-nav-item lang-ko"
      href="/archive-date/"
      >날짜별로 보기</a
    >
    <a
    class="sidebar-nav-item lang-en"
    href="/archive-date/"
    >List by dates</a
  >
        
    <a
      class="sidebar-nav-item lang-ko"
      href="/archive-tag/"
      >주제별로 보기</a
    >
    <a
    class="sidebar-nav-item lang-en"
    href="/archive-tag/"
    >List by topics</a
  >
        
    <a
      class="sidebar-nav-item lang-ko"
      href="/random/"
      >랜덤 포스트</a
    >
    <a
    class="sidebar-nav-item lang-en"
    href="/random/"
    >Go to a random post</a
  >
        
    <a
      class="sidebar-nav-item lang-ko"
      href="/book/"
      >새벽의 자연학 수업</a
    >
    <a
    class="sidebar-nav-item lang-en"
    href="/book/"
    >Twilight Wonders (Korean)</a
  >
        
    <a
      class="sidebar-nav-item lang-ko"
      href="/notes/"
      >복습노트 아카이브</a
    >
    <a
    class="sidebar-nav-item lang-en"
    href="/notes/"
    >Maths Review Notes (Korean)</a
  >
        
    <a
      class="sidebar-nav-item lang-ko"
      href="/guestbook/"
      >방명록</a
    >
    <a
    class="sidebar-nav-item lang-en"
    href="/guestbook/"
    >Guestbook</a
  >
                      
  </nav>

  <div class="sidebar-item">
    <p>&copy; 2025. All rights reserved.</p>
    <p style="color: #202020">
      &copy; 2025. 디멘 reserved by 곰댕.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead" style="width: 100%">
        <div
          class="container"
          style="
            display: flex;
            justify-content: space-evenly;
            align-items: center;
            padding: 0px;
            margin-left: 4em;
            margin-right: 0;
            max-width: none;
            overflow-y: hidden;
          "
        >
          <h3
            class="masthead-title"
            style="
              display: flex;
              flex-direction: row;
              gap: 0.3em;
              align-items: end;
              line-height: 1;
            "
          >
            <a
              href="/"
              style="white-space: nowrap"
              class="lang-ko"
              title="Home"
              >디멘의 블로그</a>
            <a
              href="/"
              style="white-space: nowrap"
              class="lang-en"
              title="Home"
            >Dimen's Blog</a>
            <small><div class="lang-ko">이데아를 여행하는 히치하이커</div>
              <div class="lang-en">Alice in Logicland</div></small>

          </h3>
          <form
            id="search-form"
            action="/search.html"
            method="get"
            style="display: flex; justify-content: end; padding-right: 1em"
          >
            <input
              type="text"
              name="q"
              id="search-input"
              placeholder="검색"
            />
          </form>

          <div class="lang-toggle-wrapper">
            <span class="lang-label">한</span>
            <label class="switch">
              <input type="checkbox" id="lang-toggle" />
              <span class="slider round"></span>
            </label>
            <span class="lang-label">EN</span>
          </div>
        </div>
      </div>

      <div class="container content"><head>
  <style>
    .fade-rise-1 {
      opacity: 0;
      transform: translateY(20px);
      /* animation: fadeRise 0.8s ease-out forwards;
      animation-delay: 0.2s; */
    }

    .fade-rise-2 {
      opacity: 0;
      transform: translateY(20px);
      /* animation: fadeRise 0.8s ease-out forwards;
      animation-delay: 0.4s; */
    }

    .fade-rise-3 {
      opacity: 0;
      transform: translateY(20px);
      /* animation: fadeRise 0.8s ease-out forwards;
      animation-delay: 0.6s; */
    }

    /* 이미지가 로드된 후 추가될 클래스에 animation 속성 추가 */
    .fade-rise-1.is-loaded {
      animation: fadeRise 0.8s ease-out forwards 0.2s;
    }
    .fade-rise-2.is-loaded {
      animation: fadeRise 0.8s ease-out forwards 0.4s;
    }
    .fade-rise-3.is-loaded {
      animation: fadeRise 0.8s ease-out forwards 0.6s;
    }

    @keyframes fadeRise {
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .fade-in-section {
      opacity: 0;
      transform: translateY(10px);
      transition: opacity 0.5s ease-out, transform 0.5s ease-out;
    }

    .fade-in-section.is-visible {
      opacity: 1;
      transform: none;
    }

    .spacer {
      height: 100vh;
    }
  </style>
</head>



<div class="posts">
  
    <div class="post fade-in-section" data-lang="ko" style="display: none">
      <h1 class="post-title">
        <a href="/2025/02/07/arithmetic-hierarchy"> 산술 위계 </a>
      </h1>
    <span class="post-date">07 Feb 2025</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/수학/'">
        수학
      </div>
      
      <div class="tag" onclick="location.href='/tags/논리학/'">
        논리학
      </div>
      
    </div>
     <p><img src="/public/arithmetic-hierarchy.png" width="340px" style="margin: 2em auto;" /></p>

<blockquote>
  <p><strong>주의.</strong> 이 글은 뇌피셜로 쓰였기 때문에 엄밀하지 않고, 심지어 틀린 내용이 있을 수 있습니다.</p>
</blockquote>

<p><strong>산술 위계(arithmetical hierarchy)</strong>는 산술 — 엄밀히는 1차 페아노 산술 — 의 명제들을 양화사의 복잡도에 따라 분류한 것이다. 산술 위계는 증명 이론 및 계산 복잡도 이론의 핵심 개념이며, 기술적 집합론과도 연관이 있다.</p>

<h2 id="1-delta_0-명제">1. $\Delta_0$ 명제</h2>

<h3 id="11-정의">1.1. 정의</h3>

<blockquote>
  <p><strong>정의.</strong> $\Sigma_0 = \Pi_0 = \Delta_0$는 상한이 있는 양화사만을 가지는 명제들의 집합이다.</p>
</blockquote>

<p>왜 같은 부류의 명제를 세 개의 이름으로 부르는지는 곧 명확해질 것이다. 이 글에서는 특별한 이유가 없을 때에는 세 이름 중 $\Delta_0$라는 이름을 대표로 사용하겠다.</p>

<p>예를 들어 다음 네 명제들은 모두 $\Delta_0$ 명제들이다.</p>

\[\begin{gather}
\phi_1 : 0 = 1\\
\phi_2(x) : \exists y &lt; x \; [y + y = x] \\
\phi_3(x, y) : \exists z \leq y \;[ xz = y ] \\
\end{gather}\]

<p>$\phi_1$은 거짓인 문장이다. $\phi_2$는 $x$가 짝수일 때, $\phi_3$는 $x$가 $y$의 약수일 때 참인 명제이다.</p>

<p>$\Delta_0$ 명제들은 양화사에 상한이 걸려 있기 때문에, 임의의 $x$가 주어졌을 때 $x$가 해당 명제에 부합하는지를 튜링 기계로 판단할 수 있다. 예를 들어 $x$가 $\phi_2$를 만족하는지 판단하는 튜링 기계는 다음과 같다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for y &lt; x:
   if y + y == x:
      return true;

return false;
</code></pre></div></div>

<p>위 튜링 기계는 $x$번의 반복 이내에 정지한다. 따라서 $\Delta_0$는 또는 튜링 기계 등의 기계 장치로 <strong>결정 가능(decidable)</strong>한, 또는 <strong>재귀적인(recursive)</strong>, 또는 <strong>계산 가능(computable)</strong>한 명제들이다(세 표현은 동의어이다). 그러나 뒤에서 자세히 설명하듯이, 모든 결정 가능한 명제들이 $\Delta_0$인 것은 아니다.</p>

<p>괴델의 표현가능성 정리에 따라 결정 가능한 참인 명제는 증명 가능하다. 그리고 이 글에서 $\phi$가 ‘참’이라 함은, $\mathsf{PA} \vDash \phi$가 아니라, 표준 자연수 모형 $\mathcal{N}$에 대해 $\mathcal{N} \vDash \phi$라는 의미이다. 다시 말해, 다음이 성립한다.</p>

<blockquote>
  <p><strong>정리.</strong> 참인 $\Delta_0$ 문장들의 집합은 완전하다. (즉, $\phi$가 참인 $\Delta_0$ 문장이라면 $\mathsf{PA} \vdash \phi$이다.)</p>
</blockquote>

<h3 id="12-계산-이론에서의-delta_0">1.2. 계산 이론에서의 $\Delta_0$</h3>

<p>프로그래밍 언어의 관점에서 보았을 때 $\Delta_0$ 문장들은 다음만을 허용하는 코드의 집합과 대응된다.</p>

<ul>
  <li>조건문</li>
  <li>상한이 있는 반복문</li>
  <li>덧셈과 곱셈</li>
</ul>

<p>주의할 점은, <em>상한이 없는 반복문</em>과 <em>변수 재지정</em>은 허용되지 않는다는 것이다. 예를 들어 다음의 코드는 소수 판별이 $\Delta_0$임을 입증한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for y &lt; x:
  for z &lt;= y:
    if yz == x:
      return false;

return true;
</code></pre></div></div>

<p>그러나 $x^y$를 계산하는 다음의 코드는 $\Delta_0$에 해당되지 않는다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let a = 1
for 1&lt;= z &lt;= y:
   a = a * x

return a
</code></pre></div></div>

<p>그렇다면 지수 연산은 $\Delta_0$가 아닌 것일까? 그렇지는 않다. 복잡하긴 하지만, $\Delta_0$ 명제로 지수를 표현하는 방법이 <a href="https://math.stackexchange.com/questions/5032077/how-to-express-exponentiation-with-a-delta-0-formula">있다</a>. 이 사례는 주어진 연산 또는 술어가 $\Delta_0$인지 판단하는 일이 까다로울 수 있음을 방증한다. 일례로 다음이 알려져 있다.</p>

<blockquote>
  <p><strong>정리.</strong> 팩토리얼은 $\Delta_0$이지만 테트레이션은 $\Delta_0$가 아니다.</p>
</blockquote>

<p>그러나 테트레이션은 결정 가능하다. 따라서 모든 결정 가능한 명제들이 $\Delta_0$인 것은 아니다.</p>

<h2 id="2-한-단계-올라가기">2. 한 단계 올라가기</h2>

<blockquote>
  <p><strong>정의.</strong></p>

\[\begin{gather}
\Sigma_1 := \{ \exists x_1 \cdots \exists x_n \;\phi : \phi \in \Pi_0 \}\\
\Pi_1 := \{ \forall x_1 \cdots \forall x_n \;\phi : \phi \in \Sigma_0 \}\\
\Delta_1 := \Sigma_1 \cap \Pi_1
\end{gather}\]
</blockquote>

<h3 id="21-sigma_1-명제">2.1. $\Sigma_1$ 명제</h3>

<p>다음 명제들은 $\Sigma_1$이다.</p>

\[\begin{gather}
\phi_1(x): \exists y \; \underbrace{[y^2 + y + 1 = x]}_{\Pi_0}\\
\phi_2(x): ∃y\; ∃z\; \underbrace{(y \text{ is prime} ∧ z \text{ is prime} ∧ x = y + z ∧ x \text{ is even})}_{\Pi_0}
\end{gather}\]

<p>$\phi_1$은 집합 $\lbrace 1, 3, 7, 13, \dots \rbrace$에서 참이다. $\phi_2$는 골드바흐의 추측으로, 모든 $x$가 이를 만족하는지는 알려져 있지 않다.</p>

<p>$\Sigma_1$은 <strong>재귀적으로 열거 가능(recursively enumerable)</strong>한 집합들의 모임이다. 즉, $\phi \in \Sigma_1$이라면 다음의 튜링 기계 $M$이 존재한다.</p>

<ul>
  <li>$\phi(c)$가 참이라면 $M$이 $\phi(c)$를 결정함이 보장된다.</li>
  <li>$\phi(c)$가 거짓이라면 $M$이 $\phi(c)$를 결정함이 보장되지 않는다.</li>
</ul>

<p>예를 들어 다음의 튜링 기계는 $\phi_2$가 재귀적으로 열거 가능함을 보여준다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for y &gt; 1:
   for z &gt; 1:
      if isPrime(y) &amp; isPrime(z) &amp; x = y + z &amp; isEven(x):
         return true;

return false;
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">return false</code> 문이 있기는 하지만, 반복문에서 빠져나올 <code class="language-plaintext highlighter-rouge">break</code> 문이 없으므로 <code class="language-plaintext highlighter-rouge">return false</code>는 도달 불가능하다. 즉, $\phi_2(c)$가 참이라면 위의 튜링 기계는 참을 반환하지만 거짓이라면 무한 루프에 빠진다.</p>

<p>$\phi \in \Sigma_1$이 표준 자연수 모형에서 참인 문장이라면 $\mathsf{PA} \vdash \phi$이다. $\phi : \exists x \; \psi(x)$ 꼴의 명제가 표준 자연수 모형에서 참이라는 것은 어떤 $c \in \mathbb{N}$에 대해 $\psi(c)$가 참이라는 의미이며, $\psi(c)$는 참인 $\Pi_0$ 문장이므로 증명 가능하기 때문이다. 따라서 다음이 성립한다.</p>

<blockquote>
  <p><strong>정리.</strong> 참인 $\Sigma_1$ 문장들의 집합은 완전하다.</p>
</blockquote>

<h3 id="22-sigma_1-setminus-delta_0-명제">2.2. $\Sigma_1 \setminus \Delta_0$ 명제</h3>

<p>그런데 사실 지금까지 필자는 독자를 오도했다. 앞서 $\Sigma_1$의 예시로 나열한 명제들은 사실 $\Delta_0$로 쓸 수 있기 때문이다.</p>

\[\begin{gather}
\phi_1: \exists y&lt;x \;{[y^2 + y + 1 = x]}\\
\phi_2(x): ∃y&lt;x\; ∃z&lt;x\; {(y \text{ is prime} ∧ z \text{ is prime} ∧ x = y + z ∧ x \text{ is even})}
\end{gather}\]

<p>그렇다면 $\Delta_0$에 속하지 않는 $\Sigma_1$ 명제는 어떻게 생겼을까? 한 가지 답은 <strong>정지 문제</strong>에서 찾을 수 있다.</p>

<p>먼저 $\mathrm{HaltsIn}(x, n)$를, “괴델 수가 $x$인 튜링 기계”가 $n$회의 연산 이내에 출력값을 내놓는지를 판별하는 술어라고 하자. 이 술어는 <strong>클레이니 술어</strong>로부터 쉽게 정의할 수 있으며, 클레이니 술어는 $\Sigma_0$임이 알려져 있다. 예를 들어 3의 제곱을 2회의 연산으로 계산하는 튜링 기계의 괴델 수가 $123$이라면 $\mathrm{HaltsIn}(123, 3)$은 참이지만 $\mathrm{HaltsIn}(123, 1)$는 거짓이다.</p>

<p>이제 다음 명제를 고려하자.</p>

\[\phi_1(x): \exists y \;[ \mathrm{HaltsIn}(x, y) ]\]

<p>위 명제가 말하는 바는, 괴델 수가 $x$인 튜링 기계가 언젠가 정지한다는 것이다. 즉, 위 명제는 정지 문제와 동치이다. 그런데 정지 문제는 결정 불가능하다. 앞서 $\Delta_0$ 명제는 모두 결정 가능함을 보았으므로, $\phi$는 $\Delta_0$에 속하지 않는 $\Sigma_1$ 명제이다.</p>

<p>다른 예시로, 다음 명제를 고려하자.</p>

\[\phi_2(x): \exists y \; [ \mathrm{Proves}(x, y) ]\]

<p>여기서 $\mathrm{Proves}(x, y)$는 “괴델 수가 $x$인 문장의 증명”의 괴델 수가 $y$일 때 참인 술어이다. 즉, $\phi_2(x)$는 괴델 수가 $x$인 문장이 증명 가능하다는 술어이다. 그런데 이 술어는 결정 가능하지 않다. 만약 $\phi_2$가 결정 가능하다면 (PA가 무모순적이라는 가정 하에) $\phi_2(\ulcorner 0 = 1 \urcorner)$이 거짓이라는 증명이 PA에 존재하게 되어 괴델의 불완전성 정리와 상충하기 때문이다.</p>

<h3 id="23-pi_1-명제">2.3. $\Pi_1$ 명제</h3>

<p>$\Sigma_1$ 명제가 재귀적으로 열거 가능한 명제들의 모임이라면, $\Pi_1$ 명제는 <strong>쌍대-재귀적으로 열거 가능한(co-recursively enumerable)</strong> 명제들의 모임이다. 즉 $\Pi_1$의 문장은 거짓이라면 결정 가능하지만 참이라면 결정 가능성이 보장되지 않는다. 예를 들어 다음 두 명제는 $\Delta_0$가 아닌 $\Pi_1$ 문장이다.</p>

\[\begin{gather}
\phi_3(x): \forall y \;[ \lnot \mathrm{HaltsIn}(x, y) ] \\
\phi_4(x): \forall y \; [ \lnot \mathrm{Proves}(x, y) ]
\end{gather}\]

<p>$\Sigma_1$의 경우와 달리, $\Pi_1$은 완전하지 않다. $\Sigma_1$ 문장의 부정이 $\Pi_1$이기 때문에, $\Pi_1$ 또한 완전하다면 $\Sigma_1 = \Pi_1=$ (결정 가능한 명제들의 모임)이 되기 때문이다.</p>

<blockquote>
  <p><strong>정리.</strong> 참인 $\Pi_1$ 문장들의 집합은 완전하지 않다.</p>
</blockquote>

<h3 id="24-delta_1-명제">2.4. $\Delta_1$ 명제</h3>

<p>$\Delta_1$ 명제는 $\Sigma_1$과 $\Pi_1$에 모두 속한다. 따라서 $\Delta_1$은 <strong>결정 가능한</strong> 명제들의 모임이다. 앞서 본 테트레이션은 $\Delta_0$가 아닌 $\Delta_1$ 명제이다.</p>

<h2 id="3-한-단계-더-올라가기">3. 한 단계 더 올라가기</h2>

<blockquote>
  <p><strong>정의.</strong></p>

\[\begin{gather}
\Sigma_2 := \{ \exists x_1 \cdots \exists x_n \;\phi : \phi \in \Pi_1 \}\\
\Pi_2 := \{ \forall x_1 \cdots \forall x_n \;\phi : \phi \in \Sigma_1 \}\\
\Delta_2 := \Sigma_2 \cap \Pi_2
\end{gather}\]
</blockquote>

<p>이제 패턴이 보일 거라 생각한다. $\Sigma_2$ 명제의 예시로, 다음을 보자.</p>

\[\phi_5(x) : \exists y \; [ \mathrm{DoesNotHaltOn}(x, y)]\]

<p>여기서 $\mathrm{DoesNotHaltOn}(x, y)$는, “괴델 수가 $x$인 튜링 기계”에 $y$를 입력했을 때 정지하지 않으면 참인 술어이다. 앞선 논의로부터 $\mathrm{DoesNotHaltOn}$이 $\Pi_1$임을 어렵지 않게 알 수 있다.</p>

<blockquote>
  <p><strong>정리.</strong> $\phi_5 \notin \Pi_1$</p>
</blockquote>

<p><strong>증명.</strong> $\phi_5 \in \Pi_1$이라고 가정하자. 우리의 목표는 이 가정이 “참인 $\Pi_1$ 문장들의 집합은 완전하다”를 시사함을 보이는 것이다.</p>

<p>$\psi(x)$가 임의의 $\Delta_0$ 명제라고 하자. $\theta : \forall x \;\psi(x)$는 $\Pi_1$ 문장이다. 다음의 튜링 기계 $M$을 생각하자.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if ψ(x):
   return 1;

while True:
</code></pre></div></div>

<p>이 튜링 기계는 값 $x$에 대해 $\psi(x)$가 참이면 정지하고 거짓이면 정지하지 않는다. 따라서 $\theta$가 참이라는 것은 모든 $x$에 대해 $M$이 정지한다는 것과 동치이며, 이것은 $\phi_5(\ulcorner M \urcorner)$이 거짓임과 동치이다. 그리고 가정에 의해 $\phi_5 \in \Pi_1$이므로, $\phi_5(\ulcorner M \urcorner)$이 거짓이라면 $\mathsf{PA} \vdash \lnot \phi(\ulcorner M \urcorner)$이다. 즉, $\mathsf{PA} \vdash \theta$가 되어 모든 참인 $\Pi_1$ 문장은 증명 가능하게 된다. 이것은 모순이다. ■</p>

<p><em>Remark.</em> 엄밀히는 위의 증명이 PA 내에서 표현 가능함을 보여야 한다.</p>

<p>앞서 $\Sigma_1$ 명제는 참일 때 결정 가능하고, $\Pi_1$ 명제는 거짓일 때 결정 가능하다고 했다. 그런데 $\Sigma_2$ 문장은 $\forall$과 $\exists$가 섞여 있기 때문에, 참일 때에도, 거짓일 때에도 결정이 불가능한 문장이 있을 수 있다.</p>

<h3 id="31-오라클">3.1. 오라클</h3>

<blockquote>
  <p><strong>정의.</strong> $\mathcal{O}$가 단 한 번의 연산으로 문제 $P$의 결과를 구할 수 있을 때 $\mathcal{O}$을 $P$의 <strong>오라클</strong>이라고 한다.</p>
</blockquote>

<p>예를 들어 정지 문제의 오라클은 주어진 튜링 기계의 정지 연부를 단 한 번의 연산으로 알아낼 수 있는, 그야말로 신적인 존재다.</p>

<p>산술 위계를 오르는 것은 점점 더 강한 오라클이 주어지는 것과 같다. 앞서 $\Sigma_1$ 명제의 예시로 다음을 보았다.</p>

\[\phi_1(x): \exists y \;[ \mathrm{HaltsIn}(x, y) ]\]

<p>그런데 만약 정지 문제 오라클 $\mathcal{O}$가 주어졌다면, $\phi_1$은 $\Delta_0$ 명제로 단순하게 표현 가능하다.</p>

\[\phi_1(x) : \mathcal{O}(x)\]

<p>또한 앞서 $\Sigma_2$ 명제의 예시로 다음을 보았다.</p>

\[\phi_5(x) : \exists y \; [ \mathrm{DoesNotHaltOn}(x, y)]\]

<p>정지 문제 오라클 $\mathcal{O}$가 주어졌다면, $\phi_5$는 $\Sigma_1$ 명제로 표현 가능하다.</p>

\[\phi_5(x): \exists y \; \lnot \mathcal{O}(x|_y)\]

<p>여기서 $x|_y$는 괴델 수가 $x$인 튜링 기계에 $y$를 입력한 상태의 괴델 수이다. 즉, $\Sigma_2$ 명제는 정지 문제의 오라클이 주어졌을 때 $\Sigma_1$ 명제로 환원된다. 비슷한 원리로, $\Pi_2$ 명제와 $\Delta_2$ 명제는 각각 정지 문제의 오라클이 주어졌을 때 $\Pi_1$ 명제와 $\Delta_1$ 명제로 환원된다.</p>

<p>나아가 <strong>2차 오라클</strong>을 정의할 수 있다. 2차 정지 문제 오라클은, 정지 문제 오라클을 사용하는 튜링 기계들에 대한 정지 문제 오라클이다. 예를 들어 $\mathcal{O}$가 다음 코드의 정지 여부를 판단하는 데 그치는 데 반해,</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for x &gt; 0:
   for y &gt; 0:
      for z &gt; 0:
         for n &gt; 2:
            if x^n + y^n == z^n:
               return True;
return False;
</code></pre></div></div>

<p>$\mathcal{O}^2$은 다음 코드의 정지 여부를 판단할 수도 있다. 다음의 코드는 NP 튜링 기계의 괴델 수 $x$를 입력받았을 때, $x$와 출력이 일치하는 P 튜링 기계가 존재하면 정지하고 존재하지 않으면 정지하지 않는다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let x ∈ NP;
for y ∈ P:
   if !Halts(
      let z = 0
      while x(z) == y(z):
         z = z + 1
   ):
      return 1; // x가 P에 속하는 NP일 때 정지
</code></pre></div></div>

<p>일반적으로 다음이 성립한다.</p>

<blockquote>
  <p><strong>정리.</strong> $\Pi_n, \Sigma_n, \Delta_n$의 명제들은 $k$차 오라클이 주어졌을 때 각각 $\Pi_{n - k}, \Sigma_{n - k}, \Delta_{n - k}$의 명제들이 된다.</p>
</blockquote>

  </div>
  <div style="margin-bottom: 6em"></div>
  
    <div class="post fade-in-section" data-lang="en" style="display: none">
      <h1 class="post-title">
        <a href="/2025/02/07/arithmetic-hierarchy/en"> Arithmetic Hierarchy </a>
      </h1>
    <span class="post-date">07 Feb 2025</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/mathematics/'">
        Mathematics
      </div>
      
      <div class="tag" onclick="location.href='/tags/logic/'">
        Logic
      </div>
      
    </div>
     <blockquote>
  <p>This post was machine translated and has not yet been proofread. It may contain minor errors or unnatural expressions. Proofreading will be done in the near future.</p>
</blockquote>

<p><img src="/public/arithmetic-hierarchy.png" width="340px" style="margin: 2em auto;" /></p>

<blockquote>
  <p><strong>Warning.</strong> This article was written informally and may therefore lack rigour or even contain incorrect content.</p>
</blockquote>

<p>The <strong>arithmetic hierarchy</strong> is a classification of propositions in arithmetic — more precisely, first-order Peano arithmetic — according to the complexity of their quantifiers. The arithmetic hierarchy is a central concept in proof theory and computational complexity theory, and is also related to descriptive set theory.</p>

<h2 id="1-delta_0-propositions">1. $\Delta_0$ Propositions</h2>

<h3 id="11-definition">1.1. Definition</h3>

<blockquote>
  <p><strong>Definition.</strong> $\Sigma_0 = \Pi_0 = \Delta_0$ is the set of propositions containing only bounded quantifiers.</p>
</blockquote>

<p>Why the same class of propositions is referred to by three names will become clear shortly. In this article, unless there is a specific reason otherwise, we shall use $\Delta_0$ as the representative name amongst the three.</p>

<p>For example, the following four propositions are all $\Delta_0$ propositions.</p>

\[\begin{gather}
\phi_1 : 0 = 1\\
\phi_2(x) : \exists y &lt; x \; [y + y = x] \\
\phi_3(x, y) : \exists z \leq y \;[ xz = y ] \\
\end{gather}\]

<p>$\phi_1$ is a false statement. $\phi_2$ is true when $x$ is even, and $\phi_3$ is true when $x$ is a divisor of $y$.</p>

<p>Since $\Delta_0$ propositions have bounded quantifiers, it is possible to determine whether an arbitrary $x$ satisfies the corresponding proposition using a Turing machine. For instance, a Turing machine that determines whether $x$ satisfies $\phi_2$ is as follows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for y &lt; x:
   if y + y == x:
      return true;

return false;
</code></pre></div></div>

<p>The above Turing machine halts within $x$ iterations. Therefore, $\Delta_0$ propositions are <strong>decidable</strong>, <strong>recursive</strong>, or <strong>computable</strong> by mechanical devices such as Turing machines (the three expressions are synonymous). However, as we shall explain in detail later, not all decidable propositions are $\Delta_0$.</p>

<p>According to Gödel’s representability theorem, decidable true propositions are provable. In this article, when we say that $\phi$ is ‘true’, we mean $\mathcal{N} \vDash \phi$ for the standard natural number model $\mathcal{N}$, rather than $\mathsf{PA} \vDash \phi$. In other words, the following holds:</p>

<blockquote>
  <p><strong>Theorem.</strong> The set of true $\Delta_0$ sentences is complete. (That is, if $\phi$ is a true $\Delta_0$ sentence, then $\mathsf{PA} \vdash \phi$.)</p>
</blockquote>

<h3 id="12-delta_0-in-computational-theory">1.2. $\Delta_0$ in Computational Theory</h3>

<p>From a programming language perspective, $\Delta_0$ sentences correspond to the set of code that permits only the following:</p>

<ul>
  <li>Conditional statements</li>
  <li>Bounded loops</li>
  <li>Addition and multiplication</li>
</ul>

<p>It should be noted that <em>unbounded loops</em> and <em>variable reassignment</em> are not permitted. For example, the following code demonstrates that primality testing is $\Delta_0$:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for y &lt; x:
  for z &lt;= y:
    if yz == x:
      return false;

return true;
</code></pre></div></div>

<p>However, the following code that computes $x^y$ does not correspond to $\Delta_0$:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let a = 1
for 1&lt;= z &lt;= y:
   a = a * x

return a
</code></pre></div></div>

<p>So is exponentiation not $\Delta_0$? Not necessarily. Although complex, there are <a href="https://math.stackexchange.com/questions/5032077/how-to-express-exponentiation-with-a-delta-0-formula">methods</a> to express exponentiation with a $\Delta_0$ proposition. This case demonstrates that determining whether a given operation or predicate is $\Delta_0$ can be intricate. For instance, the following is known:</p>

<blockquote>
  <p><strong>Theorem.</strong> Factorial is $\Delta_0$, but tetration is not $\Delta_0$.</p>
</blockquote>

<p>However, tetration is decidable. Therefore, not all decidable propositions are $\Delta_0$.</p>

<h2 id="2-moving-up-one-level">2. Moving Up One Level</h2>

<blockquote>
  <p><strong>Definition.</strong></p>

\[\begin{gather}
\Sigma_1 := \{ \exists x_1 \cdots \exists x_n \;\phi : \phi \in \Pi_0 \}\\
\Pi_1 := \{ \forall x_1 \cdots \forall x_n \;\phi : \phi \in \Sigma_0 \}\\
\Delta_1 := \Sigma_1 \cap \Pi_1
\end{gather}\]
</blockquote>

<h3 id="21-sigma_1-propositions">2.1. $\Sigma_1$ Propositions</h3>

<p>The following propositions are $\Sigma_1$:</p>

\[\begin{gather}
\phi_1(x): \exists y \; \underbrace{[y^2 + y + 1 = x]}_{\Pi_0}\\
\phi_2(x): ∃y\; ∃z\; \underbrace{(y \text{ is prime} ∧ z \text{ is prime} ∧ x = y + z ∧ x \text{ is even})}_{\Pi_0}
\end{gather}\]

<p>$\phi_1$ is true in the set ${1, 3, 7, 13, \ldots}$. $\phi_2$ is Goldbach’s conjecture; it is not known whether all $x$ satisfy this.</p>

<p>$\Sigma_1$ is the collection of <strong>recursively enumerable</strong> sets. That is, if $\phi \in \Sigma_1$, then there exists a Turing machine $M$ such that:</p>

<ul>
  <li>If $\phi(c)$ is true, then $M$ is guaranteed to decide $\phi(c)$.</li>
  <li>If $\phi(c)$ is false, then $M$ is not guaranteed to decide $\phi(c)$.</li>
</ul>

<p>For example, the following Turing machine shows that $\phi_2$ is recursively enumerable:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for y &gt; 1:
   for z &gt; 1:
      if isPrime(y) &amp; isPrime(z) &amp; x = y + z &amp; isEven(x):
         return true;

return false;
</code></pre></div></div>

<p>Although there is a <code class="language-plaintext highlighter-rouge">return false</code> statement, since there is no <code class="language-plaintext highlighter-rouge">break</code> statement to exit the loop, <code class="language-plaintext highlighter-rouge">return false</code> is unreachable. That is, if $\phi_2(c)$ is true, the above Turing machine returns true, but if it is false, it falls into an infinite loop.</p>

<p>If $\phi \in \Sigma_1$ is a sentence that is true in the standard natural number model, then $\mathsf{PA} \vdash \phi$. A proposition of the form $\phi : \exists x \; \psi(x)$ being true in the standard natural number model means that $\psi(c)$ is true for some $c \in \mathbb{N}$, and since $\psi(c)$ is a true $\Pi_0$ sentence, it is provable. Therefore, the following holds:</p>

<blockquote>
  <p><strong>Theorem.</strong> The set of true $\Sigma_1$ sentences is complete.</p>
</blockquote>

<h3 id="22-sigma_1-setminus-delta_0-propositions">2.2. $\Sigma_1 \setminus \Delta_0$ Propositions</h3>

<p>However, I have in fact been misleading the reader thus far. The propositions I listed earlier as examples of $\Sigma_1$ can actually be written as $\Delta_0$:</p>

\[\begin{gather}
\phi_1: \exists y&lt;x \;{[y^2 + y + 1 = x]}\\
\phi_2(x): ∃y&lt;x\; ∃z&lt;x\; {(y \text{ is prime} ∧ z \text{ is prime} ∧ x = y + z ∧ x \text{ is even})}
\end{gather}\]

<p>So what do $\Sigma_1$ propositions that do not belong to $\Delta_0$ look like? One answer can be found in the <strong>halting problem</strong>.</p>

<p>First, let $\mathrm{HaltsIn}(x, n)$ be a predicate that determines whether “the Turing machine with Gödel number $x$” produces an output within $n$ operations. This predicate can be easily defined from the <strong>Kleene predicate</strong>, and the Kleene predicate is known to be $\Sigma_0$. For example, if the Gödel number of a Turing machine that computes the square of 3 in 2 operations is $123$, then $\mathrm{HaltsIn}(123, 3)$ is true but $\mathrm{HaltsIn}(123, 1)$ is false.</p>

<p>Now consider the following proposition:</p>

\[\phi_1(x): \exists y \;[ \mathrm{HaltsIn}(x, y) ]\]

<p>What this proposition states is that the Turing machine with Gödel number $x$ eventually halts. That is, the above proposition is equivalent to the halting problem. However, the halting problem is undecidable. Since we showed earlier that all $\Delta_0$ propositions are decidable, $\phi$ is a $\Sigma_1$ proposition that does not belong to $\Delta_0$.</p>

<p>As another example, consider the following proposition:</p>

\[\phi_2(x): \exists y \; [ \mathrm{Proves}(x, y) ]\]

<p>Here, $\mathrm{Proves}(x, y)$ is a predicate that is true when the Gödel number of “a proof of the sentence with Gödel number $x$” is $y$. That is, $\phi_2(x)$ is a predicate stating that the sentence with Gödel number $x$ is provable. However, this predicate is not decidable. If $\phi_2$ were decidable, then (under the assumption that PA is consistent) there would exist a proof in PA that $\phi_2(\ulcorner 0 = 1 \urcorner)$ is false, which would conflict with Gödel’s incompleteness theorem.</p>

<h3 id="23-pi_1-propositions">2.3. $\Pi_1$ Propositions</h3>

<p>If $\Sigma_1$ propositions are the collection of recursively enumerable propositions, then $\Pi_1$ propositions are the collection of <strong>co-recursively enumerable</strong> propositions. That is, a $\Pi_1$ sentence is decidable if false, but decidability is not guaranteed if true. For example, the following two propositions are $\Pi_1$ sentences that are not $\Delta_0$:</p>

\[\begin{gather}
\phi_3(x): \forall y \;[ \lnot \mathrm{HaltsIn}(x, y) ] \\
\phi_4(x): \forall y \; [ \lnot \mathrm{Proves}(x, y) ]
\end{gather}\]

<p>Unlike the case of $\Sigma_1$, $\Pi_1$ is not complete. Since the negation of a $\Sigma_1$ sentence is $\Pi_1$, if $\Pi_1$ were also complete, then $\Sigma_1 = \Pi_1 =$ (collection of decidable propositions).</p>

<blockquote>
  <p><strong>Theorem.</strong> The set of true $\Pi_1$ sentences is not complete.</p>
</blockquote>

<h3 id="24-delta_1-propositions">2.4. $\Delta_1$ Propositions</h3>

<p>$\Delta_1$ propositions belong to both $\Sigma_1$ and $\Pi_1$. Therefore, $\Delta_1$ is the collection of <strong>decidable</strong> propositions. The tetration we saw earlier is a $\Delta_1$ proposition that is not $\Delta_0$.</p>

<h2 id="3-moving-up-another-level">3. Moving Up Another Level</h2>

<blockquote>
  <p><strong>Definition.</strong></p>

\[\begin{gather}
\Sigma_2 := \{ \exists x_1 \cdots \exists x_n \;\phi : \phi \in \Pi_1 \}\\
\Pi_2 := \{ \forall x_1 \cdots \forall x_n \;\phi : \phi \in \Sigma_1 \}\\
\Delta_2 := \Sigma_2 \cap \Pi_2
\end{gather}\]
</blockquote>

<p>I believe the pattern should now be visible. As an example of a $\Sigma_2$ proposition, consider the following:</p>

\[\phi_5(x) : \exists y \; [ \mathrm{DoesNotHaltOn}(x, y)]\]

<p>Here, $\mathrm{DoesNotHaltOn}(x, y)$ is a predicate that is true if “the Turing machine with Gödel number $x$” does not halt when given input $y$. From the preceding discussion, it is not difficult to see that $\mathrm{DoesNotHaltOn}$ is $\Pi_1$.</p>

<blockquote>
  <p><strong>Theorem.</strong> $\phi_5 \notin \Pi_1$</p>
</blockquote>

<p><strong>Proof.</strong> Suppose $\phi_5 \in \Pi_1$. Our goal is to show that this assumption implies “the set of true $\Pi_1$ sentences is complete”.</p>

<p>Let $\psi(x)$ be an arbitrary $\Delta_0$ proposition. Then $\theta : \forall x \;\psi(x)$ is a $\Pi_1$ sentence. Consider the following Turing machine $M$:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if ψ(x):
   return 1;

while True:
</code></pre></div></div>

<p>This Turing machine halts for value $x$ if $\psi(x)$ is true and does not halt if it is false. Therefore, $\theta$ being true is equivalent to $M$ halting for all $x$, which is equivalent to $\phi_5(\ulcorner M \urcorner)$ being false. By assumption, $\phi_5 \in \Pi_1$, so if $\phi_5(\ulcorner M \urcorner)$ is false, then $\mathsf{PA} \vdash \lnot \phi(\ulcorner M \urcorner)$. That is, $\mathsf{PA} \vdash \theta$, making all true $\Pi_1$ sentences provable. This is a contradiction. ■</p>

<p><em>Remark.</em> Strictly speaking, one should show that the above proof is expressible within PA.</p>

<p>We said earlier that $\Sigma_1$ propositions are decidable when true, and $\Pi_1$ propositions are decidable when false. However, since $\Sigma_2$ sentences have mixed $\forall$ and $\exists$ quantifiers, there may be sentences that are undecidable both when true and when false.</p>

<h3 id="31-oracles">3.1. Oracles</h3>

<blockquote>
  <p><strong>Definition.</strong> When $\mathcal{O}$ can obtain the result of problem $P$ in a single operation, we call $\mathcal{O}$ an <strong>oracle</strong> for $P$.</p>
</blockquote>

<p>For example, an oracle for the halting problem is a truly divine entity that can determine whether a given Turing machine halts in a single operation.</p>

<p>Ascending the arithmetic hierarchy is equivalent to being given increasingly powerful oracles. We saw earlier the following as an example of a $\Sigma_1$ proposition:</p>

\[\phi_1(x): \exists y \;[ \mathrm{HaltsIn}(x, y) ]\]

<p>However, if a halting problem oracle $\mathcal{O}$ were given, $\phi_1$ could be expressed simply as a $\Delta_0$ proposition:</p>

\[\phi_1(x) : \mathcal{O}(x)\]

<p>Also, we saw earlier the following as an example of a $\Sigma_2$ proposition:</p>

\[\phi_5(x) : \exists y \; [ \mathrm{DoesNotHaltOn}(x, y)]\]

<p>If a halting problem oracle $\mathcal{O}$ were given, $\phi_5$ could be expressed as a $\Sigma_1$ proposition:</p>

\[\phi_5(x): \exists y \; \lnot \mathcal{O}(x|_y)\]

<table>
  <tbody>
    <tr>
      <td>Here, $x</td>
      <td>_y$ is the Gödel number of the state where input $y$ is given to the Turing machine with Gödel number $x$. That is, $\Sigma_2$ propositions reduce to $\Sigma_1$ propositions when given an oracle for the halting problem. By similar principles, $\Pi_2$ and $\Delta_2$ propositions reduce to $\Pi_1$ and $\Delta_1$ propositions, respectively, when given an oracle for the halting problem.</td>
    </tr>
  </tbody>
</table>

<p>Furthermore, we can define <strong>second-order oracles</strong>. A second-order halting problem oracle is a halting problem oracle for Turing machines that use halting problem oracles. For example, whilst $\mathcal{O}$ is limited to determining whether the following code halts:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for x &gt; 0:
   for y &gt; 0:
      for z &gt; 0:
         for n &gt; 2:
            if x^n + y^n == z^n:
               return True;
return False;
</code></pre></div></div>

<p>$\mathcal{O}^2$ can also determine whether the following code halts. The following code takes as input the Gödel number $x$ of an NP Turing machine, halts if there exists a P Turing machine whose output matches $x$, and does not halt if no such machine exists:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let x ∈ NP;
for y ∈ P:
   if !Halts(
      let z = 0
      while x(z) == y(z):
         z = z + 1
   ):
      return 1; // halts when x is an NP that belongs to P
</code></pre></div></div>

<p>In general, the following holds:</p>

<blockquote>
  <p><strong>Theorem.</strong> Propositions in $\Pi_n$, $\Sigma_n$, $\Delta_n$ become propositions in $\Pi_{n-k}$, $\Sigma_{n-k}$, $\Delta_{n-k}$, respectively, when given a $k$-th order oracle.</p>
</blockquote>

  </div>
  <div style="margin-bottom: 6em"></div>
  
    <div class="post fade-in-section" data-lang="ko" style="display: none">
      <h1 class="post-title">
        <a href="/2025/02/05/order"> 곱군과 위수에 관한 노트: 페르마 소수 정리와 윌슨의 정리 </a>
      </h1>
    <span class="post-date">05 Feb 2025</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/수학/'">
        수학
      </div>
      
      <div class="tag" onclick="location.href='/tags/대수학/'">
        대수학
      </div>
      
    </div>
     <h3 id="remarks">Remarks</h3>

<table>
  <thead>
    <tr>
      <th><strong>곱군</strong></th>
      <th><strong>합군</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1이 항등원</td>
      <td>0이 항등원</td>
    </tr>
    <tr>
      <td>$x$의 위수가 $r$일 때, $x^r = 1$</td>
      <td>$x$의 위수가 $r$일 때, $rx = 0$</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>소수 $p$에 대해 $p - 1$에 대한 정보가 주어졌다면 위수가 $p - 1$인 곱군 $(\mathbb{Z}/p\mathbb{Z})^\times$을 생각해 보자.</li>
  <li>유한체의 곱군은 순환군이다.</li>
  <li>순환적 곱군 $G$에 대해 $nm \mid |G|$는, $x^{nm} = 1$이지만 $x^n, x^m \neq 1$인 원소 $x$의 존재성과 동치이다.</li>
  <li>위수는 주기와 다르다. 일반적으로 <strong>(주기) = (위수) + 1</strong>이다.</li>
</ul>

<h3 id="페르마-소수-정리">페르마 소수 정리</h3>

<blockquote>
  <p><strong>정리.</strong> 소수 $p$가 두 정수 $a, b$에 대해 $p = a^2 + b^2$ 꼴로 나타내어질 필요충분조건은 $p \bmod 1 = 4$인 것이다.</p>
</blockquote>

<p><strong>증명.</strong></p>

<p>(⇒) 자명</p>

<p>(⇐) $G = (\mathbb{Z}/p\mathbb{Z})^\times$라고 하자. 조건에 의해 $4 \mid |G|$이다. 따라서 $n^4 = 1$이지만 $n^2 \neq 1$인 원소 $n$이 존재한다. 즉, $n^2 = -1$이다. 따라서 $p \mid n^2 + 1$이다. 이제 $\mathbb{Z}[i]$에서 생각해 보면 $p \mid (n + i)(n - i)$이다. 만약 $p$가 $\mathbb{Z}[i]$에서 기약이었다면 $p \mid n + i$ 또는 $p \mid n - i$인데 둘 다 불가능하다. 따라서 $p$는 기약이 아니며, 켤레성에 의해</p>

\[p = (a + bi)(a - bi) = a^2 + b^2\]

<p>이다. ■</p>

<h3 id="윌슨의-정리">윌슨의 정리</h3>

<blockquote>
  <p><strong>정리.</strong> $p$가 소수일 필요충분조건은 $(p - 1)! \equiv -1 \mod p$인 것이다.</p>
</blockquote>

<p><strong>증명.</strong></p>

<p>(⇒) $G = (\mathbb{Z}/p\mathbb{Z})^\times$라고 하자. $G$의 원소를 모두 곱한 값은 $(p - 1)!$이다. $x^2 = 1$의 근인 $\pm 1$을 제외한 $G$의 모든 원소는 자기 자신을 역원으로 가지지 않는다. 따라서 $(p - 1)! \equiv -1$이다.</p>

<p>(⇐) $N = (p - 1)! + 1$이라고 하자. 조건에 의해 $p \mid N$이다. 만약 $p$가 소수가 아니라면 어떤 소수 $q &lt; p$에 대해 $q \mid N$이다. 그러나 $N \bmod q = 1$이므로 모순이다. ■</p>

  </div>
  <div style="margin-bottom: 6em"></div>
  
    <div class="post fade-in-section" data-lang="en" style="display: none">
      <h1 class="post-title">
        <a href="/2025/02/05/order/en"> Notes on Multiplicative Groups and Order: Fermat's Theorem on Primes and Wilson's Theorem </a>
      </h1>
    <span class="post-date">05 Feb 2025</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/mathematics/'">
        Mathematics
      </div>
      
      <div class="tag" onclick="location.href='/tags/algebra/'">
        Algebra
      </div>
      
    </div>
     <blockquote>
  <p>This post was machine translated and has not yet been proofread. It may contain minor errors or unnatural expressions. Proofreading will be done in the near future.</p>
</blockquote>

<h3 id="remarks">Remarks</h3>

<table>
  <thead>
    <tr>
      <th><strong>Multiplicative Group</strong></th>
      <th><strong>Additive Group</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1 is the identity element</td>
      <td>0 is the identity element</td>
    </tr>
    <tr>
      <td>When the order of $x$ is $r$, $x^r = 1$</td>
      <td>When the order of $x$ is $r$, $rx = 0$</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>For a prime $p$, if information about $p - 1$ is given, consider the multiplicative group $(\mathbb{Z}/p\mathbb{Z})^\times$ of order $p - 1$.</li>
  <li>The multiplicative group of a finite field is cyclic.</li>
  <li>For a cyclic multiplicative group $G$, $nm \mid |G|$ is equivalent to the existence of an element $x$ such that $x^{nm} = 1$ but $x^n, x^m \neq 1$.</li>
  <li>Order is different from period. In general, <strong>(period) = (order) + 1</strong>.</li>
</ul>

<h3 id="fermats-theorem-on-primes">Fermat’s Theorem on Primes</h3>

<blockquote>
  <p><strong>Theorem.</strong> A prime $p$ can be expressed in the form $p = a^2 + b^2$ for two integers $a, b$ if and only if $p \equiv 1 \pmod{4}$.</p>
</blockquote>

<p><strong>Proof.</strong></p>

<p>(⇒) Trivial.</p>

<p>(⇐) Let $G = (\mathbb{Z}/p\mathbb{Z})^\times$. By the condition, $4 \mid |G|$. Therefore, there exists an element $n$ such that $n^4 = 1$ but $n^2 \neq 1$. That is, $n^2 = -1$. Hence, $p \mid n^2 + 1$. Now, considering in $\mathbb{Z}[i]$, we have $p \mid (n + i)(n - i)$. If $p$ were irreducible in $\mathbb{Z}[i]$, then $p \mid n + i$ or $p \mid n - i$, but both are impossible. Therefore, $p$ is not irreducible, and by conjugacy,</p>

\[p = (a + bi)(a - bi) = a^2 + b^2\]

<p>■</p>

<h3 id="wilsons-theorem">Wilson’s Theorem</h3>

<blockquote>
  <p><strong>Theorem.</strong> $p$ is prime if and only if $(p - 1)! \equiv -1 \pmod{p}$.</p>
</blockquote>

<p><strong>Proof.</strong></p>

<p>(⇒) Let $G = (\mathbb{Z}/p\mathbb{Z})^\times$. The product of all elements of $G$ is $(p - 1)!$. Except for $\pm 1$, which are the roots of $x^2 = 1$, all other elements of $G$ do not have themselves as their inverse. Therefore, $(p - 1)! \equiv -1$.</p>

<p>(⇐) Let $N = (p - 1)! + 1$. By the condition, $p \mid N$. If $p$ were not prime, then for some prime $q &lt; p$, we would have $q \mid N$. However, $N \equiv 1 \pmod{q}$, which is a contradiction. ■</p>


  </div>
  <div style="margin-bottom: 6em"></div>
  
    <div class="post fade-in-section" data-lang="ko" style="display: none">
      <h1 class="post-title">
        <a href="/2025/01/25/beta-function"> 베타 함수를 통한 페아노 산술에서의 괴델 수 정의 </a>
      </h1>
    <span class="post-date">25 Jan 2025</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/수학/'">
        수학
      </div>
      
      <div class="tag" onclick="location.href='/tags/논리학/'">
        논리학
      </div>
      
    </div>
     <p><strong>요약.</strong> 1차 페아노 산술은 술어에 대한 양화를 허용하지 않기 때문에 덧셈과 곱셈 공리를 별도로 요구한다. 그러나 지수나 계승 등의 추가적인 연산은 — 튜플을 페아노 산술에서 정의할 수 있는 한 — 별도의 공리 없이 정의 가능하다. 그리고 튜플은 베타 암호화를 통해 페아노 산술에서 정의 가능하기 때문에, 페아노 산술은 지수, 계승, 소인수분해, 나아가 괴델 수까지 형식화할 수 있다.</p>

<h2 id="1-서론">1. 서론</h2>

<blockquote>
  <p><strong>정의.</strong> <strong>페아노 산술(Peano arithmetics, PA)</strong>은 $(0, S, +, \cdot)$를 부호수(signature)로 가지는 이론으로, 공리는 다음과 같다.</p>

  <ol>
    <li>$\forall x : S(x) \neq 0$</li>
    <li>$\forall x, y : S(x) = S(y) \rightarrow x = y$</li>
    <li>$\forall x : x + 0 = x$</li>
    <li>$\forall x, y : x + S(y) = S(x + y)$</li>
    <li>$\forall x, y : x \cdot 0 = 0$</li>
    <li>$\forall x, y : x \cdot S(y) = (x \cdot y) + x$</li>
  </ol>

  <p>추가로 다음의 귀납 공리꼴(axiom schema)을 가진다. 임의의 1차 논리식 $\phi(x)$에 대해,</p>

  <p> 7. $\big[ \phi(0) \land \forall x \; [ \phi(x) \rightarrow \phi(S(x)) ] \big] \rightarrow \forall x \;\phi(x)$</p>
</blockquote>

<p>추가적으로 편의를 위해 $&lt;, -, \bmod$를 다음과 같이 정의한다.</p>

\[\begin{aligned}
&amp;x &lt; y : &amp;&amp;\exists z \neq 0\; [x + z = y]\\
&amp;x - y = z : &amp;&amp;x = y + z \\
&amp;x \bmod y = z: &amp;&amp; (z &lt; y) \land \exists q \;[ qy + z = x ]
\end{aligned}\]

<p>역사적으로 데데킨트가 처음 제시한 페아노 산술은 2차 논리 이론이었기 때문에 귀납 <em>공리꼴</em> 대신 귀납 <em>공리</em>가 있었다. 또한 3번부터 7번 공리가 없었다.</p>

<blockquote>
  <p><strong>정의.</strong> <strong>2차 논리 페아노 산술</strong>은 $(0, S)$를 부호수(signature)로 가지는 이론으로, 공리는 다음과 같다.</p>

  <ol>
    <li>$\forall x : S(x) \neq 0$</li>
    <li>$\forall x, y : S(x) = S(y) \rightarrow x = y$</li>
    <li>$\forall \phi \bigg[ \big[ \phi(0) \land \forall x \; [ \phi(x) \rightarrow \phi(S(x)) ] \big] \rightarrow \forall x \;\phi(x)\bigg]$</li>
  </ol>
</blockquote>

<p>나머지 공리가 불필요한 이유는, 2차 논리는 술어에 대한 양화를 허용하기 때문에 2차 논리식만으로 덧셈과 곱셈을 정의할 수 있기 때문이다. 예를 들어 $w = u + v$는 다음 논리식과 동치이다.</p>

\[\forall \phi \bigg[ \forall x, y, z \big[ \phi(x, 0, x) \land (\phi(x, S(y), z) \rightarrow \phi(x, y, S(z)) \big] \rightarrow \phi(u, v, w) \bigg]\]

<p>그러나 2차 논리는 수많은 수학적 · 철학적 허점을 가지는 것으로 드러났기 때문에 서두에서 소개한 1차 논리 페아노 산술이 표준으로 선택되었다. 이 선택의 함의는 첫째로 귀납 공리가 귀납 공리꼴이 된다는 것이고, 둘째는 덧셈과 곱셈을 별도의 공리를 통해 정의해야 한다는 것이다.</p>

<p>그런데 이런 의문이 남는다. 덧셈과 곱셈 말고 다른 연산은 따로 정의할 필요가 없는 것일까? 예를 들어 지수, 소인수분해, 계승과 같은 연산은 별도의 공리 없이 정의 가능할까? 나아가, 임의의 논리식을 자연수에 대응시키는 괴델 수 기법은 페아노 산술만으로 정의 가능할까?</p>

<h2 id="2-튜플">2. 튜플</h2>

<p>이 의문에 답하는 혜안은, <strong>튜플</strong>을 페아노 산술에서 정의할 수 있다면 기타 수많은 연산이 정의 가능해진다는 사실이다. 여기서 튜플이란 $(1, 4, 2)$와 같은 유한한 자연수의 나열을 말한다.</p>

<p>일례로 다음과 같은 술어와 함수들이 정의되어 있다고 가정하자.</p>

<ul>
  <li>$\mathrm{Tup}(\tau):$ $\tau$가 튜플이다.</li>
  <li>$\mathrm{At}(\tau, i):$ $\tau$가 튜플일 때, $\tau$의 $i$번째 자연수를 반환한다.</li>
  <li>$\mathrm{Len}(\tau):$ $\tau$의 길이를 반환한다.</li>
</ul>

<p>편의를 위해 $\mathrm{At}(\tau, i)$를 $\tau[i]$로 쓰도록 하자. 예를 들어 $\tau = (1, 4, 2)$라면 다음이 성립한다. (인덱스는 0부터 시작하는 것으로 생각한다)</p>

\[\mathrm{Tup}(\tau) \; \land \;  \mathrm{Len}(\tau) = 3 \;\land\; \tau[1] = 4\]

<p>튜플을 사용하면 다음과 같이 $z = x^y$를 정의할 수 있다.</p>

\[\forall \tau \bigg[ \big[ \mathrm{Tup}(\tau)\; \land \; \tau[0] = 1 \;\land \forall i &lt; y (\tau[i + 1] = \tau[i] \cdot x) \big] \rightarrow \tau[y] = z \bigg]\]

<h2 id="3-베타-암호화">3. 베타 암호화</h2>

<p>그렇다면 튜플을 덧셈과 곱셈, 그리고 1차 논리식만으로 정의할 수 있을까? 이에 대한 답은 <strong>“가능하다”</strong>이다. 아니나다를까역시나적시나 이 결과를 처음 증명한 사람은 괴델이다. 먼저 다음의 정리를 상기하자.</p>

<blockquote>
  <p><strong>중국인의 나머지 정리.</strong> $(n_1, \dots, n_k)$가 켤레서로소(pairwise coprime)라고 하자. $0 \leq r_i &lt; n_i$인 임의의 $(r_1, \dots, r_k)$에 대해 다음을 만족하는 수 $x$가 언제나 존재한다.</p>

\[x \bmod n_i = r_i\]
</blockquote>

<p>괴델의 아이디어는 중국인의 나머지 정리에서 $x$에 해당하는 수를 튜플 $(r_1, \dots, r_k)$의 코드로 생각하는 것이다. 그런데 여기에는 문제가 있다. $x$로부터 $(r_1, \dots, r_k)$를 복호화하기 위해서는 $(n_1, \dots, n_k)$가 주어져야 하는데, 이는 또다시 튜플을 요구하기 때문이다.</p>

<p>이 문제를 해결하기 위해 괴델은 다음의 보조정리를 꺼내든다.</p>

<blockquote>
  <p><strong>보조정리.</strong> $n!+ 1, 2n! + 1, \dots, n \cdot n! + 1$은 켤레서로소이다.</p>
</blockquote>

<p><strong>증명.</strong> $1 \leq a &lt; b \leq n$에 대해 $u = an! + 1, v = bn! + 1$이라고 하자. 유클리드 호제법에 의해,</p>

\[\mathrm{gcd}(u, v) = \mathrm{gcd}(u, v - u) = \mathrm{gcd}(an! + 1, (b - a)n!)\]

<p>이다. $(b - a)n!$의 모든 약수의 집합은 $\lbrace  1, 2, \dots, n\rbrace $이다. 그런데 이중 어느 원소도 $an! + 1$의 약수가 아니므로 $\mathrm{gcd}(an! + 1, (b - a)n!) = \mathrm{gcd}(u, v) = 1$이다. □</p>

<p>이제 우리는 튜플을 <strong>순서쌍</strong>으로서 정의할 수 있다.</p>

<blockquote>
  <p><strong>정의.</strong> 튜플 $(r_1, \dots, r_k)$를 다음과 같이 순서쌍 $\langle a, b \rangle$로 표현한다.</p>

  <ul>
    <li>$b = n! \quad \text{where} \quad n = \max(r_1, \dots, r_k, k)$</li>
    <li>$a \bmod (kb + 1) = r_k$</li>
  </ul>

  <p>단, $a$는 2번 조건을 만족하는 자연수 중 가장 작은 자연수로 선택한다.</p>
</blockquote>

<p>한편 튜플은 칸토어 대응을 통해 자연수로 표현이 가능하다.</p>

<blockquote>
  <p><strong>정의.</strong></p>

\[\langle a, b \rangle = \frac{(a + b)(a + b + 1)}{2} + b\]
</blockquote>

<p>이로써 우리는 튜플 $\tau$를 자연수 $n$으로 암호화(coding)할 수 있다. 그리고 역으로 $n$이 주어지면 덧셈, 곱셈, 그리고 나머지 연산만을 사용하여 $\tau$를 복호화해낼 수 있다. 그리고 나머지 연산은 덧셈, 곱셈, 그리고 1차 논리로부터 쉽게 정의가 가능하므로, 목표가 달성되었다.</p>

<p>역사적으로 괴델이 증명한 정리는 다음과 같다.</p>

<blockquote>
  <p><strong>$\beta$-함수 보조정리.</strong> 임의의 자연수열 $(n_1, \dots, n_k)$에 대해, 어떤 자연수 $a, b$가 존재하여 $1 \leq i \leq k$에 대해 $\beta(a, b, i) = n_i$이다. 여기서 $\beta$는 다음과 같이 정의된 함수이다.</p>

\[\beta(x, y, i) = x \bmod (iy + 1)\]
</blockquote>

<p>이런 이유로 지금까지의 과정을 <strong>베타 암호화(Beta coding)</strong>라고 부른다. 괴델은 베타 암호화를 이용하여 지수 연산과 소인수분해를 PA에서 성공적으로 정의했으며, 이로부터 괴델 수와 비롯된 여러 술어를 PA에서 형식화할 수 있었다. 제목에서 드러나다시피 원래 이 글의 목표는 이 과정을 모두 개괄하는 것이었으나 때늦게 찾아온 필자의 귀찮음 이슈와, 글을 여기까지 읽은 독자라면 이후 내용은 어렵지 않게 유추 가능하리라는 생각으로 이만 줄인다.</p>

  </div>
  <div style="margin-bottom: 6em"></div>
  
    <div class="post fade-in-section" data-lang="en" style="display: none">
      <h1 class="post-title">
        <a href="/2025/01/25/beta-function/en"> Defining Gödel Numbers in Peano Arithmetic via the Beta Function </a>
      </h1>
    <span class="post-date">25 Jan 2025</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/mathematics/'">
        Mathematics
      </div>
      
      <div class="tag" onclick="location.href='/tags/logic/'">
        Logic
      </div>
      
    </div>
     <blockquote>
  <p>This post was machine translated and has not yet been proofread. It may contain minor errors or unnatural expressions. Proofreading will be done in the near future.</p>
</blockquote>

<p><strong>Abstract.</strong> First-order Peano arithmetic does not permit quantification over predicates, hence it requires separate axioms for addition and multiplication. However, additional operations such as exponentiation and factorial—provided that tuples can be defined in Peano arithmetic—are definable without separate axioms. Since tuples are definable in Peano arithmetic through beta encoding, Peano arithmetic can formalise exponentiation, factorial, prime factorisation, and ultimately Gödel numbers.</p>

<h2 id="1-introduction">1. Introduction</h2>

<blockquote>
  <p><strong>Definition.</strong> <strong>Peano arithmetic (PA)</strong> is a theory with signature $(0, S, +, \cdot)$, where the axioms are as follows:</p>

  <ol>
    <li>$\forall x : S(x) \neq 0$</li>
    <li>$\forall x, y : S(x) = S(y) \rightarrow x = y$</li>
    <li>$\forall x : x + 0 = x$</li>
    <li>$\forall x, y : x + S(y) = S(x + y)$</li>
    <li>$\forall x, y : x \cdot 0 = 0$</li>
    <li>$\forall x, y : x \cdot S(y) = (x \cdot y) + x$</li>
  </ol>

  <p>Additionally, it has the following induction axiom schema. For any first-order formula $\phi(x)$:</p>

  <p> 7. $\big[ \phi(0) \land \forall x \; [ \phi(x) \rightarrow \phi(S(x)) ] \big] \rightarrow \forall x \;\phi(x)$</p>
</blockquote>

<p>For convenience, we define $&lt;, -, \bmod$ as follows:</p>

\[\begin{aligned}
&amp;x &lt; y : &amp;&amp;\exists z \neq 0\; [x + z = y]\\
&amp;x - y = z : &amp;&amp;x = y + z \\
&amp;x \bmod y = z: &amp;&amp; (z &lt; y) \land \exists q \;[ qy + z = x ]
\end{aligned}\]

<p>Historically, the Peano arithmetic first presented by Dedekind was a second-order logic theory, hence it had an induction <em>axiom</em> rather than an induction <em>axiom schema</em>. Moreover, it lacked axioms 3 through 7.</p>

<blockquote>
  <p><strong>Definition.</strong> <strong>Second-order Peano arithmetic</strong> is a theory with signature $(0, S)$, where the axioms are as follows:</p>

  <ol>
    <li>$\forall x : S(x) \neq 0$</li>
    <li>$\forall x, y : S(x) = S(y) \rightarrow x = y$</li>
    <li>$\forall \phi \bigg[ \big[ \phi(0) \land \forall x \; [ \phi(x) \rightarrow \phi(S(x)) ] \big] \rightarrow \forall x \;\phi(x)\bigg]$</li>
  </ol>
</blockquote>

<p>The reason the remaining axioms are unnecessary is that second-order logic permits quantification over predicates, enabling addition and multiplication to be defined using second-order formulae alone. For instance, $w = u + v$ is equivalent to the following formula:</p>

\[\forall \phi \bigg[ \forall x, y, z \big[ \phi(x, 0, x) \land (\phi(x, S(y), z) \rightarrow \phi(x, y, S(z)) \big] \rightarrow \phi(u, v, w) \bigg]\]

<p>However, since second-order logic was found to have numerous mathematical and philosophical shortcomings, the first-order Peano arithmetic introduced at the beginning became the standard choice. The implications of this choice are, firstly, that the induction axiom becomes an induction axiom schema, and secondly, that addition and multiplication must be defined through separate axioms.</p>

<p>This raises the question: are there no other operations besides addition and multiplication that need separate definition? For example, can operations such as exponentiation, prime factorisation, and factorial be defined without additional axioms? Furthermore, can Gödel numbering techniques, which map arbitrary formulae to natural numbers, be defined using Peano arithmetic alone?</p>

<h2 id="2-tuples">2. Tuples</h2>

<p>The insight that answers this question is that if <strong>tuples</strong> can be defined in Peano arithmetic, then numerous other operations become definable. Here, a tuple refers to a finite sequence of natural numbers such as $(1, 4, 2)$.</p>

<p>For instance, suppose the following predicates and functions are defined:</p>

<ul>
  <li>$\mathrm{Tup}(\tau):$ $\tau$ is a tuple.</li>
  <li>$\mathrm{At}(\tau, i):$ When $\tau$ is a tuple, returns the $i$-th natural number of $\tau$.</li>
  <li>$\mathrm{Len}(\tau):$ Returns the length of $\tau$.</li>
</ul>

<p>For convenience, let us write $\mathrm{At}(\tau, i)$ as $\tau[i]$. For example, if $\tau = (1, 4, 2)$, then the following holds (assuming indexing starts from 0):</p>

\[\mathrm{Tup}(\tau) \; \land \;  \mathrm{Len}(\tau) = 3 \;\land\; \tau[1] = 4\]

<p>Using tuples, we can define $z = x^y$ as follows:</p>

\[\forall \tau \bigg[ \big[ \mathrm{Tup}(\tau)\; \land \; \tau[0] = 1 \;\land \forall i &lt; y (\tau[i + 1] = \tau[i] \cdot x) \big] \rightarrow \tau[y] = z \bigg]\]

<h2 id="3-beta-encoding">3. Beta Encoding</h2>

<p>Can tuples be defined using only addition, multiplication, and first-order formulae? The answer is <strong>“yes”</strong>. As might be expected, it was Gödel who first proved this result. Let us first recall the following theorem:</p>

<blockquote>
  <p><strong>Chinese Remainder Theorem.</strong> Let $(n_1, \dots, n_k)$ be pairwise coprime. For any $(r_1, \dots, r_k)$ with $0 \leq r_i &lt; n_i$, there always exists a number $x$ satisfying:</p>

\[x \bmod n_i = r_i\]
</blockquote>

<p>Gödel’s idea was to think of the number $x$ from the Chinese Remainder Theorem as a code for the tuple $(r_1, \dots, r_k)$. However, there is a problem here. To decode $(r_1, \dots, r_k)$ from $x$, we need $(n_1, \dots, n_k)$ to be given, which again requires a tuple.</p>

<p>To solve this problem, Gödel produced the following lemma:</p>

<blockquote>
  <p><strong>Lemma.</strong> $n!+ 1, 2n! + 1, \dots, n \cdot n! + 1$ are pairwise coprime.</p>
</blockquote>

<p><strong>Proof.</strong> For $1 \leq a &lt; b \leq n$, let $u = an! + 1, v = bn! + 1$. By the Euclidean algorithm,</p>

\[\mathrm{gcd}(u, v) = \mathrm{gcd}(u, v - u) = \mathrm{gcd}(an! + 1, (b - a)n!)\]

<p>The set of all divisors of $(b - a)n!$ is $\lbrace  1, 2, \dots, n\rbrace $. Since none of these elements divides $an! + 1$, we have $\mathrm{gcd}(an! + 1, (b - a)n!) = \mathrm{gcd}(u, v) = 1$. □</p>

<p>We can now define tuples as <strong>ordered pairs</strong>.</p>

<blockquote>
  <p><strong>Definition.</strong> We represent the tuple $(r_1, \dots, r_k)$ as an ordered pair $\langle a, b \rangle$ as follows:</p>

  <ul>
    <li>$b = n! \quad \text{where} \quad n = \max(r_1, \dots, r_k, k)$</li>
    <li>$a \bmod (kb + 1) = r_k$</li>
  </ul>

  <p>where $a$ is chosen to be the smallest natural number satisfying the second condition.</p>
</blockquote>

<p>Meanwhile, tuples can be represented as natural numbers through Cantor pairing.</p>

<blockquote>
  <p><strong>Definition.</strong></p>

\[\langle a, b \rangle = \frac{(a + b)(a + b + 1)}{2} + b\]
</blockquote>

<p>Thus we can encode a tuple $\tau$ as a natural number $n$. Conversely, given $n$, we can decode $\tau$ using only addition, multiplication, and the modulo operation. Since the modulo operation is easily definable from addition, multiplication, and first-order logic, our goal is achieved.</p>

<p>Historically, Gödel’s theorem was as follows:</p>

<blockquote>
  <p><strong>$\beta$-function Lemma.</strong> For any sequence of natural numbers $(n_1, \dots, n_k)$, there exist natural numbers $a, b$ such that $\beta(a, b, i) = n_i$ for $1 \leq i \leq k$, where $\beta$ is the function defined as follows:</p>

\[\beta(x, y, i) = x \bmod (iy + 1)\]
</blockquote>

<p>For this reason, the entire process is called <strong>beta encoding</strong>. Gödel used beta encoding to successfully define exponentiation and prime factorisation in PA, enabling the formalisation of Gödel numbers and various related predicates in PA. As indicated by the title, the original goal of this article was to provide an overview of this entire process. However, due to the author’s tardily arriving laziness and the belief that readers who have come this far can easily infer the subsequent content, I shall conclude here.</p>


  </div>
  <div style="margin-bottom: 6em"></div>
  
    <div class="post fade-in-section" data-lang="ko" style="display: none">
      <h1 class="post-title">
        <a href="/2025/01/25/los"> 워시의 정리 </a>
      </h1>
    <span class="post-date">25 Jan 2025</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/수학/'">
        수학
      </div>
      
      <div class="tag" onclick="location.href='/tags/논리학/'">
        논리학
      </div>
      
    </div>
     <p><a href="https://dimenerno.github.io/2025/01/22/hypernaturals/">이전 글</a>에서 이어지는 내용이다.</p>

<h2 id="5-초자연수의-비표준적-특징">5. 초자연수의 비표준적 특징</h2>

<p>지금까지 우리가 살펴본 초자연수는 $[0], [1], [2], \dots$와 같이 표준 자연수와 상응하는 것들이었다. 이제 표준 자연수와는 괴리가 있는 초자연수들을 살펴 보자.</p>

<p>다음의 초자연수 $\mathfrak{n}$을 보자.</p>

\[(1, 2, 3, 4, \dots) \in \mathfrak{n}\]

<p>초자연수의 정의가 동치류이기 때문에 등호가 아닌 포함 관계로 표현함에 유의하라. 초자연수에서 부등호의 정의를 상기하면, 자연수 $n$에 대해 $[n] &lt; \mathfrak{n}$임을 알 수 있다. 즉, $\mathfrak{n}$은 모든 자연수보다 큰 초자연수이다. 따라서 초자연수에서는 다음이 성립한다.</p>

\[\phi_1 : \exists x \; ( \lbrace y : y &lt; x \rbrace \text{ is infinite } )\]

<p>위 명제는 자연수에서는 성립하지 않는다.</p>

<p>이번에는 다음의 초자연수 $\mathfrak{m}$을 보자.</p>

\[(1, 2!, 3!, 4!, \dots) \in \mathfrak{m}\]

<p>표준 자연수 $n$에 대해 $\mathfrak{m}$은 $[n]$으로 나누어떨어진다. 즉, $\mathfrak{m}$은 모든 자연수를 약수로 가진다. 따라서 초자연수에서는 다음이 성립한다.</p>

\[\phi_2 : \exists x \; (\lbrace y : y \mid x \rbrace \text{ is infinite })\]

<p>위 명제 또한 자연수에서는 성립하지 않는다.</p>

<p>그런데 이상한 점이 있다. 저번 글의 서론에서 필자는 자연수와 초자연수가 논리적으로 구분 불가능하다고 했다. 그러나 $\phi_1$과 $\phi_2$는 $\mathbb{N}^*$에서는 참이지만 $\mathbb{N}$에서는 거짓이므로, 둘은 논리적으로 구분 가능한 것으로 보인다. 필자가 거짓말을 한 것일까?</p>

<p>그렇지 않다. 이 표면적인 역설을 해결하는 실마리는, $\phi_1$과 $\phi_2$가 1차 논리로 표현 <em>불가능한</em> 문장이라는 사실이다. 콤팩트성 정리에 의해 “…가 유한하다”는 1차 논리로 표현 불가능하기 때문이다.</p>

<p>$\mathbb{N}^*$과 $\mathbb{N}$이 논리적으로 구분 불가능하다는 말의 엄밀한 의미는 다음과 같다.</p>

<blockquote>
  <p><strong>정의.</strong> 언어 $\mathcal{L}$의 모형 $\mathcal{M}_1$과 $\mathcal{M}_2$가 <strong>초등적으로 동등(elementarily equivalent)</strong>하다는 것은 임의의 (1차 논리) 문장 $\phi$에 대해</p>

\[\mathcal{M_1} \vDash \phi \iff \mathcal{M}_2 \vDash \phi\]

  <p>가 성립하는 것이다.</p>
</blockquote>

<blockquote>
  <p><strong>정리.</strong> $\mathbb{N}$과 $\mathbb{N}^*$은 초등적으로 동등하다.</p>
</blockquote>

<p>위 정리는 워시의 정리의 특수한 결과이다. 워시의 정리를 소개하기 앞서, 일반화된 초곱의 개념을 먼저 살펴보자.</p>

<h2 id="6-초곱">6. 초곱</h2>

<p>집합 $I$와, $I$ 위의 자유 초필터 $\mathcal{U}$가 주어졌다고 하자. 또한, 언어 $\mathcal{L}$의 모형 $\lbrace \mathcal{M}_i \rbrace_{i \in I}$가 주어졌다고 하자. 이때, <strong>초곱(ultraproduct)</strong> $\mathcal{M}^* = \prod \mathcal{M}_i / \mathcal{U}$를 다음과 같이 정의한다.</p>

<blockquote>
  <h4 id="초곱의-원소">초곱의 원소</h4>

  <p>$\mathcal{M}^*$의 원소는 $\lbrace (a_i)_{i\in I} : a_i \in \mathcal{M}_i \rbrace$가 $\sim$에 대해 이루는 동치류이다. 여기서 $\sim$은 다음과 같이 정의된다.</p>

\[(a_i)_{i\in I} \sim (b_i)_{i \in I} \iff \lbrace i \in I : a_i = b_i \rbrace \in \mathcal{U}\]

  <h4 id="초곱-위의-연산">초곱 위의 연산</h4>

  <p>$f(x)$가 $\mathcal{L}$의 함수라고 하자. $\mathcal{M}^*$의 원소 $\mathfrak{a} = [(a_i)_{i\in I}]$에 대해 다음과 같이 정의한다.</p>

\[f(\mathfrak{a}) = [(f(a_i))_{i \in I}]\]

  <p>위 정의는 자연스러운 방식으로 $n$항 함수로 일반화된다.</p>

  <h4 id="초곱-위의-술어">초곱 위의 술어</h4>

  <p>$P(x, y)$가 $\mathcal{L}$의 술어라고 하자. $\mathcal{M}^*$의 두 원소 $\mathfrak{a} = [(a_i)_{i\in I}]$와 $\mathfrak{b} = [(b_i)_{i\in I}]$에 대해 다음과 같이 정의한다.</p>

\[\mathcal{M}^* \vDash P(\mathfrak{a}, \mathfrak{b}) \iff \lbrace i \in I : \mathcal{M}_i \vDash P(a_i, b_i) \rbrace \in \mathcal{U}\]

  <p>위 정의는 자연스러운 방식으로 $n$항 술어로 일반화된다.</p>
</blockquote>

<p>초곱 위의 연산과 술어를 정의할 때, 연산과 술어의 결과가 동치류에서 어떤 원소를 대표자로 선택하든 상관없이 같음을 보여야 한다. 이것은 $\mathcal{U}$의 교집합 속성으로부터 어렵지 않게 얻어지므로 연습문제로 남긴다.</p>

<p>이로써 우리는 초자연수를, $I, \mathcal{U}, \mathcal{L}, \mathcal{M}_i$가 각각 다음과 같을 때 도출되는 초곱으로 재정의할 수 있다.</p>

<ul>
  <li>$I = \mathbb{N}$</li>
  <li>$\mathcal{U} =$ 프레셰 초필터</li>
  <li>$\mathcal{L} = (0, S, &lt;)$</li>
  <li>$\mathcal{M}_i = \mathbb{N}$</li>
</ul>

<p>비슷한 방식으로 <strong>초실수(hyperreals)</strong>를 정의할 수 있다.</p>

<ul>
  <li>$I = \mathbb{N}$</li>
  <li>$\mathcal{U} =$ 프레셰 초필터</li>
  <li>$\mathcal{L} = (0, 1, +, ⋅, &lt;)$</li>
  <li>$\mathcal{M}_i = \mathbb{R}$</li>
</ul>

<h2 id="7-워시의-정리">7. 워시의 정리</h2>

<blockquote>
  <p><strong>워시의 정리(Łoś’s Theorem).</strong> 초곱 $\mathcal{M}^* = \prod \mathcal{M}_i / \mathcal{U}$가 주어졌을 때, 임의의 $\mathcal{L}$-문장 $\phi$에 대해 다음이 성립한다.</p>

\[\mathcal{M}^* \vDash \phi \iff \lbrace i \in I : \mathcal{M}_i \vDash \phi \rbrace \in \mathcal{U}\]
</blockquote>

<p><em>Proof.</em> $\phi$에 대한 구조적 귀납법으로 증명한다.</p>

<h4 id="1-phi가-원자-명제이다">1. $\phi$가 원자 명제이다</h4>

<p>“초곱 위의 술어” 정의에 의해 자명하게 성립한다.</p>

<h4 id="2-phi--psi-land-theta">2. $\phi := \psi \land \theta$</h4>

\[\begin{aligned}
&amp;\mathcal{M}^* ⊨ φ\\
&amp;\iff \mathcal{M}^* ⊨ ψ \land \mathcal{M}^* ⊨ θ\\
&amp;\iff \lbrace i ∈ I \mid \mathcal{M}_i ⊨ ψ \rbrace ∈ \mathcal{U} \land \lbrace i ∈ I \mid \mathcal{M}_i ⊨ θ \rbrace ∈ \mathcal{U} &amp;&amp;(*)
\\
&amp;\iff \lbrace i ∈ I \mid \mathcal{M}_i ⊨ ψ \rbrace \cap \lbrace i ∈ I \mid \mathcal{M}_i ⊨ θ \rbrace ∈ \mathcal{U} &amp;&amp;(**) \\
&amp;\iff \lbrace i ∈ I \mid \mathcal{M}_i ⊨ ψ \land \mathcal{M}_i ⊨ θ \rbrace ∈ \mathcal{U}\\
&amp;\iff \lbrace i ∈ I \mid \mathcal{M}_i ⊨ ψ∧θ \rbrace ∈ \mathcal{U}\\
&amp;\iff \lbrace i ∈ I \mid \mathcal{M}_i ⊨ φ \rbrace ∈ \mathcal{U}
\end{aligned}\]

<p>$(*)$는 귀납 가정에 의해 성립하고, $(**)$는 $\mathcal{U}$의 교집합 닫힘 속성으로 성립한다.</p>

<h4 id="3-phi--lnot-psi">3. $\phi := \lnot \psi$</h4>

<p>2와 비슷한 방법으로 하면 된다. 단, 귀납 가정과 $\mathcal{U}$의 초필터 속성($A \in \mathcal{U} \lor A^c \in \mathcal{U}$)를 사용한다.</p>

<h4 id="4-phi--exists-x-psi">4. $\phi := \exists x\; \psi$</h4>

<p>2와 비슷한 방법으로 하면 된다. 단, 귀납 가정만 사용해도 충분하다.</p>

<p>모든 명제는 1, 2, 3, 4로 구성할 수 있으므로 귀납법에 의해 정리가 증명되었다. ■</p>

<blockquote>
  <p><strong>따름정리.</strong> $\mathbb{N}$과 $\mathbb{N}^*$은 초등적으로 동등하다.</p>
</blockquote>

<p><em>Proof.</em> 워시의 정리에 의해 $\mathbb{N}^* \vDash \phi$일 필요충분조건은 $\lbrace i \in \mathbb{N} : \mathbb{N}^\ast_i \vDash \phi \rbrace \in \mathcal{U}$인 것이다. 그런데 $\mathbb{N}^*_i = \mathbb{N}$이므로, 필요충분조건은 $\mathbb{N} \vDash \phi$로 환원된다. ■</p>

  </div>
  <div style="margin-bottom: 6em"></div>
  
    <div class="post fade-in-section" data-lang="en" style="display: none">
      <h1 class="post-title">
        <a href="/2025/01/25/los/en"> Łoś's Theorem </a>
      </h1>
    <span class="post-date">25 Jan 2025</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/mathematics/'">
        Mathematics
      </div>
      
      <div class="tag" onclick="location.href='/tags/logic/'">
        Logic
      </div>
      
    </div>
     <blockquote>
  <p>This post was machine translated and has not yet been proofread. It may contain minor errors or unnatural expressions. Proofreading will be done in the near future.</p>
</blockquote>

<p>This content continues from the <a href="https://dimenerno.github.io/2025/01/22/hypernaturals/">previous article</a>.</p>

<h2 id="5-nonstandard-characteristics-of-hypernatural-numbers">5. Nonstandard Characteristics of Hypernatural Numbers</h2>

<p>Thus far, the hypernatural numbers we have examined have been those corresponding to standard natural numbers, such as $[0], [1], [2], \dots$. We shall now examine hypernatural numbers that diverge from the standard natural numbers.</p>

<p>Consider the following hypernatural number $\mathfrak{n}$:</p>

\[(1, 2, 3, 4, \dots) \in \mathfrak{n}\]

<p>Note that we express this as a membership relation rather than equality, as the definition of hypernatural numbers involves equivalence classes. Recalling the definition of inequality in hypernatural numbers, we observe that for any natural number $n$, we have $[n] &lt; \mathfrak{n}$. That is, $\mathfrak{n}$ is a hypernatural number greater than all natural numbers. Therefore, the following holds in the hypernatural numbers:</p>

\[\phi_1 : \exists x \; ( \lbrace y : y &lt; x \rbrace \text{ is infinite } )\]

<p>This proposition does not hold in the natural numbers.</p>

<p>Now consider the following hypernatural number $\mathfrak{m}$:</p>

\[(1, 2!, 3!, 4!, \dots) \in \mathfrak{m}\]

<p>For any standard natural number $n$, $\mathfrak{m}$ is divisible by $[n]$. That is, $\mathfrak{m}$ has every natural number as a divisor. Therefore, the following holds in the hypernatural numbers:</p>

\[\phi_2 : \exists x \; (\lbrace y : y \mid x \rbrace \text{ is infinite })\]

<p>This proposition also does not hold in the natural numbers.</p>

<p>However, there appears to be something peculiar here. In the introduction to the previous article, I stated that the natural numbers and hypernatural numbers are logically indistinguishable. Yet $\phi_1$ and $\phi_2$ are true in $\mathbb{N}^*$ but false in $\mathbb{N}$, suggesting that they are logically distinguishable. Have I been misleading?</p>

<p>Not at all. The key to resolving this apparent paradox lies in the fact that $\phi_1$ and $\phi_2$ are sentences that cannot be expressed in first-order logic. By the compactness theorem, “… is finite” cannot be expressed in first-order logic.</p>

<p>The precise meaning of the statement that $\mathbb{N}^*$ and $\mathbb{N}$ are logically indistinguishable is as follows:</p>

<blockquote>
  <p><strong>Definition.</strong> Two models $\mathcal{M}_1$ and $\mathcal{M}_2$ of a language $\mathcal{L}$ are <strong>elementarily equivalent</strong> if for any (first-order logic) sentence $\phi$,</p>

\[\mathcal{M_1} \vDash \phi \iff \mathcal{M}_2 \vDash \phi\]
</blockquote>

<blockquote>
  <p><strong>Theorem.</strong> $\mathbb{N}$ and $\mathbb{N}^*$ are elementarily equivalent.</p>
</blockquote>

<p>This theorem is a special case of Łoś’s theorem. Before introducing Łoś’s theorem, let us first examine the concept of generalised ultraproducts.</p>

<h2 id="6-ultraproducts">6. Ultraproducts</h2>

<p>Let a set $I$ and a free ultrafilter $\mathcal{U}$ on $I$ be given. Furthermore, let models $\lbrace \mathcal{M}_i \rbrace_{i \in I}$ of a language $\mathcal{L}$ be given. We define the <strong>ultraproduct</strong> $\mathcal{M}^* = \prod \mathcal{M}_i / \mathcal{U}$ as follows:</p>

<blockquote>
  <h4 id="elements-of-the-ultraproduct">Elements of the Ultraproduct</h4>

  <p>The elements of $\mathcal{M}^*$ are equivalence classes of $\lbrace (a_i)_{i\in I} : a_i \in \mathcal{M}_i \rbrace$ under the relation $\sim$, where $\sim$ is defined as:</p>

\[(a_i)_{i\in I} \sim (b_i)_{i \in I} \iff \lbrace i \in I : a_i = b_i \rbrace \in \mathcal{U}\]

  <h4 id="operations-on-the-ultraproduct">Operations on the Ultraproduct</h4>

  <p>Let $f(x)$ be a function in $\mathcal{L}$. For an element $\mathfrak{a} = [(a_i)_{i\in I}]$ of $\mathcal{M}^*$, we define:</p>

\[f(\mathfrak{a}) = [(f(a_i))_{i \in I}]\]

  <p>This definition generalises naturally to $n$-ary functions.</p>

  <h4 id="predicates-on-the-ultraproduct">Predicates on the Ultraproduct</h4>

  <p>Let $P(x, y)$ be a predicate in $\mathcal{L}$. For two elements $\mathfrak{a} = [(a_i)_{i\in I}]$ and $\mathfrak{b} = [(b_i)_{i\in I}]$ of $\mathcal{M}^*$, we define:</p>

\[\mathcal{M}^* \vDash P(\mathfrak{a}, \mathfrak{b}) \iff \lbrace i \in I : \mathcal{M}_i \vDash P(a_i, b_i) \rbrace \in \mathcal{U}\]

  <p>This definition generalises naturally to $n$-ary predicates.</p>
</blockquote>

<p>When defining operations and predicates on the ultraproduct, one must show that the results of operations and predicates are the same regardless of which element is chosen as a representative in the equivalence class. This follows readily from the intersection property of $\mathcal{U}$, so we leave it as an exercise.</p>

<p>We can now redefine the hypernatural numbers as the ultraproduct arising when $I, \mathcal{U}, \mathcal{L}, \mathcal{M}_i$ are respectively:</p>

<ul>
  <li>$I = \mathbb{N}$</li>
  <li>$\mathcal{U} =$ Fréchet ultrafilter</li>
  <li>$\mathcal{L} = (0, S, &lt;)$</li>
  <li>$\mathcal{M}_i = \mathbb{N}$</li>
</ul>

<p>Similarly, we can define the <strong>hyperreal numbers</strong>:</p>

<ul>
  <li>$I = \mathbb{N}$</li>
  <li>$\mathcal{U} =$ Fréchet ultrafilter</li>
  <li>$\mathcal{L} = (0, 1, +, ⋅, &lt;)$</li>
  <li>$\mathcal{M}_i = \mathbb{R}$</li>
</ul>

<h2 id="7-łośs-theorem">7. Łoś’s Theorem</h2>

<blockquote>
  <p><strong>Łoś’s Theorem.</strong> Given an ultraproduct $\mathcal{M}^* = \prod \mathcal{M}_i / \mathcal{U}$, for any $\mathcal{L}$-sentence $\phi$, the following holds:</p>

\[\mathcal{M}^* \vDash \phi \iff \lbrace i \in I : \mathcal{M}_i \vDash \phi \rbrace \in \mathcal{U}\]
</blockquote>

<p><em>Proof.</em> We prove this by structural induction on $\phi$.</p>

<h4 id="1-phi-is-an-atomic-proposition">1. $\phi$ is an atomic proposition</h4>

<p>This follows trivially from the definition of predicates on ultraproducts.</p>

<h4 id="2-phi--psi-land-theta">2. $\phi := \psi \land \theta$</h4>

\[\begin{aligned}
&amp;\mathcal{M}^* ⊨ φ\\
&amp;\iff \mathcal{M}^* ⊨ ψ \land \mathcal{M}^* ⊨ θ\\
&amp;\iff \lbrace i ∈ I \mid \mathcal{M}_i ⊨ ψ \rbrace ∈ \mathcal{U} \land \lbrace i ∈ I \mid \mathcal{M}_i ⊨ θ \rbrace ∈ \mathcal{U} &amp;&amp;(*)
\\
&amp;\iff \lbrace i ∈ I \mid \mathcal{M}_i ⊨ ψ \rbrace \cap \lbrace i ∈ I \mid \mathcal{M}_i ⊨ θ \rbrace ∈ \mathcal{U} &amp;&amp;(**) \\
&amp;\iff \lbrace i ∈ I \mid \mathcal{M}_i ⊨ ψ \land \mathcal{M}_i ⊨ θ \rbrace ∈ \mathcal{U}\\
&amp;\iff \lbrace i ∈ I \mid \mathcal{M}_i ⊨ ψ∧θ \rbrace ∈ \mathcal{U}\\
&amp;\iff \lbrace i ∈ I \mid \mathcal{M}_i ⊨ φ \rbrace ∈ \mathcal{U}
\end{aligned}\]

<p>$(*)$ holds by the inductive hypothesis, and $(**)$ holds by the intersection closure property of $\mathcal{U}$.</p>

<h4 id="3-phi--lnot-psi">3. $\phi := \lnot \psi$</h4>

<p>This can be proved by a similar method to case 2, using the inductive hypothesis and the ultrafilter property of $\mathcal{U}$ ($A \in \mathcal{U} \lor A^c \in \mathcal{U}$).</p>

<h4 id="4-phi--exists-x-psi">4. $\phi := \exists x\; \psi$</h4>

<p>This can be proved by a similar method to case 2, though the inductive hypothesis alone suffices.</p>

<p>Since every proposition can be constructed from cases 1, 2, 3, and 4, the theorem is proved by induction. ■</p>

<blockquote>
  <p><strong>Corollary.</strong> $\mathbb{N}$ and $\mathbb{N}^*$ are elementarily equivalent.</p>
</blockquote>

<p><em>Proof.</em> By Łoś’s theorem, the necessary and sufficient condition for $\mathbb{N}^* \vDash \phi$ is that $\lbrace i \in \mathbb{N} : \mathbb{N}^\ast_i \vDash \phi \rbrace \in \mathcal{U}$. However, since $\mathbb{N}^*_i = \mathbb{N}$, the necessary and sufficient condition reduces to $\mathbb{N} \vDash \phi$. ■</p>

  </div>
  <div style="margin-bottom: 6em"></div>
  
    <div class="post fade-in-section" data-lang="ko" style="display: none">
      <h1 class="post-title">
        <a href="/2025/01/22/hypernaturals"> 프레셰 필터와 비표준 자연수 </a>
      </h1>
    <span class="post-date">22 Jan 2025</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/수학/'">
        수학
      </div>
      
      <div class="tag" onclick="location.href='/tags/논리학/'">
        논리학
      </div>
      
    </div>
     <p>뢰벤하임-스콜렘 정리에 따르면 표준 산술 모형과 초등적으로 동등(elementarily equivalent)하지만 구조적으로 상이(nonisomorphic)한 모형이 존재한다. 달리 말해, 자연수가 만족하는 모든 1차 논리 명제를 만족하지만 자연수가 아닌 수 체계가 존재한다.</p>

<p>이 글(시리즈)에서는 <strong>초곱(ultraproduct)</strong>을 이용하여 대표적인 산술의 비표준적 모형인 <strong>초자연수(hypernaturals)</strong>를 구성하고, 이것이 표준 산술 모형과 초등적으로 동등함을 보증하는 <strong>워시의 정리(Łoś’s theorem)</strong>를 증명한다.</p>

<h2 id="1-개괄">1. 개괄</h2>

<p>콤팩트성 정리에 의해 우리는 1차 논리가 유한과 무한을 구별하지 못함을 안다. 따라서 무한을 적절히 사용함으로써 자연수와 1차 논리적으로 구분 불가능한 모델을 정의할 수 있으리라 기대해봄직하다.</p>

<p>이에 따라 다음과 같이 초자연수 $[0], [1], [2], \dots$를 정의하자.</p>

\[\begin{aligned}
[][0] &amp;= (0, 0, 0, 0, 0, \dots) \\
[1] &amp;= (1, 1, 1, 1, 1, \dots) \\
[2] &amp;= (2, 2, 2, 2, 2, \dots)
\end{aligned}\]

<p>그런데 생각해 보면 모든 항이 0으로 차 있어야 $[0]$으로 간주하는 것은 지나치게 엄격하다. 예를 들어 처음 두 개의 항만 1이고 나머지 항은 모두 0인 튜플 $(1, 1, 0, 0, 0, \dots)$ 또한 $[0]$으로 보는 것이 자연스럽다. 따라서 유한 개의 항을 제외한 모든 항이 $n$이라면 그 튜플 또한 $[n]$으로 간주하도록 하자. 즉,</p>

\[[n] = \lbrace (x_1, x_2, x_3, \dots) \in \mathbb{N}^\omega : \lbrace i \in \mathbb{N}: x_i \neq n \rbrace \text{ is finite} \rbrace\]

<p>하지만 이제 다음의 문제가 생긴다. 다음 튜플은 $[0]$으로 간주해야 하는가, $[1]$로 간주해야 하는가?</p>

\[(0, 1, 0, 1, 0, 1, \dots)\]

<p>이 모호함을 제거하기 위해 우리는 짝수 집합과 홀수 집합 중 하나를 임의로 채택할 것이다. 만약 짝수 집합을 채택했다면 위 튜플은 $[0]$이 되고(인덱스는 0부터 시작하는 것으로 전제한다) 홀수 집합을 채택했다면 $[1]$이 될 것이다.</p>

<p>하지만 이 채택의 과정에는 주의가 필요하다. 만약 6의 배수의 집합이 채택되었다면, 3의 배수의 집합 또한 채택되어야 논리적으로 일관된다. 후자를 만족하는 튜플은 자명하게 전자를 만족하기 때문이다. 그리고 3의 배수의 집합이 채택되었으므로, 3의 배수가 <em>아닌</em> 수의 집합은 기각되어야 한다. 자연수의 모든 부분집합에 대해 이같은 채택과 기각의 과정을 거친 결과물은 <strong>초필터(ultrafilter)</strong>라고 불리는 구조와 상응될 것이다. 적절한 초필터가 주어지면 그것을 토대로 임의의 튜플을 초자연수에 대응시킬 수 있으며, 이 전체적인 과정을 <strong>초곱(ultraproduct)</strong>이라고 부른다.</p>

<h2 id="2-초필터의-정의">2. 초필터의 정의</h2>

<blockquote>
  <p><strong>정의.</strong> $X$가 집합이라고 하자. $X$의 부분집합들로 이루어진 집합 $\mathcal{F}$가 다음을 만족할 때, $X$의 <strong>필터</strong>라고 부른다.</p>

  <ol>
    <li>$X \in \mathcal{F}$</li>
    <li>$\varnothing \not\in \mathcal{F}$</li>
    <li>상위집합 닫힘: $A \in \mathcal{F}, A \subset B \implies B \in \mathcal{F}$</li>
    <li>유한 교집합 닫힘: $A, B \in \mathcal{F} \implies A \cap B \in \mathcal{F}$</li>
  </ol>
</blockquote>

<p>직관적으로 필터는 “큰 집합들의 모임”이다. 이 관점에서 보면 1번과 2번 공리는 전체집합은 크고 공집합은 작다는 자명한 원리를 진술한다. 3번 공리는 큰 집합을 포함하는 집합은 크다는 원리를, 4번 공리는 큰 집합끼리 유한 번 교집합을 해도 여전히 크다는 원리를 진술한다.</p>

<p>여담으로 필터는 초곱뿐 아니라 퍼지 논리(fuzzy logic)의 모형을 고전 논리의 모형으로 변환하는 데도 쓰인다. 이때 필터는 “큰 집합들의 모임”이 아닌 “참인 문장들의 모임”이 된다. 그리고 퍼지 논리에서 고전 논리로의 변환은 코헨의 강제법을 이해하는 한 가지 방식이기도 하다.</p>

<p><strong>하세 다이어그램(Hasse diagram)</strong>을 통해 필터를 더 직관적으로 이해할 수 있다. 색칠된 영역은 $X = \lbrace 0, 1, 2 \rbrace$의 필터이다. 하세 다이어그램을 $\varnothing$에서 $X$로 가는 물줄기의 흐름으로 이해하면, 특정 지점에 잉크를 떨어뜨렸을 때 그 잉크가 퍼져 나가는 영역은 필터를 이룬다.</p>

<p><img src="https://velog.velcdn.com/images/dimenerno/post/86ac1e36-13fe-46fb-a9cc-b6749d1c5a69/image.png" width="400px" style="margin: 20px auto 30px auto;" /></p>

<p>2번 공리와 4번 공리에 의해, $A \in \mathcal{F}$라면 $A^c := X \setminus A \notin \mathcal{F}$이다. 이 사실을 강화하여, $X$의 <em>모든</em> 부분집합에 대해 그 집합 또는 여집합이 필터에 있을 것을 요구하면 <strong>초필터(ultrafilter)</strong>의 정의를 얻는다.</p>

<blockquote>
  <p><strong>정의.</strong> $X$의 필터 $\mathcal{F}$가 다음을 만족할 때 $\mathcal{F}$는 초필터이다.</p>

\[\forall A \in \mathcal{P}(X) : A \in \mathcal{F} \lor A^c \in \mathcal{F}\]
</blockquote>

<p>앞선 그림의 필터는 초필터이다. 초필터는 하세 다이어그램의 정확히 절반을 차지한다는 사실에 주목하라.</p>

<h2 id="3-무한집합에서의-초필터">3. 무한집합에서의 초필터</h2>

<p>최소(least) 원소를 가지는 필터를 주 필터(principal filter)라고 하며, 주 필터가 아닌 필터를 자유 필터(free filter)라고 한다. 지금까지 우리가 본 모든 필터는 주 필터로, “특정 지점에 떨어뜨린 잉크가 퍼져 나가는 영역”의 이미지와 완전히 부합한다.</p>

<p>주 필터와 달리 자유 필터는 직관적으로 포착하기 힘들다. 다음의 정리 때문이다.</p>

<blockquote>
  <p><strong>정리.</strong> 유한집합 위의 필터는 모두 주 필터이다.</p>
</blockquote>

<p><em>Proof.</em> $A_0 \in \mathcal{F}$가 최소 원소가 아니라고 하자. 그러면 어떤 $B \in \mathcal{F}$가 존재하여 $A_1 = A_0 \cap B \subsetneq A$이다. 즉, $|A_1| &lt; |A_0 |$이다. $A_1$이 최소 원소라면 증명이 끝나고, 아니라면 똑같은 과정을 반복한다. 주어진 집합의 크기가 유한하므로 이 과정은 계속 반복될 수 없으며, 최소 원소에 종착하게 된다. ■</p>

<p>위 정리는 이렇게 이해할 수도 있다. 자유 필터는 그 내부에 무한히 이어지지만 (따라서 유한 교집합만으로 최소 원소에 도달할 수 없다) 공집합에 도달하지는 않는 부분집합의 체인을 가지는 필터이다. 이에 따라 무한집합 위의 필터만이 자유 필터가 될 수 있다.</p>

<p><img src="https://velog.velcdn.com/images/dimenerno/post/3769cca8-52df-4faa-af87-4225e588e89d/image.png" alt="" /></p>

<p>그 실례를 살펴보자.</p>

<blockquote>
  <p><strong>정의.</strong> $X$가 무한집합이라고 하자. $A \subset X$가 <strong>여유한(cofinite)</strong>하다는 것은 $X \setminus A$가 유한집합인 것이다.</p>
</blockquote>

<blockquote>
  <p><strong>정리.</strong> $\mathbb{N}$의 모든 여유한 부분집합의 모임을 $\mathcal{F}$라고 하자. $\mathcal{F}$는 자유 필터이다.</p>
</blockquote>

<p>증명은 연습문제로 남긴다. 위 정리의 $\mathcal{F}$를 <strong>프레셰 필터(Fréchet filter)</strong>라고 부른다. 일례로 10보다 큰 수들의 집합 $\lbrace 11, 12, 13, 14, \dots \rbrace$은 $\mathcal{F}$의 원소이지만, 짝수의 집합은 $\mathcal{F}$의 원소가 아니다.</p>

<p>프레셰 필터는 초필터가 아니다. 하지만 다음 정리에 의해 초필터로 확장할 수 있다.</p>

<blockquote>
  <p><strong>정리.</strong> 모든 필터는 초필터로 확장될 수 있다.</p>
</blockquote>

<p><em>Proof.</em> $X$의 모든 필터들의 모임 $\Omega$에 포함 관계로 정의되는 순서를 주자. 이 순서 하에서 체인을 이루는 필터들의 합집합은 필터임을 어렵지 않게 보일 수 있다. 따라서 초른의 보조정리에 의해 $\Omega$는 극대(maximal) 원소 $\mathcal{U}$를 가진다. 만약 $\mathcal{U}$가 초필터가 아니라면, 어떤 $A_0 \subset X$가 존재하여 $A_0, A_0^c \notin U$이다. 이제 다음과 같이 $\mathcal{V}$를 정의한다.</p>

\[\mathcal{V} = \mathcal{U} \cup \lbrace A \subset X : A_0 \subset A \rbrace \cup \lbrace A_0 \cap U : U \in \mathcal{U} \rbrace\]

<p>$\mathcal{V}$는 필터임을 확인할 수 있다. 이것은 $\mathcal{U}$의 극대성에 위배된다. 따라서 $\mathcal{U}$는 초필터이다. ■</p>

<p>따라서 자연수 집합은 프레셰 필터로부터 확장되는 자유 초필터를 가진다. 이 필터를 <strong>프레셰 초필터</strong>라고 부르자.</p>

<p><img src="https://velog.velcdn.com/images/dimenerno/post/30387200-2e80-4a74-82a2-b696ffe7e1cd/image.png" alt="" /></p>

<h2 id="4-초자연수">4. 초자연수</h2>

<p>지금까지의 논의를 정리하자면, 프레셰 초필터를 비롯한 자유 초필터는 다음의 성질을 가진다.</p>

<ol>
  <li>모든 여유한 집합을 원소로 가진다.</li>
  <li>유한집합은 원소로 가지지 않는다.</li>
  <li>$A \subset \mathbb{N}$일 때 $A$가 필터의 원소이거나 $A^c$가 필터의 원소이다.</li>
</ol>

<p>위 세 성질 덕분에 프레셰 초필터는 서론에서 초곱의 기초적인 아이디어를 개괄했을 때 맞닥뜨렸던 모호성의 문제를 해결하는 데 안성맞춤이다. 이제 우리는 다음과 같이 초자연수를 정의할 수 있다.</p>

<p>$\mathcal{U}$가 자유 초필터라고 하자. $\mathbb{N}^\omega$ 위에 다음의 동치 관계를 정의한다.</p>

\[(n_0, n_1, n_2, \dots) \sim (m_0, m_1, m_2, \dots) \iff \lbrace i \in \mathbb{N} : n_i = m_i \rbrace \in \mathcal{U}\]

<p>이것이 동치 관계임은 어렵지 않게 확인할 수 있다. 따라서 다음과 같이 동치류를 취할 수 있다.</p>

\[\mathbb{N}^* := \mathbb{N}^\omega/\sim\]

<p>$\mathbb{N}^*$을 <strong>초자연수(hypernaturals)</strong>라고 한다. 초자연수의 정의가 동치류인 것은 서론에서 초자연수를 $[n]$으로 적은 이유이다. 이제 남은 것은 초자연수의 연산과 술어 관계를 정의하는 것이다.</p>

<p>초자연수의 덧셈은 다음과 같이 자연스럽게 정의한다.</p>

\[(n_0, n_1, \dots) + (m_0, m_1, \dots) = (n_0 + m_0, n_1 + m_1, \dots)\]

<p>여기에는 한 가지 미묘한 문제가 있다. 초자연수의 정의가 동치류이기 때문에, 동치류의 어떤 원소를 택하더라도 위 덧셈의 결과에 영향을 주지 않음을 보여야 한다. 즉,</p>

\[\begin{gather}
(n_0, n_1, \dots), (n_0', n_1',  \dots) \in [n]\\
(m_0, m_1,  \dots), (m_0', m_1', \dots) \in [m]
\end{gather}\]

<p>에 대해,</p>

\[(n_0, n_1, \dots) + (m_0, m_1,  \dots), (n_0', n_1', \dots) + (m_0', m_1', \dots) \in [n + m]\]

<p>임을 보여야 한다. 다행히 이는 어렵지 않다.</p>

<p>곱셈과 역원 또한 비슷하게 정의하면 된다. 한편 $&lt;$와 같은 이항 관계는 다음과 같이 정의한다.</p>

\[(n_0, n_1, n_2, \dots) &lt; (m_0, m_1, m_2, \dots) \iff \lbrace i \in \mathbb{N} : n_i &lt; m_i \rbrace \in \mathcal{U}\]

<p>이 정의는 자연스럽게 삼항, 사항 관계로 일반화할 수 있다.</p>

<p>이로써 우리는 초자연수를 정의했다. 다음 글에서는 초자연수의 여러 비표준적인 특징과, 그런 비표준성에도 불구하고 초자연수와 자연수를 1차 논리로 구분할 수 없음을 보이는 워시의 정리를 살펴볼 것이다.</p>

  </div>
  <div style="margin-bottom: 6em"></div>
  
    <div class="post fade-in-section" data-lang="en" style="display: none">
      <h1 class="post-title">
        <a href="/2025/01/22/hypernaturals/en"> Fréchet Filters and Nonstandard Natural Numbers </a>
      </h1>
    <span class="post-date">22 Jan 2025</span>
    
    <div class="tag-container">
      
      <div class="tag" onclick="location.href='/tags/mathematics/'">
        Mathematics
      </div>
      
      <div class="tag" onclick="location.href='/tags/logic/'">
        Logic
      </div>
      
    </div>
     <blockquote>
  <p>This post was machine translated and has not yet been proofread. It may contain minor errors or unnatural expressions. Proofreading will be done in the near future.</p>
</blockquote>

<p>According to the Löwenheim-Skolem theorem, there exist models that are elementarily equivalent to the standard arithmetic model but structurally nonisomorphic. In other words, there exist number systems that satisfy all first-order logical statements satisfied by the natural numbers, yet are not the natural numbers themselves.</p>

<p>In this article (series), we construct the <strong>hypernaturals</strong>, a representative nonstandard model of arithmetic, using <strong>ultraproducts</strong>, and prove <strong>Łoś’s theorem</strong>, which guarantees that this model is elementarily equivalent to the standard arithmetic model.</p>

<h2 id="1-overview">1. Overview</h2>

<p>By the compactness theorem, we know that first-order logic cannot distinguish between the finite and the infinite. Therefore, we might reasonably expect to be able to define a model that is first-order logically indistinguishable from the natural numbers by appropriately employing infinity.</p>

<p>Accordingly, let us define the hypernaturals $[0], [1], [2], \dots$ as follows:</p>

\[\begin{aligned}
[0] &amp;= (0, 0, 0, 0, 0, \dots) \\
[1] &amp;= (1, 1, 1, 1, 1, \dots) \\
[2] &amp;= (2, 2, 2, 2, 2, \dots)
\end{aligned}\]

<p>However, upon reflection, requiring all entries to be 0 in order to regard something as $[0]$ is excessively stringent. For instance, it would be natural to regard the tuple $(1, 1, 0, 0, 0, \dots)$, where only the first two entries are 1 and all remaining entries are 0, as $[0]$ as well. Therefore, let us consider any tuple as $[n]$ if all but finitely many entries equal $n$. That is,</p>

\[[n] = \lbrace (x_1, x_2, x_3, \dots) \in \mathbb{N}^\omega : \lbrace i \in \mathbb{N}: x_i \neq n \rbrace \text{ is finite} \rbrace\]

<p>However, this now gives rise to the following problem. Should the following tuple be considered as $[0]$ or as $[1]$?</p>

\[(0, 1, 0, 1, 0, 1, \dots)\]

<p>To resolve this ambiguity, we shall arbitrarily adopt either the set of even numbers or the set of odd numbers. If we adopt the set of even numbers, the above tuple becomes $[0]$ (assuming indices begin from 0), whilst if we adopt the set of odd numbers, it becomes $[1]$.</p>

<p>However, this adoption process requires careful consideration. If the set of multiples of 6 is adopted, then the set of multiples of 3 must also be adopted for logical consistency, since tuples satisfying the latter trivially satisfy the former. Moreover, since the set of multiples of 3 is adopted, the set of numbers that are <em>not</em> multiples of 3 must be rejected. The result of this process of adoption and rejection for all subsets of the natural numbers will correspond to a structure called an <strong>ultrafilter</strong>. Given an appropriate ultrafilter, we can map any tuple to a hypernatural based upon it, and this entire process is called an <strong>ultraproduct</strong>.</p>

<h2 id="2-definition-of-ultrafilters">2. Definition of Ultrafilters</h2>

<blockquote>
  <p><strong>Definition.</strong> Let $X$ be a set. A collection $\mathcal{F}$ of subsets of $X$ is called a <strong>filter</strong> on $X$ if it satisfies the following:</p>

  <ol>
    <li>$X \in \mathcal{F}$</li>
    <li>$\varnothing \not\in \mathcal{F}$</li>
    <li>Upward closure: $A \in \mathcal{F}, A \subset B \implies B \in \mathcal{F}$</li>
    <li>Finite intersection closure: $A, B \in \mathcal{F} \implies A \cap B \in \mathcal{F}$</li>
  </ol>
</blockquote>

<p>Intuitively, a filter is a “collection of large sets”. From this perspective, axioms 1 and 2 express the trivial principle that the whole set is large and the empty set is small. Axiom 3 expresses the principle that a set containing a large set is large, whilst axiom 4 expresses the principle that finite intersections of large sets remain large.</p>

<p>As an aside, filters are used not only in ultraproducts but also in converting models of fuzzy logic into models of classical logic. In this context, filters become “collections of true statements” rather than “collections of large sets”. Moreover, the conversion from fuzzy logic to classical logic is also one way of understanding Cohen’s forcing method.</p>

<p>Filters can be understood more intuitively through <strong>Hasse diagrams</strong>. The shaded region represents a filter on $X = \lbrace 0, 1, 2 \rbrace$. If we understand the Hasse diagram as a flow of water from $\varnothing$ to $X$, the region where ink spreads when dropped at a particular point forms a filter.</p>

<p><img src="https://velog.velcdn.com/images/dimenerno/post/86ac1e36-13fe-46fb-a9cc-b6749d1c5a69/image.png" width="400px" style="margin: 20px auto 30px auto;" /></p>

<p>By axioms 2 and 4, if $A \in \mathcal{F}$, then $A^c := X \setminus A \notin \mathcal{F}$. Strengthening this fact by requiring that for <em>every</em> subset of $X$, either the set or its complement is in the filter, we obtain the definition of an <strong>ultrafilter</strong>.</p>

<blockquote>
  <p><strong>Definition.</strong> A filter $\mathcal{F}$ on $X$ is an ultrafilter if it satisfies:</p>

\[\forall A \in \mathcal{P}(X) : A \in \mathcal{F} \lor A^c \in \mathcal{F}\]
</blockquote>

<p>The filter in the previous diagram is an ultrafilter. Note that an ultrafilter occupies exactly half of the Hasse diagram.</p>

<h2 id="3-ultrafilters-on-infinite-sets">3. Ultrafilters on Infinite Sets</h2>

<p>A filter with a least element is called a principal filter, whilst a filter that is not principal is called a free filter. All filters we have seen so far are principal filters, which perfectly match the image of “the region where ink dropped at a specific point spreads”.</p>

<p>Unlike principal filters, free filters are difficult to grasp intuitively, due to the following theorem:</p>

<blockquote>
  <p><strong>Theorem.</strong> Every filter on a finite set is principal.</p>
</blockquote>

<p><em>Proof.</em> Suppose $A_0 \in \mathcal{F}$ is not a minimal element. Then there exists some $B \in \mathcal{F}$ such that $A_1 = A_0 \cap B \subsetneq A$. That is, $|A_1| &lt; |A_0 |$. If $A_1$ is a minimal element, the proof is complete; otherwise, we repeat the same process. Since the given set has finite cardinality, this process cannot continue indefinitely and must terminate at a minimal element. ■</p>

<p>This theorem can also be understood as follows: a free filter is one that contains an infinitely descending chain of subsets within it (and thus cannot reach a minimal element through finite intersections alone) but never reaches the empty set. Accordingly, only filters on infinite sets can be free filters.</p>

<p><img src="https://velog.velcdn.com/images/dimenerno/post/3769cca8-52df-4faa-af87-4225e588e89d/image.png" alt="" /></p>

<p>Let us examine a concrete example.</p>

<blockquote>
  <p><strong>Definition.</strong> Let $X$ be an infinite set. A subset $A \subset X$ is <strong>cofinite</strong> if $X \setminus A$ is a finite set.</p>
</blockquote>

<blockquote>
  <p><strong>Theorem.</strong> Let $\mathcal{F}$ be the collection of all cofinite subsets of $\mathbb{N}$. Then $\mathcal{F}$ is a free filter.</p>
</blockquote>

<p>The proof is left as an exercise. The $\mathcal{F}$ in the above theorem is called the <strong>Fréchet filter</strong>. For instance, the set of numbers greater than 10, $\lbrace 11, 12, 13, 14, \dots \rbrace$, is an element of $\mathcal{F}$, but the set of even numbers is not an element of $\mathcal{F}$.</p>

<p>The Fréchet filter is not an ultrafilter. However, it can be extended to an ultrafilter by the following theorem:</p>

<blockquote>
  <p><strong>Theorem.</strong> Every filter can be extended to an ultrafilter.</p>
</blockquote>

<p><em>Proof.</em> Let $\Omega$ be the collection of all filters on $X$, ordered by inclusion. Under this ordering, the union of filters forming a chain is itself a filter, as can be shown without difficulty. Therefore, by Zorn’s lemma, $\Omega$ has a maximal element $\mathcal{U}$. If $\mathcal{U}$ is not an ultrafilter, then there exists some $A_0 \subset X$ such that $A_0, A_0^c \notin U$. Define $\mathcal{V}$ as follows:</p>

\[\mathcal{V} = \mathcal{U} \cup \lbrace A \subset X : A_0 \subset A \rbrace \cup \lbrace A_0 \cap U : U \in \mathcal{U} \rbrace\]

<p>One can verify that $\mathcal{V}$ is a filter. This contradicts the maximality of $\mathcal{U}$. Therefore, $\mathcal{U}$ is an ultrafilter. ■</p>

<p>Hence, the set of natural numbers possesses a free ultrafilter extending from the Fréchet filter. Let us call this filter the <strong>Fréchet ultrafilter</strong>.</p>

<p><img src="https://velog.velcdn.com/images/dimenerno/post/30387200-2e80-4a74-82a2-b696ffe7e1cd/image.png" alt="" /></p>

<h2 id="4-the-hypernaturals">4. The Hypernaturals</h2>

<p>To summarise our discussion thus far, free ultrafilters, including the Fréchet ultrafilter, possess the following properties:</p>

<ol>
  <li>They contain all cofinite sets as elements.</li>
  <li>They do not contain finite sets as elements.</li>
  <li>For $A \subset \mathbb{N}$, either $A$ is an element of the filter or $A^c$ is an element of the filter.</li>
</ol>

<p>Thanks to these three properties, the Fréchet ultrafilter is perfectly suited to resolving the ambiguity problem we encountered when outlining the basic idea of ultraproducts in the introduction. We can now define the hypernaturals as follows:</p>

<p>Let $\mathcal{U}$ be a free ultrafilter. Define the following equivalence relation on $\mathbb{N}^\omega$:</p>

\[(n_0, n_1, n_2, \dots) \sim (m_0, m_1, m_2, \dots) \iff \lbrace i \in \mathbb{N} : n_i = m_i \rbrace \in \mathcal{U}\]

<p>It is not difficult to verify that this is indeed an equivalence relation. Therefore, we can take equivalence classes as follows:</p>

\[\mathbb{N}^* := \mathbb{N}^\omega/\sim\]

<p>We call $\mathbb{N}^*$ the <strong>hypernaturals</strong>. The reason we wrote hypernaturals as $[n]$ in the introduction is that the definition of hypernaturals consists of equivalence classes. What remains is to define operations and predicate relations on the hypernaturals.</p>

<p>Addition of hypernaturals is defined naturally as follows:</p>

\[(n_0, n_1, \dots) + (m_0, m_1, \dots) = (n_0 + m_0, n_1 + m_1, \dots)\]

<p>There is one subtle issue here. Since the definition of hypernaturals involves equivalence classes, we must show that the result of the above addition is unaffected regardless of which representative of an equivalence class we choose. That is, for</p>

\[\begin{gather}
(n_0, n_1, \dots), (n_0', n_1',  \dots) \in [n]\\
(m_0, m_1,  \dots), (m_0', m_1', \dots) \in [m]
\end{gather}\]

<p>we must show that</p>

\[(n_0, n_1, \dots) + (m_0, m_1,  \dots), (n_0', n_1', \dots) + (m_0', m_1', \dots) \in [n + m]\]

<p>Fortunately, this is not difficult to establish.</p>

<p>Multiplication and successor can be defined similarly. Meanwhile, binary relations such as $&lt;$ are defined as follows:</p>

\[(n_0, n_1, n_2, \dots) &lt; (m_0, m_1, m_2, \dots) \iff \lbrace i \in \mathbb{N} : n_i &lt; m_i \rbrace \in \mathcal{U}\]

<p>This definition can be naturally generalised to ternary and quaternary relations.</p>

<p>We have thus defined the hypernaturals. In the next article, we shall examine various nonstandard features of the hypernaturals and Łoś’s theorem, which shows that despite such nonstandardness, the hypernaturals and natural numbers cannot be distinguished by first-order logic.</p>


  </div>
  <div style="margin-bottom: 6em"></div>
  
</div>

<div class="pagination">
  
  <a
    class="pagination-item older lang-ko"
    href="/page9"
    >이전 글</a
  >
  <a
  class="pagination-item older lang-en"
  href="/page9"
  >Previous</a
>
    
  <a
    class="pagination-item newer lang-ko"
    href="/page7"
    >다음 글</a
  >
  <a
  class="pagination-item newer lang-en"
  href="/page7"
  >Next</a
>
   
</div>

<script>
  const faders = document.querySelectorAll(".fade-in-section");

  const appearOptions = {
    // threshold: 0.05,
    // rootMargin: "0px 0px 50px 0px",
  };

  const appearOnScroll = new IntersectionObserver((entries, observer) => {
    entries.forEach((entry) => {
      if (entry.isIntersecting) {
        entry.target.classList.add("is-visible");
        observer.unobserve(entry.target);
      }
    });
  }, appearOptions);

  faders.forEach((fader) => {
    appearOnScroll.observe(fader);
  });

  // 배너 이미지 로드 후 애니메이션 트리거 스크립트
  document.addEventListener("DOMContentLoaded", () => {

    const lang = localStorage.getItem("lang") || "ko";
  document.querySelectorAll('.post[data-lang]').forEach(post => {
    if (post.dataset.lang === lang) {
      post.style.display = '';
    }
  });

    const bannerImages = document.querySelectorAll(
      '.fade-rise-1[src="/public/banner.png"], .fade-rise-2[src="/public/banner-2.png"]'
    ); // 애니메이션 시작을 기다릴 이미지들
    const elementsToAnimate = document.querySelectorAll(
      ".fade-rise-1, .fade-rise-2, .fade-rise-3"
    ); // 애니메이션 될 요소들
    let loadedImagesCount = 0;
    const totalImagesToWait = bannerImages.length;

    // 기다릴 이미지가 없으면 즉시 애니메이션 시작
    if (totalImagesToWait === 0) {
      elementsToAnimate.forEach((el) => el.classList.add("is-loaded"));
      return;
    }

    const checkAllImagesLoaded = () => {
      if (loadedImagesCount === totalImagesToWait) {
        // 모든 이미지가 로드되면 애니메이션 클래스 추가
        elementsToAnimate.forEach((el) => el.classList.add("is-loaded"));
      }
    };

    bannerImages.forEach((img) => {
      // 이미지가 캐시되어 이미 로드 완료된 경우
      if (img.complete) {
        loadedImagesCount++;
      } else {
        // 이미지 로드 완료 이벤트 리스너 추가
        img.addEventListener("load", () => {
          loadedImagesCount++;
          checkAllImagesLoaded(); // 이미지 로드될 때마다 체크
        });
        // 에러 발생 시 처리 (선택 사항)
        img.addEventListener("error", () => {
          console.error("Failed to load image:", img.src);
          // 에러 발생 시에도 애니메이션을 시작하려면 여기서 loadedImagesCount를 증가시키거나 다른 로직 추가
          // 현재 로직에서는 에러 시 카운트가 증가하지 않아 모든 이미지 로드되지 않으면 애니메이션 안 시작
          loadedImagesCount++; // 에러 발생 시에도 카운트 증가 (모든 이미지를 처리했음을 알림)
          checkAllImagesLoaded();
        });
      }
    });

    // 모든 이미지에 대해 complete 상태를 확인하거나 리스너를 설정한 후,
    // 이미 모든 이미지가 로드 완료 상태였을 경우를 대비해 마지막으로 체크
    checkAllImagesLoaded();


    // Listen for language toggle changes and update post visibility dynamically
    const langToggle = document.getElementById("lang-toggle");
    if (langToggle) {
      langToggle.addEventListener("change", () => {
        const newLang = langToggle.checked ? "en" : "ko";
        localStorage.setItem("lang", newLang);
        document.querySelectorAll('.post[data-lang]').forEach(post => {
          post.style.display = post.dataset.lang === newLang ? '' : 'none';
        });
      });
    }
  });
</script>
</div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script src="/public/js/script.js"></script>
    <script src="/public/js/lang.js"></script>
  </body>
</html>
